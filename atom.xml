<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Techive</title>
  
  <subtitle>An Archive for Technologies</subtitle>
  <link href="/techive/atom.xml" rel="self"/>
  
  <link href="http://suzhouxing.github.io/techive/"/>
  <updated>2021-10-15T12:27:52.566Z</updated>
  <id>http://suzhouxing.github.io/techive/</id>
  
  <author>
    <name>Zhouxing Su</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>从羽毛球的角度谈科研</title>
    <link href="http://suzhouxing.github.io/techive/2021/10/03/FromBadmintonToResearch/"/>
    <id>http://suzhouxing.github.io/techive/2021/10/03/FromBadmintonToResearch/</id>
    <published>2021-10-03T03:52:37.000Z</published>
    <updated>2021-10-15T12:27:52.566Z</updated>
    
    <content type="html"><![CDATA[<p>羽毛球是一种技巧性很强的运动, 新手想要提高球技, 最大的困难往往在于纠正姿势. 不正确的姿势往往无法快速跑位导致接不到球, 或者接到回球质量很差打不到位, 长此以往还容易导致运动损伤. 相反地, 正确的姿势能够充分发挥全身的力量, 击球质量高打得有来有回不仅观赏性强, 锻炼效果也更好.</p><p>从握拍方式到挥拍动作再到移动步法, 既然采用正确的姿势有这么多好处, 为什么大多数人不愿意纠正姿势呢?</p><p>因为大家熟悉的打法上限虽低, 下限却比较高, 至少跟水平相当的人菜鸡互啄还是能碰到球的, 打多了水平也能有一定的提升. 而纠正姿势的过程是十分痛苦的, 往往要经历一段 "邯郸学步" 的状态, 变得连拍子都抓不稳球都不会打了. 概括地说, 绝大多数人太在乎一时的输赢与得失, 没有理解古人 "以退为进" 和 "磨刀不误砍柴工" 的智慧. 这是第一层原因 -- 放不下, 输不起.</p><p>另一方面, 很多人根本不知道有哪些 "基本功" 以及如何练习. 有些人可能根本没看过职业选手们的精彩对决; 有些人看过高手过招, 但是将其完全归功于天赋, 而对一招一式之间的共性无动于衷; 有些人知道基础训练的重要性, 但没有进一步思考运动员们到底训练了什么. 这是第二层原因 -- 不探索, 不总结.</p><p>此外, 还有些常见的劣根性, 在任何领域都是人类进步的阻碍. 有些人会找各种各样的借口自我欺骗, 而最普遍的自我欺骗, 便是 "下次我会努力克服这些问题". 这是第三层原因 -- 找借口, 爱拖延.</p><p>打羽毛球时, 有了扎实的基本功, 才有资格去谈千变万化的战术, 否则身体就会跟不上思维, 想法难以付诸现实. 做科学研究也是一样. 很多人科研的姿势不对，总是想走捷径利用现成的工具. 现成的工具虽然能够让你快速得到可以看得到的成果 (下限很高), 却总是存在局限性, 如果不具备修改甚至创新的能力, 便无法取得更进一步的提升 (上限很低). 而基本功从哪里来? 科学研究的基本功又有哪几项呢? 答案其实很简单, 大家可以自己去探索和领悟.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;羽毛球是一种技巧性很强的运动, 新手想要提高球技, 最大的困难往往在于纠正姿势. 不正确的姿势往往无法快速跑位导致接不到球, 或者接到回球质量很差打不到位, 长此以往还容易导致运动损伤. 相反地, 正确的姿势能够充分发挥全身的力量, 击球质量高打得有来有回不仅观赏性强, 锻
      
    
    </summary>
    
      <category term="科学" scheme="http://suzhouxing.github.io/techive/categories/%E7%A7%91%E5%AD%A6/"/>
    
    
      <category term="技术" scheme="http://suzhouxing.github.io/techive/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="科学" scheme="http://suzhouxing.github.io/techive/tags/%E7%A7%91%E5%AD%A6/"/>
    
      <category term="异想天开" scheme="http://suzhouxing.github.io/techive/tags/%E5%BC%82%E6%83%B3%E5%A4%A9%E5%BC%80/"/>
    
  </entry>
  
  <entry>
    <title>SmartLab Challenge 2021 - Vehicle Routing Problem with Time Windows</title>
    <link href="http://suzhouxing.github.io/techive/2021/09/27/Contest-2021VRP/"/>
    <id>http://suzhouxing.github.io/techive/2021/09/27/Contest-2021VRP/</id>
    <published>2021-09-27T01:47:34.000Z</published>
    <updated>2021-09-29T13:03:39.399Z</updated>
    
    <content type="html"><![CDATA[<p>带时间窗的车辆路由问题是交通运输与物流配送等领域中的重要问题, 其应用场景在生产生活中随处可见. 带时间窗的车辆路由问题主要研究如何确定一系列从同一个仓库出发的车辆的行驶路径, 在每辆车均不超载且每个客户都在给定时间窗内被访问的前提下, 最小化所有车辆的行驶时间之和. 比如快递配送过程中, 配送员能携带的物品重量有限, 同时每个客户只在特定的时段内有空收件, 快递公司需要调度配送员用最短的工时完成所有配送任务. 相反地, 在物流公司提供上门取件服务时, 揽件人员也会面临同样的优化问题. 因此, 高效的带时间窗的车辆路由问题的求解算法在理论上与实践上均意义重大.</p><h1 id="带时间窗的车辆路由算法训练">带时间窗的车辆路由算法训练</h1><h2 id="问题概述">问题概述</h2><p>给定一个有向完全图, 图中包含一个仓库节点和若干客户节点. 每个客户节点都对应一个配送请求, 需要一个在指定的时间窗内将给定重量的物品一次性送达, 交接过程花费固定的时间. 此外, 每辆车的最大载重量相同且均需从仓库出发最后回到仓库, 同时任意两点间的最短行驶时间已知 (超时视为到达节点后原地等待). 请确定使用几辆车参与配送, 并给出每辆车依次访问的有序节点列表, 使得所有车辆的总行驶时间最短.</p><ul><li>参考文献.<ul><li>[1] M. M. Solomon, “Algorithms for the Vehicle Routing and Scheduling Problems with Time Window Constraints,” Operations Research, vol. 35, no. 2, pp. 254–265, 1987, doi: 10.1287/opre.35.2.254.</li><li>[2] Y. Nagata and O. Bräysy, “A powerful route minimization heuristic for the vehicle routing problem with time windows,” Operations Research Letters, vol. 37, no. 5, pp. 333–338, 2009, doi: 10.1016/j.orl.2009.04.006.</li><li>[3] Y. Nagata, O. Bräysy, and W. Dullaert, “A penalty-based edge assembly memetic algorithm for the vehicle routing problem with time windows,” Computers &amp; Operations Research, vol. 37, no. 4, pp. 724–737, 2010, doi: 10.1016/j.cor.2009.06.022.</li><li>[4] R. Baldacci, A. Mingozzi, and R. Roberti, “New Route Relaxation and Pricing Strategies for the Vehicle Routing Problem,” Operations Research, vol. 59, no. 5, pp. 1269–1283, 2011, doi: 10.1287/opre.1110.0975.</li><li>[5] http://dimacs.rutgers.edu/programs/challenge/vrp/vrptw</li><li>[6] http://dimacs.rutgers.edu/files/7616/3155/5530/VRPTW_Competition_Rules.pdf</li><li>[7] https://www.sintef.no/projectweb/top/vrptw/homberger-benchmark/200-customers</li></ul></li></ul><h2 id="命令行参数">命令行参数</h2><p>请大家编写程序时支持两个命令行参数, 依次为运行时间上限 (单位为秒) 和随机种子 (0-65535). 算例文件已重定向至标准输入 <code>stdin</code>/<code>cin</code>, 标准输出 <code>stdout</code>/<code>cout</code> 已重定向至解文件 (如需打印调试信息, 请使用标准错误输出 <code>stderr</code>/<code>cerr</code>). 例如, 在控制台运行以下命令表示调用可执行文件 <code>vrptw.exe</code> 在限时 300 秒, 随机种子为 12345 的情况下求解路径为 <code>../data/solomon.c101.txt</code> 的算例, 解文件输出至 <code>sln.solomon.c101.txt</code>: <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vrptw.exe 300 123456 &lt;../data/solomon.c101.txt &gt;sln.solomon.c101.txt</span><br></pre></td></tr></table></figure></p><ul><li>运行时间上限.<ul><li>超出运行时间上限后测试程序会强行终止算法, 请确保在此之前已输出解 (最好还能自行正常退出).</li></ul></li><li>随机种子设置.<ul><li>使用 C 语言随机数生成器请用 <code>srand</code>.</li><li>使用 C++ 随机数生成器 (如 <code>mt19937</code>) 请在构造时传参或调用 <code>seed()</code> 方法设置.</li></ul></li></ul><h2 id="输入的算例文件格式">输入的算例文件格式</h2><p>所有算例的节点和车辆分别从 0 开始连续编号, 所有节点分布于平面直角坐标系中. 节点 0 为仓库, 即车辆的起点和终点, 其物品重量, 最短停留时间, 时间窗开始时间均为 0.</p><p>第一行给出两个由空白字符分隔的整数, 分别表示节点数 N, 最大可用车辆数 K, 以及各车辆的载重量上限 M. 接下来连续 N 行, 每行包含 6 个由空白字符分隔的整数, 第 i 行的 6 个整数依次表示第 i 个节点的 x 坐标, y 坐标, 物品重量, 最短停留时间 (服务时间), 最早到达时间, 最晚到达时间.</p><p>例如, 以下算例文件表示有 4 个节点和 3 辆车, 每辆车的容量为 10; 其中,<br>节点 0 的坐标为 (1, 5), 物品重量为 0, 最短停留时间为 0, 时间窗开始和结束时间分别为 0 和 8;<br>节点 1 的坐标为 (2, 1), 物品重量为 6, 最短停留时间为 3, 时间窗开始和结束时间分别为 4 和 5;<br>节点 2 的坐标为 (3, 7), 物品重量为 2, 最短停留时间为 4, 时间窗开始和结束时间分别为 5 和 6;<br>节点 3 的坐标为 (8, 8), 物品重量为 9, 最短停留时间为 5, 时间窗开始和结束时间分别为 6 和 7: <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">4 3 10</span><br><span class="line">1 5 0 0 0 8</span><br><span class="line">2 1 6 3 4 5</span><br><span class="line">3 7 2 4 5 6</span><br><span class="line">8 8 9 5 6 7</span><br></pre></td></tr></table></figure></p><p>注意, 本问题所用算例集中假设行驶时间等于两点间的距离, 目前的距离计算遵循文献与 DIMACS 竞赛中的约定, 使用截断保留一位小数的欧氏距离 (<span class="math inline">\(t = \lfloor 10 d \rfloor / 10\)</span>), 具体计算方式以 SDK 中的代码为准.</p><h2 id="输出的解文件格式">输出的解文件格式</h2><p>输出 V 行整数表示 V 辆车 (V &lt; K) 的行驶路径, 第 i 行第 j 个整数表示第 i 辆车经过的第 j 个客户节点.</p><p>例如, 以下解文件表示 2 辆车的行驶路径; 其中,<br>车辆 0 从仓库 0 出发后依次经过节点 3, 最后回到仓库 0;<br>车辆 1 从仓库 0 出发后依次经过节点 1 和 2, 最后回到仓库 0: <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">1 2</span><br></pre></td></tr></table></figure></p><h2 id="提交要求">提交要求</h2><ul><li>发送至邮箱 <a href="mailto:szx@duhe.tech" target="_blank" rel="noopener">szx@duhe.tech</a>.</li><li>邮件标题格式为 "<strong>Challenge2021VRPTW2d-姓名-学校-专业</strong>".</li><li>邮件附件为单个压缩包, 文件名为 "<strong>姓名-学校-专业</strong>", 其内包含下列文件.<ul><li><strong>必要</strong> 算法的可执行文件 (Windows 平台).<ul><li>建议基于官方 SDK 开发 (<a href="https://gitee.com/suzhouxing/npbenchmark/tree/main/SDK.VRPTW2d" target="_blank" rel="noopener">https://gitee.com/suzhouxing/npbenchmark/tree/main/SDK.VRPTW2d</a>).</li><li>用 g++ 的同学编译时请静态链接, 即添加 <code>-static-libgcc -static-libstdc++</code> 编译选项.</li></ul></li><li><strong>必要</strong> 算法源码.<ul><li>可重入 (可在同一线程内反复调用而不会出现数据初始化错误或内存泄漏).</li><li>可并发 (可在同一进程内的多个线程同时运行多个算法求解实例而互不干扰, 满足此要求一般不能有全局的非只读变量).</li><li>可伸缩 (数据结构可以根据算例规模动态申请内存, 而非根据预先指定的编译期常量进行内存分配).</li></ul></li><li><strong>可选</strong> 算法在各算例上的运行情况概要, 至少包括以下几项信息 (仅在无法成功调用算法输出可通过检查程序的解时作为参考).<ul><li>算例名.</li><li>使用的车辆数.</li><li>所有车辆的行驶时长总和.</li><li>计算耗时.</li></ul></li><li><strong>可选</strong> 算法在各算例上求得的路径总长度最短的解文件 (仅在无法成功调用算法输出可通过检查程序的解时作为参考).</li></ul></li><li>若成功提交, 在收到邮件时以及测试完成后系统均会自动发送邮件反馈提交情况.<ul><li>若测试结果较优, 可在排行榜页面看到自己的运行情况 (<a href="https://gitee.com/suzhouxing/npbenchmark/tree/data" target="_blank" rel="noopener">https://gitee.com/suzhouxing/npbenchmark/tree/data</a>).</li></ul></li></ul><p>例如: <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">苏宙行-华科-计科.zip</span><br><span class="line">|   vrptw2d.exe</span><br><span class="line">|   results.csv</span><br><span class="line">|</span><br><span class="line">+---src</span><br><span class="line">|       main.cpp</span><br><span class="line">|       algorithm.cpp</span><br><span class="line">|       algorithm.h</span><br><span class="line">|</span><br><span class="line">+---results</span><br><span class="line">        solomon.c101.n101v25c200.txt</span><br><span class="line">        solomon.c102.n101v25c200.txt</span><br><span class="line">        ...</span><br></pre></td></tr></table></figure></p><h2 id="算例清单">算例清单</h2><p>下载地址: <a href="https://gitee.com/suzhouxing/npbenchmark/tree/data/VRPTW2d/Instance" target="_blank" rel="noopener">https://gitee.com/suzhouxing/npbenchmark/tree/data/VRPTW2d/Instance</a></p><p>solomon.c101.n101v25c200<br>solomon.c102.n101v25c200<br>solomon.c103.n101v25c200<br>solomon.c104.n101v25c200<br>solomon.c105.n101v25c200<br>solomon.c106.n101v25c200<br>solomon.c107.n101v25c200<br>solomon.c108.n101v25c200<br>solomon.c109.n101v25c200<br>solomon.c201.n101v25c700<br>solomon.c202.n101v25c700<br>solomon.c203.n101v25c700<br>solomon.c204.n101v25c700<br>solomon.c205.n101v25c700<br>solomon.c206.n101v25c700<br>solomon.c207.n101v25c700<br>solomon.c208.n101v25c700<br>solomon.r101.n101v25c200<br>solomon.r102.n101v25c200<br>solomon.r103.n101v25c200<br>solomon.r104.n101v25c200<br>solomon.r105.n101v25c200<br>solomon.r106.n101v25c200<br>solomon.r107.n101v25c200<br>solomon.r108.n101v25c200<br>solomon.r109.n101v25c200<br>solomon.r110.n101v25c200<br>solomon.r111.n101v25c200<br>solomon.r112.n101v25c200<br>solomon.r201.n101v25c1000<br>solomon.r202.n101v25c1000<br>solomon.r203.n101v25c1000<br>solomon.r204.n101v25c1000<br>solomon.r205.n101v25c1000<br>solomon.r206.n101v25c1000<br>solomon.r207.n101v25c1000<br>solomon.r208.n101v25c1000<br>solomon.r209.n101v25c1000<br>solomon.r210.n101v25c1000<br>solomon.r211.n101v25c1000<br>solomon.rc101.n101v25c200<br>solomon.rc102.n101v25c200<br>solomon.rc103.n101v25c200<br>solomon.rc104.n101v25c200<br>solomon.rc105.n101v25c200<br>solomon.rc106.n101v25c200<br>solomon.rc107.n101v25c200<br>solomon.rc108.n101v25c200<br>solomon.rc201.n101v25c1000<br>solomon.rc202.n101v25c1000<br>solomon.rc203.n101v25c1000<br>solomon.rc204.n101v25c1000<br>solomon.rc205.n101v25c1000<br>solomon.rc206.n101v25c1000<br>solomon.rc207.n101v25c1000<br>solomon.rc208.n101v25c1000<br>homberger.c10201.n201v50c200<br>homberger.c10202.n201v50c200<br>homberger.c10203.n201v50c200<br>homberger.c10204.n201v50c200<br>homberger.c10205.n201v50c200<br>homberger.c10206.n201v50c200<br>homberger.c10207.n201v50c200<br>homberger.c10208.n201v50c200<br>homberger.c10209.n201v50c200<br>homberger.c10210.n201v50c200<br>homberger.c10401.n401v100c200<br>homberger.c10402.n401v100c200<br>homberger.c10403.n401v100c200<br>homberger.c10404.n401v100c200<br>homberger.c10405.n401v100c200<br>homberger.c10406.n401v100c200<br>homberger.c10407.n401v100c200<br>homberger.c10408.n401v100c200<br>homberger.c10409.n401v100c200<br>homberger.c10410.n401v100c200<br>homberger.c10601.n601v150c200<br>homberger.c10602.n601v150c200<br>homberger.c10603.n601v150c200<br>homberger.c10604.n601v150c200<br>homberger.c10605.n601v150c200<br>homberger.c10606.n601v150c200<br>homberger.c10607.n601v150c200<br>homberger.c10608.n601v150c200<br>homberger.c10609.n601v150c200<br>homberger.c10610.n601v150c200<br>homberger.c10801.n801v200c200<br>homberger.c10802.n801v200c200<br>homberger.c10803.n801v200c200<br>homberger.c10804.n801v200c200<br>homberger.c10805.n801v200c200<br>homberger.c10806.n801v200c200<br>homberger.c10807.n801v200c200<br>homberger.c10808.n801v200c200<br>homberger.c10809.n801v200c200<br>homberger.c10810.n801v200c200<br>homberger.c11001.n1001v250c200<br>homberger.c11002.n1001v250c200<br>homberger.c11003.n1001v250c200<br>homberger.c11004.n1001v250c200<br>homberger.c11005.n1001v250c200<br>homberger.c11006.n1001v250c200<br>homberger.c11007.n1001v250c200<br>homberger.c11008.n1001v250c200<br>homberger.c11009.n1001v250c200<br>homberger.c11010.n1001v250c200<br>homberger.c20201.n201v50c700<br>homberger.c20202.n201v50c700<br>homberger.c20203.n201v50c700<br>homberger.c20204.n201v50c700<br>homberger.c20205.n201v50c700<br>homberger.c20206.n201v50c700<br>homberger.c20207.n201v50c700<br>homberger.c20208.n201v50c700<br>homberger.c20209.n201v50c700<br>homberger.c20210.n201v50c700<br>homberger.c20401.n401v100c700<br>homberger.c20402.n401v100c700<br>homberger.c20403.n401v100c700<br>homberger.c20404.n401v100c700<br>homberger.c20405.n401v100c700<br>homberger.c20406.n401v100c700<br>homberger.c20407.n401v100c700<br>homberger.c20408.n401v100c700<br>homberger.c20409.n401v100c700<br>homberger.c20410.n401v100c700<br>homberger.c20601.n601v150c700<br>homberger.c20602.n601v150c700<br>homberger.c20603.n601v150c700<br>homberger.c20604.n601v150c700<br>homberger.c20605.n601v150c700<br>homberger.c20606.n601v150c700<br>homberger.c20607.n601v150c700<br>homberger.c20608.n601v150c700<br>homberger.c20609.n601v150c700<br>homberger.c20610.n601v150c700<br>homberger.c20801.n801v200c700<br>homberger.c20802.n801v200c700<br>homberger.c20803.n801v200c700<br>homberger.c20804.n801v200c700<br>homberger.c20805.n801v200c700<br>homberger.c20806.n801v200c700<br>homberger.c20807.n801v200c700<br>homberger.c20808.n801v200c700<br>homberger.c20809.n801v200c700<br>homberger.c20810.n801v200c700<br>homberger.c21001.n1001v250c700<br>homberger.c21002.n1001v250c700<br>homberger.c21003.n1001v250c700<br>homberger.c21004.n1001v250c700<br>homberger.c21005.n1001v250c700<br>homberger.c21006.n1001v250c700<br>homberger.c21007.n1001v250c700<br>homberger.c21008.n1001v250c700<br>homberger.c21009.n1001v250c700<br>homberger.c21010.n1001v250c700<br>homberger.r10201.n201v50c200<br>homberger.r10202.n201v50c200<br>homberger.r10203.n201v50c200<br>homberger.r10204.n201v50c200<br>homberger.r10205.n201v50c200<br>homberger.r10206.n201v50c200<br>homberger.r10207.n201v50c200<br>homberger.r10208.n201v50c200<br>homberger.r10209.n201v50c200<br>homberger.r10210.n201v50c200<br>homberger.r10401.n401v100c200<br>homberger.r10402.n401v100c200<br>homberger.r10403.n401v100c200<br>homberger.r10404.n401v100c200<br>homberger.r10405.n401v100c200<br>homberger.r10406.n401v100c200<br>homberger.r10407.n401v100c200<br>homberger.r10408.n401v100c200<br>homberger.r10409.n401v100c200<br>homberger.r10410.n401v100c200<br>homberger.r10601.n601v150c200<br>homberger.r10602.n601v150c200<br>homberger.r10603.n601v150c200<br>homberger.r10604.n601v150c200<br>homberger.r10605.n601v150c200<br>homberger.r10606.n601v150c200<br>homberger.r10607.n601v150c200<br>homberger.r10608.n601v150c200<br>homberger.r10609.n601v150c200<br>homberger.r10610.n601v150c200<br>homberger.r10801.n801v200c200<br>homberger.r10802.n801v200c200<br>homberger.r10803.n801v200c200<br>homberger.r10804.n801v200c200<br>homberger.r10805.n801v200c200<br>homberger.r10806.n801v200c200<br>homberger.r10807.n801v200c200<br>homberger.r10808.n801v200c200<br>homberger.r10809.n801v200c200<br>homberger.r10810.n801v200c200<br>homberger.r11001.n1001v250c200<br>homberger.r11002.n1001v250c200<br>homberger.r11003.n1001v250c200<br>homberger.r11004.n1001v250c200<br>homberger.r11005.n1001v250c200<br>homberger.r11006.n1001v250c200<br>homberger.r11007.n1001v250c200<br>homberger.r11008.n1001v250c200<br>homberger.r11009.n1001v250c200<br>homberger.r11010.n1001v250c200<br>homberger.r20201.n201v50c1000<br>homberger.r20202.n201v50c1000<br>homberger.r20203.n201v50c1000<br>homberger.r20204.n201v50c1000<br>homberger.r20205.n201v50c1000<br>homberger.r20206.n201v50c1000<br>homberger.r20207.n201v50c1000<br>homberger.r20208.n201v50c1000<br>homberger.r20209.n201v50c1000<br>homberger.r20210.n201v50c1000<br>homberger.r20401.n401v100c1000<br>homberger.r20402.n401v100c1000<br>homberger.r20403.n401v100c1000<br>homberger.r20404.n401v100c1000<br>homberger.r20405.n401v100c1000<br>homberger.r20406.n401v100c1000<br>homberger.r20407.n401v100c1000<br>homberger.r20408.n401v100c1000<br>homberger.r20409.n401v100c1000<br>homberger.r20410.n401v100c1000<br>homberger.r20601.n601v150c1000<br>homberger.r20602.n601v150c1000<br>homberger.r20603.n601v150c1000<br>homberger.r20604.n601v150c1000<br>homberger.r20605.n601v150c1000<br>homberger.r20606.n601v150c1000<br>homberger.r20607.n601v150c1000<br>homberger.r20608.n601v150c1000<br>homberger.r20609.n601v150c1000<br>homberger.r20610.n601v150c1000<br>homberger.r20801.n801v200c1000<br>homberger.r20802.n801v200c1000<br>homberger.r20803.n801v200c1000<br>homberger.r20804.n801v200c1000<br>homberger.r20805.n801v200c1000<br>homberger.r20806.n801v200c1000<br>homberger.r20807.n801v200c1000<br>homberger.r20808.n801v200c1000<br>homberger.r20809.n801v200c1000<br>homberger.r20810.n801v200c1000<br>homberger.r21001.n1001v250c1000<br>homberger.r21002.n1001v250c1000<br>homberger.r21003.n1001v250c1000<br>homberger.r21004.n1001v250c1000<br>homberger.r21005.n1001v250c1000<br>homberger.r21006.n1001v250c1000<br>homberger.r21007.n1001v250c1000<br>homberger.r21008.n1001v250c1000<br>homberger.r21009.n1001v250c1000<br>homberger.r21010.n1001v250c1000<br>homberger.rc10201.n201v50c200<br>homberger.rc10202.n201v50c200<br>homberger.rc10203.n201v50c200<br>homberger.rc10204.n201v50c200<br>homberger.rc10205.n201v50c200<br>homberger.rc10206.n201v50c200<br>homberger.rc10207.n201v50c200<br>homberger.rc10208.n201v50c200<br>homberger.rc10209.n201v50c200<br>homberger.rc10210.n201v50c200<br>homberger.rc10401.n401v100c200<br>homberger.rc10402.n401v100c200<br>homberger.rc10403.n401v100c200<br>homberger.rc10404.n401v100c200<br>homberger.rc10405.n401v100c200<br>homberger.rc10406.n401v100c200<br>homberger.rc10407.n401v100c200<br>homberger.rc10408.n401v100c200<br>homberger.rc10409.n401v100c200<br>homberger.rc10410.n401v100c200<br>homberger.rc10601.n601v150c200<br>homberger.rc10602.n601v150c200<br>homberger.rc10603.n601v150c200<br>homberger.rc10604.n601v150c200<br>homberger.rc10605.n601v150c200<br>homberger.rc10606.n601v150c200<br>homberger.rc10607.n601v150c200<br>homberger.rc10608.n601v150c200<br>homberger.rc10609.n601v150c200<br>homberger.rc10610.n601v150c200<br>homberger.rc10801.n801v200c200<br>homberger.rc10802.n801v200c200<br>homberger.rc10803.n801v200c200<br>homberger.rc10804.n801v200c200<br>homberger.rc10805.n801v200c200<br>homberger.rc10806.n801v200c200<br>homberger.rc10807.n801v200c200<br>homberger.rc10808.n801v200c200<br>homberger.rc10809.n801v200c200<br>homberger.rc10810.n801v200c200<br>homberger.rc11001.n1001v250c200<br>homberger.rc11002.n1001v250c200<br>homberger.rc11003.n1001v250c200<br>homberger.rc11004.n1001v250c200<br>homberger.rc11005.n1001v250c200<br>homberger.rc11006.n1001v250c200<br>homberger.rc11007.n1001v250c200<br>homberger.rc11008.n1001v250c200<br>homberger.rc11009.n1001v250c200<br>homberger.rc11010.n1001v250c200<br>homberger.rc20201.n201v50c1000<br>homberger.rc20202.n201v50c1000<br>homberger.rc20203.n201v50c1000<br>homberger.rc20204.n201v50c1000<br>homberger.rc20205.n201v50c1000<br>homberger.rc20206.n201v50c1000<br>homberger.rc20207.n201v50c1000<br>homberger.rc20208.n201v50c1000<br>homberger.rc20209.n201v50c1000<br>homberger.rc20210.n201v50c1000<br>homberger.rc20401.n401v100c1000<br>homberger.rc20402.n401v100c1000<br>homberger.rc20403.n401v100c1000<br>homberger.rc20404.n401v100c1000<br>homberger.rc20405.n401v100c1000<br>homberger.rc20406.n401v100c1000<br>homberger.rc20407.n401v100c1000<br>homberger.rc20408.n401v100c1000<br>homberger.rc20409.n401v100c1000<br>homberger.rc20410.n401v100c1000<br>homberger.rc20601.n601v150c1000<br>homberger.rc20602.n601v150c1000<br>homberger.rc20603.n601v150c1000<br>homberger.rc20604.n601v150c1000<br>homberger.rc20605.n601v150c1000<br>homberger.rc20606.n601v150c1000<br>homberger.rc20607.n601v150c1000<br>homberger.rc20608.n601v150c1000<br>homberger.rc20609.n601v150c1000<br>homberger.rc20610.n601v150c1000<br>homberger.rc20801.n801v200c1000<br>homberger.rc20802.n801v200c1000<br>homberger.rc20803.n801v200c1000<br>homberger.rc20804.n801v200c1000<br>homberger.rc20805.n801v200c1000<br>homberger.rc20806.n801v200c1000<br>homberger.rc20807.n801v200c1000<br>homberger.rc20808.n801v200c1000<br>homberger.rc20809.n801v200c1000<br>homberger.rc20810.n801v200c1000<br>homberger.rc21001.n1001v250c1000<br>homberger.rc21002.n1001v250c1000<br>homberger.rc21003.n1001v250c1000<br>homberger.rc21004.n1001v250c1000<br>homberger.rc21005.n1001v250c1000<br>homberger.rc21006.n1001v250c1000<br>homberger.rc21007.n1001v250c1000<br>homberger.rc21008.n1001v250c1000<br>homberger.rc21009.n1001v250c1000<br>homberger.rc21010.n1001v250c1000</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;带时间窗的车辆路由问题是交通运输与物流配送等领域中的重要问题, 其应用场景在生产生活中随处可见. 带时间窗的车辆路由问题主要研究如何确定一系列从同一个仓库出发的车辆的行驶路径, 在每辆车均不超载且每个客户都在给定时间窗内被访问的前提下, 最小化所有车辆的行驶时间之和. 比如
      
    
    </summary>
    
      <category term="算法挑战" scheme="http://suzhouxing.github.io/techive/categories/%E7%AE%97%E6%B3%95%E6%8C%91%E6%88%98/"/>
    
    
      <category term="组合优化" scheme="http://suzhouxing.github.io/techive/tags/%E7%BB%84%E5%90%88%E4%BC%98%E5%8C%96/"/>
    
      <category term="算法挑战" scheme="http://suzhouxing.github.io/techive/tags/%E7%AE%97%E6%B3%95%E6%8C%91%E6%88%98/"/>
    
  </entry>
  
  <entry>
    <title>运筹优化相关算法竞赛合集</title>
    <link href="http://suzhouxing.github.io/techive/2021/09/16/CompetitionNavigation/"/>
    <id>http://suzhouxing.github.io/techive/2021/09/16/CompetitionNavigation/</id>
    <published>2021-09-16T02:00:27.000Z</published>
    <updated>2021-10-02T06:57:43.547Z</updated>
    
    <content type="html"><![CDATA[<p>很欣慰地看到, 国家越来越重视竞赛了, 各个教育阶段的升学和考核等政策都在逐步向有竞赛成果的人倾斜. 相比于论文, 大部分竞赛有相对客观的评价标准, 第一只有一个, 很难出现大量无意义的低质量的重复研究. 因此, 后来者无需花费大量时间甄别前人到底尝试过哪些方法, 其中哪些是有效的, 哪些是无用的. 下面将简单列举一下与运筹优化相关的竞赛.</p><h1 id="周期性竞赛">周期性竞赛</h1><ul><li>计算机科学 CS<ul><li>电子设计自动化 EDA<ul><li><strong>ICCAD</strong> (每年) <a href="http://iccad-contest.org" target="_blank" rel="noopener">http://iccad-contest.org</a></li><li><strong>ISPD</strong> (每年) <a href="http://www.ispd.cc/?page=contests" target="_blank" rel="noopener">http://www.ispd.cc/?page=contests</a></li><li><strong>EDAAI</strong> (每年/随时提交) <a href="http://www.eda-ai.org/" target="_blank" rel="noopener">http://www.eda-ai.org/</a></li><li><strong>集成电路EDA设计精英挑战赛</strong> (每年) <a href="https://eda.icisc.cn/" target="_blank" rel="noopener">https://eda.icisc.cn/</a></li><li>逻辑综合<ul><li><strong>IWLS</strong> (每年) <a href="https://www.iwls.org/" target="_blank" rel="noopener">https://www.iwls.org/</a></li><li><strong>ReactiveSynthesis</strong> (每年) <a href="http://www.syntcomp.org/" target="_blank" rel="noopener">http://www.syntcomp.org/</a></li><li><strong>SyGuS</strong> (每年) <a href="https://sygus.org/comp/" target="_blank" rel="noopener">https://sygus.org/comp/</a></li></ul></li><li><strong>EDAthon</strong> (每年) <a href="https://sites.google.com/view/ceda-hk/edathon-2021" target="_blank" rel="noopener">https://sites.google.com/view/ceda-hk/edathon-2021</a></li><li>静态时序分析<ul><li><strong>TAU</strong> (每年) <a href="https://sites.google.com/view/tau-contest-2021/home/past-contests" target="_blank" rel="noopener">https://sites.google.com/view/tau-contest-2021/home/past-contests</a></li></ul></li></ul></li><li>NP 问题通用求解引擎<ul><li>命题逻辑<ul><li><strong>SAT</strong> (每年) <a href="http://www.satcompetition.org/" target="_blank" rel="noopener">http://www.satcompetition.org/</a><ul><li>历史链接 <a href="http://www.maxsat.udl.cat/" target="_blank" rel="noopener">http://www.maxsat.udl.cat/</a></li></ul></li><li><strong>MaxSAT</strong> (每年) <a href="https://maxsat-evaluations.github.io/" target="_blank" rel="noopener">https://maxsat-evaluations.github.io/</a></li></ul></li><li>谓词逻辑<ul><li><strong>SMT</strong> (每年) <a href="https://smt-comp.github.io/previous.html" target="_blank" rel="noopener">https://smt-comp.github.io/previous.html</a></li><li><strong>QBF</strong> (每年) <a href="http://www.qbflib.org/index_eval.php" target="_blank" rel="noopener">http://www.qbflib.org/index_eval.php</a></li></ul></li><li>约束编程<ul><li><strong>MiniZinc</strong> (每年) <a href="https://www.minizinc.org/challenge.html" target="_blank" rel="noopener">https://www.minizinc.org/challenge.html</a></li><li><strong>XCSP</strong> (每年) <a href="http://xcsp.org/competition" target="_blank" rel="noopener">http://xcsp.org/competition</a></li></ul></li></ul></li><li>可计算性与计算复杂性理论<ul><li><strong>HWMCC</strong> (每年) <a href="http://fmv.jku.at/hwmcc20/#history" target="_blank" rel="noopener">http://fmv.jku.at/hwmcc20/#history</a></li><li><strong>ModelChecking</strong> (每年) <a href="https://mcc.lip6.fr/" target="_blank" rel="noopener">https://mcc.lip6.fr/</a></li><li><strong>ModelCounting</strong> (每年) <a href="https://mccompetition.org/past_iterations" target="_blank" rel="noopener">https://mccompetition.org/past_iterations</a></li></ul></li><li>人工智能 AI<ul><li>规划调度<ul><li><strong>ICAPS</strong> (每年) <a href="https://www.icaps-conference.org/competitions/" target="_blank" rel="noopener">https://www.icaps-conference.org/competitions/</a></li></ul></li><li>自动定理证明<ul><li><strong>CASC</strong> (每年) <a href="http://www.tptp.org/CASC/" target="_blank" rel="noopener">http://www.tptp.org/CASC/</a></li></ul></li><li>改写引擎<ul><li><strong>REC</strong> (不规律) <a href="http://rec.gforge.inria.fr/" target="_blank" rel="noopener">http://rec.gforge.inria.fr/</a></li></ul></li></ul></li><li>并行计算<ul><li><strong>GraphChallenge</strong> (每年) <a href="https://graphchallenge.mit.edu/challenges" target="_blank" rel="noopener">https://graphchallenge.mit.edu/challenges</a></li></ul></li></ul></li><li>运筹学 OR<ul><li><strong>DIMACS</strong> (不规律) <a href="http://dimacs.rutgers.edu/programs/challenge/" target="_blank" rel="noopener">http://dimacs.rutgers.edu/programs/challenge/</a><ul><li>历史链接 <a href="http://dimacs.rutgers.edu/archive/Challenges/" target="_blank" rel="noopener">http://dimacs.rutgers.edu/archive/Challenges/</a></li></ul></li><li><strong>ROADEF</strong> (每一到两年) <a href="http://www.roadef.org/challenge" target="_blank" rel="noopener">http://www.roadef.org/challenge</a></li><li><strong>VeRoLog</strong> (不规律) <a href="https://www.euro-online.org/websites/verolog/verolog-solver-challenge/" target="_blank" rel="noopener">https://www.euro-online.org/websites/verolog/verolog-solver-challenge/</a></li></ul></li><li>生物信息学 BI<ul><li>蛋白质结构预测<ul><li><strong>CASP</strong> (每两年) <a href="https://predictioncenter.org/" target="_blank" rel="noopener">https://predictioncenter.org/</a></li></ul></li></ul></li></ul><h1 id="竞赛平台">竞赛平台</h1><ul><li><strong>华为</strong> <a href="https://competition.huaweicloud.com/competitions" target="_blank" rel="noopener">https://competition.huaweicloud.com/competitions</a></li><li><strong>阿里</strong> <a href="https://tianchi.aliyun.com/competition/gameList/activeList" target="_blank" rel="noopener">https://tianchi.aliyun.com/competition/gameList/activeList</a></li><li><strong>kaggle</strong> <a href="https://www.kaggle.com/competitions" target="_blank" rel="noopener">https://www.kaggle.com/competitions</a></li><li><strong>AIcrowd</strong> <a href="https://www.aicrowd.com/challenges" target="_blank" rel="noopener">https://www.aicrowd.com/challenges</a></li><li><strong>Biendata</strong> <a href="https://biendata.xyz/" target="_blank" rel="noopener">https://biendata.xyz/</a></li><li><strong>京东</strong> <a href="https://jdata.jd.com/html/list.html" target="_blank" rel="noopener">https://jdata.jd.com/html/list.html</a></li><li><strong>OPTIL</strong> (排行榜) <a href="https://www.optil.io/optilion/problems" target="_blank" rel="noopener">https://www.optil.io/optilion/problems</a></li></ul><h1 id="其他竞赛导航">其他竞赛导航</h1><h2 id="学术会议或权威机构">学术会议或权威机构</h2><ul><li>PATAT (时刻表调度相关竞赛汇总) <a href="https://www.patatconference.org/communityService.html" target="_blank" rel="noopener">https://www.patatconference.org/communityService.html</a></li><li>FLoC (逻辑相关竞赛汇总) (每四年)<ul><li><a href="https://floc2022.org/" target="_blank" rel="noopener">https://floc2022.org/</a></li><li><a href="https://www.floc2018.org/floc-olympic-games/" target="_blank" rel="noopener">https://www.floc2018.org/floc-olympic-games/</a></li><li><a href="http://vsl2014.at/olympics/" target="_blank" rel="noopener">http://vsl2014.at/olympics/</a></li></ul></li><li>TACAS (系统构建与分析的算法与工具相关竞赛汇总) <a href="https://tacas.info/toolympics.php" target="_blank" rel="noopener">https://tacas.info/toolympics.php</a></li></ul><h2 id="个人搜集">个人搜集</h2><ul><li>HSU (各类竞赛汇总) <a href="https://www.hsu-hh.de/logistik/research/challenges" target="_blank" rel="noopener">https://www.hsu-hh.de/logistik/research/challenges</a></li></ul><h1 id="已结束竞赛">已结束竞赛</h1><ul><li>ROADEF/EURO<ul><li><strong>电网检修计划</strong> <a href="http://www.roadef.org/challenge/2020/en/index.php" target="_blank" rel="noopener">http://www.roadef.org/challenge/2020/en/index.php</a></li><li><strong>玻璃切割</strong> <a href="http://www.roadef.org/challenge/2018/en/index.php" target="_blank" rel="noopener">http://www.roadef.org/challenge/2018/en/index.php</a></li><li><strong>库存路由</strong> <a href="http://www.roadef.org/challenge/2016/en/index.php" target="_blank" rel="noopener">http://www.roadef.org/challenge/2016/en/index.php</a></li><li><strong>负载均衡</strong> <a href="http://www.roadef.org/challenge/2012/en/index.php" target="_blank" rel="noopener">http://www.roadef.org/challenge/2012/en/index.php</a></li></ul></li><li>GECCO<ul><li><strong>监控相机布局</strong> <a href="http://www.mage.fst.uha.fr/brevilliers/ocp-uscp-benchmark/index.html" target="_blank" rel="noopener">http://www.mage.fst.uha.fr/brevilliers/ocp-uscp-benchmark/index.html</a><ul><li>历史链接 <a href="http://www.mage.fst.uha.fr/brevilliers/gecco-2020-ocp-uscp-competition" target="_blank" rel="noopener">http://www.mage.fst.uha.fr/brevilliers/gecco-2020-ocp-uscp-competition</a></li><li>历史链接 <a href="http://www.mage.fst.uha.fr/brevilliers/gecco-2021-ocp-uscp-competition" target="_blank" rel="noopener">http://www.mage.fst.uha.fr/brevilliers/gecco-2021-ocp-uscp-competition</a></li></ul></li></ul></li><li>AIcrowd<ul><li><strong>列车调度</strong> <a href="https://www.aicrowd.com/challenges/flatland-3" target="_blank" rel="noopener">https://www.aicrowd.com/challenges/flatland-3</a></li></ul></li><li>京东<ul><li><strong>库存管理</strong> <a href="https://jdata.jd.com/html/detail.html?id=4" target="_blank" rel="noopener">https://jdata.jd.com/html/detail.html?id=4</a></li><li><strong>车辆路由</strong> <a href="https://jdata.jd.com/html/detail.html?id=5" target="_blank" rel="noopener">https://jdata.jd.com/html/detail.html?id=5</a></li></ul></li><li>阿里<ul><li><strong>布料切割</strong> <a href="https://tianchi.aliyun.com/competition/entrance/231749/introduction" target="_blank" rel="noopener">https://tianchi.aliyun.com/competition/entrance/231749/introduction</a></li><li><strong>作业调度</strong> <a href="https://tianchi.aliyun.com/competition/entrance/231663/introduction" target="_blank" rel="noopener">https://tianchi.aliyun.com/competition/entrance/231663/introduction</a></li><li><strong>物流运输</strong> <a href="https://tianchi.aliyun.com/competition/entrance/231623/introduction" target="_blank" rel="noopener">https://tianchi.aliyun.com/competition/entrance/231623/introduction</a></li><li><strong>航班延误恢复</strong> <a href="https://tianchi.aliyun.com/competition/entrance/231609/introduction" target="_blank" rel="noopener">https://tianchi.aliyun.com/competition/entrance/231609/introduction</a></li><li><strong>无人机路径规划</strong> <a href="https://tianchi.aliyun.com/competition/entrance/231622/introduction" target="_blank" rel="noopener">https://tianchi.aliyun.com/competition/entrance/231622/introduction</a></li><li><strong>客流量预测</strong> <a href="https://tianchi.aliyun.com/competition/entrance/231588/information" target="_blank" rel="noopener">https://tianchi.aliyun.com/competition/entrance/231588/information</a></li></ul></li><li>华为<ul><li><strong>卫星通信路径规划</strong> <a href="https://competition.huaweicloud.com/information/1000041474/circumstance" target="_blank" rel="noopener">https://competition.huaweicloud.com/information/1000041474/circumstance</a></li><li><strong>机器分配</strong> 2018 年软件精英挑战赛</li><li><strong>中心选址流量分发</strong> 2017 年软件精英挑战赛</li><li><strong>光网络路由</strong> 2016 年软件精英挑战赛</li></ul></li><li>滴滴<ul><li><strong>出租车订单分配</strong> <a href="https://biendata.xyz/competition/kdd_didi/" target="_blank" rel="noopener">https://biendata.xyz/competition/kdd_didi/</a></li></ul></li><li>护士排班<ul><li><strong>护士排班</strong> <a href="https://nrpcompetition.kuleuven-kulak.be/" target="_blank" rel="noopener">https://nrpcompetition.kuleuven-kulak.be/</a></li><li><strong>多阶段护士排班</strong> <a href="http://mobiz.vives.be/inrc2/" target="_blank" rel="noopener">http://mobiz.vives.be/inrc2/</a></li></ul></li><li>CHeSC<ul><li><strong>跨领域启发式搜索</strong> <a href="http://www.asap.cs.nott.ac.uk/external/chesc2011/index.html" target="_blank" rel="noopener">http://www.asap.cs.nott.ac.uk/external/chesc2011/index.html</a></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;很欣慰地看到, 国家越来越重视竞赛了, 各个教育阶段的升学和考核等政策都在逐步向有竞赛成果的人倾斜. 相比于论文, 大部分竞赛有相对客观的评价标准, 第一只有一个, 很难出现大量无意义的低质量的重复研究. 因此, 后来者无需花费大量时间甄别前人到底尝试过哪些方法, 其中哪些
      
    
    </summary>
    
      <category term="算法竞赛" scheme="http://suzhouxing.github.io/techive/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"/>
    
    
      <category term="算法竞赛" scheme="http://suzhouxing.github.io/techive/tags/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"/>
    
      <category term="组合优化" scheme="http://suzhouxing.github.io/techive/tags/%E7%BB%84%E5%90%88%E4%BC%98%E5%8C%96/"/>
    
      <category term="运筹优化" scheme="http://suzhouxing.github.io/techive/tags/%E8%BF%90%E7%AD%B9%E4%BC%98%E5%8C%96/"/>
    
      <category term="网址导航" scheme="http://suzhouxing.github.io/techive/tags/%E7%BD%91%E5%9D%80%E5%AF%BC%E8%88%AA/"/>
    
  </entry>
  
  <entry>
    <title>再谈统一建模语言与通用求解器</title>
    <link href="http://suzhouxing.github.io/techive/2021/09/01/GeneralSolver/"/>
    <id>http://suzhouxing.github.io/techive/2021/09/01/GeneralSolver/</id>
    <published>2021-09-01T12:03:58.000Z</published>
    <updated>2021-09-16T12:56:57.744Z</updated>
    
    <content type="html"><![CDATA[<p>多年以前曾经有过一段与统一建模语言与通用求解器相关的意识流 (<a href="/techive/2018/06/07/SearchingInDatabaseOrOptimization/" title="数据库中的搜索, 组合优化问题的搜索, 统一建模语言与通用求解器">数据库中的搜索, 组合优化问题的搜索, 统一建模语言与通用求解器</a>). 最近机缘巧合, 又遇到了这个话题, 于是又做了进一步的思考. 总的来说, 如果能设计一个能与针对特定问题的专用算法相媲美的通用求解器, 无论是精确还是近似, 其实际应用价值不亚于证明 P = NP. 可惜, 天上不会掉馅饼, 一个高价值的问题, 难度往往也不会低.</p><h1 id="我们需要什么样的通用求解器">我们需要什么样的通用求解器?</h1><p>如果说好奇心驱使人类进行科学探索, 那么, 懒, 则是人类发展技术的动力源泉. "复用" 是软件工程的核心思想之一, 说白了就是懒, 不想做别人甚至自己早就做过的工作. 在求解组合优化问题时, 我们当然也希望充分利用现有的研究成果. 算法设计中有很多平衡, 在这里, 我们关注的是算法的开发难度和结果优度之间的平衡, 以及开发效率和运行效率之间的平衡.</p><p>通用求解器的美好愿景是, 我们只用向计算机描述我们的问题, 它便能自动求出最优解.</p><p>然而, 其最大的问题就是如何向计算机描述我们的需求. 计算机往往只能接受形式化的语言, 即程序设计语言. 相比于命令式的编程语言, 声明式的编程语言更适合用于数学建模. 它们仅用于陈述事实, 所有声明是平行的, 需要被同时满足, 而不像命令式编程语言描述事件和操作的先后顺序. 不幸的是, 用数学语言形式化地描述问题对很多人来说都是一件十分困难的事情. 毕竟, 很多人用自然语言都无法清晰地描述需求, 定义问题. 简洁的建模语言入门容易, 但表达能力往往较弱, 十分考验使用者的经验与技巧. 复杂的建模语言表达能力强, 但学习成本也十分高昂. 如果既简洁又强大的建模语言真的存在, 大概率又会难以绕开自然语言的问题, 即二义性.</p><p>另一方面, 通用算法想要识别问题结构, 然后进行针对性处理是非常困难的. 然而, 且不说不同问题, 即使是同一个问题, 面对不同特性的测试用例, 不同算法的性能也有天壤之别. 比如, 拿最短简单路径这种教科书级别的 P 问题来举例: 若所有边权重相同, 则可以直接用广度优先搜索进行求解; 若在平面图上, 可以用欧氏距离作为启发函数使用 A* 算法高效求解; 若在网格上, 可以有更多基于地标和可达范围的加速策略... 如果能给计算机一些提示, 使其能够利用问题结构的信息, 将对求解效率产生十分积极的影响.</p><h1 id="几个通用求解器的技术路线">几个通用求解器的技术路线</h1><h2 id="数学规划">数学规划</h2><p>以 Gurobi 和 CPLEX 为代表的数学规划求解器, 主要基于线性规划求得线性松弛, 再基于线性松弛进行树搜索. 以个人经验来看, 虽然很多求解器还支持特殊形式的二次规划 (QP), 但其表达能力和求解效果往往不如混合整数规划 (MIP), 故此处仅讨论后者.</p><p>数学规划可以适应离散优化与连续优化相结合的场景, 表达能力足以支撑生产生活中绝大多数组合优化问题的建模. 但是, 正如 Harold Hotelling 的 "名言", "But we all know the world is nonlinear", 大量组合优化问题无法直接用 MIP 等建模语言进行描述. 最简单的情形便是 "逻辑或" 的关系, MIP 要求所有约束同时满足, 即 "逻辑与" 的关系, 所有约束对应的超平面将解空间切成一个单纯形 (凸多胞形) 构成可行解空间, "逻辑或" 会使可行解空间产生凹陷. 我们需要添加布尔类型的辅助变量进行升维, 使用 Big-M 的技巧, 将线性不可分的解空间转换为线性可分的, 将逻辑约束转述为代数约束. 进行上述处理后, 问题结构往往变得高度非线性, 不同的转换方式会不同程度地丢失问题的结构信息, 导致求解效果不够理想, 以至于最短路径或最小生成树之类的 P 问题求解速度往往也难以接受.</p><h2 id="satmaxsatsmt">SAT/MaxSAT/SMT</h2><p>以 MiniSAT 及其衍生出的众多开源求解器为代表的通用求解器, 主要基于问题之间普遍存在可以相互归约/转换的关系, 通过一定的编码技巧将各类约束统一表达为布尔表达式.</p><p>与数学规划方法基于代数理论以连续优化为切入点不同, SAT/MaxSAT/SMT 方法的重心在逻辑推理, 直接面向离散优化. 由于 NP 完全问题之间普遍存在的可归约性, SAT 问题作为第一个 NP 完全问题, 其求解器理论上可以求解所有 NP 完全问题. 然而, NP 完全问题只是所有组合优化问题中一个很小的子集, 即使扩展到了 MaxSAT, 表达能力也十分有限而充满技巧性. 例如, 在数学规划中十分基础的 <span class="math inline">\(a + b \le c\)</span> 的约束, 要编码成 SAT 算例甚至类似于设计一个包含加法器和比较器的电路. 当然, 更进一步发展到 Satisfiability Modulo Theories (SMT) 之后, 表达能力产生了质的飞跃, 但从其目前的受欢迎程度来看 (我并没有使用过 SMT), 求解效率似乎也随之发生了质的跌落...</p><h2 id="约束编程">约束编程</h2><p>以 MiniZinc 为代表的约束编程求解器, 其实现主要基于树搜索算法.</p><p>约束编程中各式各样的约束类型十分丰富, 表达能力很强, 乍一看好像和 SMT 很接近, 但是由于研究不多, 在此不做过多评价. 个人感觉约束编程中对很多常见的约束类型进行了封装或者模板化, 在简化调用代码的同时可以完整地呈现问题结构, 而不是以被使用者打散的状态出现. 做个不恰当的类比, 我们在描述一块砖的受到的重力时, 正常人都是用整块砖的质量乘以地表重力加速度, 而不是考虑砖里面每个原子的受到的万有引力以及原子间的相互作用. 比如在排序问题中, 我们需要给每个元素安排一个序号, 所有序号互不相同, 学过排序算法的都知道, 我们每次只交换两个元素就不会违反这个互不相同 (all-different) 约束. 但是如果使用者给出了 <span class="math inline">\(n^{2}\)</span> 条约束, 告诉求解器任意两个元素的序号不相等, 那么求解器就需要经过一系列约束推理 (传播) 才能发现, 修改了 A 的序号之后, 必须把另一个元素的序号改成 A 原来的序号才行. 如果建模语言直接支持一类 all-different 约束, 则可以保留这种结构信息. 当然, 与其丰富的特性相对应地, 其学习成本也不见得比学习一门编程语言以及启发式算法的基本思想低多少. 有意思的是, 物理学家们努力在寻找大统一理论来解释所有相互作用, 虽然似乎目前进展不太顺利.</p><h2 id="局部搜索">局部搜索</h2><p>以 LocalSolver 为代表的基于局部搜索的通用求解器.</p><p>局部搜索算法与人的求解过程十分相似, 都是从初始解出发, 不断对当前解进行修改, 只对搜索路径或上下文信息进行有限的记录. 对于约束较少的优化问题, 局部搜索具有极高的适应性. 例如, 以最小化问题为例, 局部搜索关注上界, 是真实可行的解的目标函数值, 因此更符合实际需求. 而树搜索为了确保最优性, 关注的往往是下界, 是理论上最优解的目标函数值, 其实努力方向稍微有点走偏了. 然而, 局部搜索算法的设计是高度依赖问题结构的, 算法性能的关键一方面是邻域动作, 即每次如何修改当前解, 另一方面是邻域范围, 即每次评估哪些邻域动作. 如果只是对解向量进行任意的修改, 可能会浪费大量时间在无效的动作上. 以前面的 all-different 约束为例, 改变一个元素的序号后, 下一步可以把 n 个元素的序号更改为 1 到 n 中的任意一个, 共有 <span class="math inline">\(n^{2}\)</span> 个动作, 但其实只有一个能得到可行解. 因此, 个人对于基于局部搜索的 "傻瓜式" "即开即用" 的通用求解器持相对悲观的态度, 不进行定制化将难以发挥局部搜索算法的强大威力.</p><h2 id="算法库">算法库</h2><p>以 COIN-OR 和 dlib 为代表的算法库. 主要基于问题之间普遍存在可以分解/组合的关系, 由算法设计者对各种子算法进行组合形成完整问题的求解算法.</p><p>使用算法库与基于 SAT/MaxSAT/SMT 构建通用求解器在思路上十分相似, 但从另一个角度看又是两个极端. 算法库几乎将算法设计的压力全部扔给了使用者, 甚至可以说这条技术路线完全没有超出软件工程的范畴. 而已知算法庞大的数量将极大地限制其可用性, 屠龙勇士最终往往会成为新的恶龙. 我已经有过类似的经历, 需要使用一个经典算法时, 发现很多第三方库中都有, 但是为了用一个简单的算法, 需要把整个庞大的工程集成到我的代码中, 感觉十分繁琐. 同时, 这些算法为了支持多种多样的应用场景往往会有很复杂的参数控制算法的行为, 即使我只需要最基础的功能, 我也得花大量时间仔细研究使用说明. 于是我决定自己重新实现一下, 并在以后的使用中日积月累, 功能越来越强大. 直到有一天, 我向学弟学妹们推销我那瑞士军刀般的算法库时, 大家都望而却步, 我才发现, 我的 "杰作" 已经成为了自己曾经不屑一顾的东西...</p><p>当然我们也不必过于悲观, 在特定领域中算法库应该还是有其用武之地的. 事实上, 基于数学规划的方法为我们提供了一些思路, 比如行生成 (惰性约束) 和列生成 (分支定价) 框架就是典型案例, 其子问题往往是个很简单的 P 问题, 可以由算法库提供支撑. 更通用地, 我们可以用函数式的编程范式对算法进行组合, 例如, 上层问题每找到一个可行解 (大格局), 就调用回调函数进行下层问题的求解 (完整解), 然后将完整解的可行性和优度反馈给上层, 上层根据反馈结果开展进一步搜索.</p><h2 id="算法框架">算法框架</h2><p>以 SCIP 和 EasyLocal 为代表的算法框架. 说白了还是软件工程, 提取算法中公共的重复的部分, 将需要定制化的部分开放出来 (当然也可以提供默认的实现以提高易用性), 可以用于任何方法学.</p><p>对现有的框架了解不多, 自己设想的框架还在规划中, 在此不展开讨论.</p><h1 id="能够指导求解的统一建模语言">能够指导求解的统一建模语言</h1><p>前面反复提到 "问题结构" 这个词, 它到底是个什么东西? 到底能为求解带来多大的好处? 其实我自己也没想清楚, 只有两个模糊的思路. 一方面, 如果我们按某种策略对解空间进行探索, 那么有些约束将自然满足, 根本不用考虑, 不用专门添加约束加以限制. 比如对于 SAT 问题, 我们默认同一个变元在所有子句中的取值是完全一致的, 就是一种很自然的约束, 在满足这个约束的基础上去寻找满足所有子句的变元取值. 事实上, 我们还可以进行完全不同的建模, 比如要求所有子句必须都满足, 然后最大化同一变元在不同子句中的一致性, 其求解效果可能有天壤之别, 但求解器很难知道还有另一个等价的可以高效求解的模型. 另一方面, 如果我们按某种策略对解空间进行探索, 一旦探索过某些特定的子结构, 则可以排除一部分解空间包含更优解的可能性. 这个思路在 P 问题的求解中应用尤为广泛, 在 NP 问题中也较为常见, 比如动态规划的最优子结构, 树搜索的剪枝策略等等.</p><p>我是研究元启发式算法的, 下面我还是以我的老本行为切入点, 探讨一下在建模层面为求解算法提供指导的可能性. 前面提到, 影响局部搜索算法求解效果最关键的两个因素是邻域动作和邻域范围, 除此之外, 如何高效地增量评估邻居解的目标函数值, 以及如何近似评估目标函数值, 都是局部搜索中的重要问题. 指导求解的统一建模语言, 至少可以从这几个方面入手.</p><h2 id="邻域动作">邻域动作</h2><p>"启发式" 的含义即借鉴人与自然的经验. 局部搜索其实十分自然, 就像人在解决问题一样, 先做个差不多的方案, 然后左调调右调调, 看看能不能改出一个更好的方案. 因此, 定义邻域动作其实并不比数学规划或约束编程复杂. 而合理的邻域动作定义, 可以充分利用问题结构, 省略部分十分自然的约束. 比如集合覆盖, 如果邻域动作是交换两个集合的选中状态, 则无需添加选中集合数量约束. 用形式化的语言描述, 令所有子集的集合为 <span class="math inline">\(S\)</span>, 选中的子集集合为 <span class="math inline">\(X\)</span>, 交换邻域动作可以定义为 <span class="math inline">\(M = \{ X \leftarrow X \cup \{ p \} \setminus \{ q \} | p \in S \setminus X, q \in X \}\)</span>.</p><h2 id="邻域范围">邻域范围</h2><p>定义邻域范围其实也只涉及简单的集合定义, 甚至没有超出高中数学的范畴. 合理的邻域范围定义, 可以充分利用问题结构, 避免评估毫无希望的邻域动作, 或者适当缩小邻域对单位评估改进量 (评估的邻域解数量 / 最优邻域动作目标函数值改进量) 进行平衡. 比如作业车间调度, 相比于任意调整同机器上两个工序的先后顺序, 高效的邻域范围往往会针对关键路径上的工序, 因为其他工序的顺序调整无法直接缩短完工时间.</p><p>再次以集合覆盖为例, 每个交换动作中新增子集时, 相比于从所有未选中集合中挑选一个, 高效的邻域范围可以是随机选中一个未覆盖元素, 尝试添加一个能够覆盖该元素的集合. 用形式化的语言描述, 令所有子集的集合为 <span class="math inline">\(S\)</span>, 选中的子集集合为 <span class="math inline">\(X\)</span>, 子集 <span class="math inline">\(s\)</span> 可覆盖的元素集合为 <span class="math inline">\(C_{s}\)</span>, 可覆盖元素 <span class="math inline">\(e\)</span> 的子集集合为 <span class="math inline">\(B_{e}\)</span>, 未覆盖元素集合 <span class="math inline">\(U(X) = \bigcup_{s \in S} C_{s} \setminus \bigcup_{s \in X} C_{s}\)</span>. 精简的交换邻域可以定义为 <span class="math inline">\(N = \{ X \leftarrow X \cup \{ p \} \setminus \{ q \} | \exists e \in U(X), \forall p \in B_{e}, \forall q \in X \}\)</span>. 注意, 这里的符号使用可能不太严谨, 我们用存在量词 <span class="math inline">\(\exists\)</span> 表示从集合中随机选取一个元素, 还应进一步规范化.</p><h2 id="增量评估">增量评估</h2><p>通用的增量评估虽然可行, 但其效率往往难以达到极致. 很多时候我们需要在更新代价和查询代价之间进行平衡, 往往需要一个中间数据结构实现辅助计算. 我们可以定义辅助查找表, 定义每轮迭代时目标函数如何通过这个查找表进行计算, 然后执行完邻域动作后查找表中的相关数据如何更新, 来提高评估效率.</p><h2 id="近似评估">近似评估</h2><p>对于相对复杂的问题, 往往增量评估的代价都十分巨大, 此时我们需要使用近似评估策略, 筛选出若干较有潜力的解, 然后对其进行精确评估选出真正的最优动作. 近似评估其实于邻域范围有些许重叠, 邻域范围相当于可以在 O(1) 时间内完成的近似评估, 直接筛掉没有改进潜力的动作. 当然, 近似评估除了由人根据经验定义, 也完全有可能实现通用化和智能化, 即使用机器学习的技术, 进行函数逼近, 自动学习出一个开销很小的函数来模拟真实的目标函数.</p><h1 id="总结">总结</h1><p>通用求解器是一个美好的愿景, 基于局部搜索的通用求解器更是十分有吸引力的方向. 而局部搜索的优势在于其对问题结构的把握, 丧失了问题结构的指引, 局部搜索的效果必然大打折扣. 因此, 个人认为, 我们在统一建模语言的基础上, 适当加入算法设计的提示信息, 对算法进行合理引导, 应该是比较有前景的技术路线.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;多年以前曾经有过一段与统一建模语言与通用求解器相关的意识流 (&lt;a href=&quot;/techive/2018/06/07/SearchingInDatabaseOrOptimization/&quot; title=&quot;数据库中的搜索, 组合优化问题的搜索, 统一建模语言与通用求解器&quot;&gt;
      
    
    </summary>
    
      <category term="技术" scheme="http://suzhouxing.github.io/techive/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="运筹优化" scheme="http://suzhouxing.github.io/techive/tags/%E8%BF%90%E7%AD%B9%E4%BC%98%E5%8C%96/"/>
    
      <category term="技术" scheme="http://suzhouxing.github.io/techive/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="通用求解器" scheme="http://suzhouxing.github.io/techive/tags/%E9%80%9A%E7%94%A8%E6%B1%82%E8%A7%A3%E5%99%A8/"/>
    
      <category term="建模" scheme="http://suzhouxing.github.io/techive/tags/%E5%BB%BA%E6%A8%A1/"/>
    
  </entry>
  
  <entry>
    <title>SmartLab Challenge 2021 - Rectangle Packing</title>
    <link href="http://suzhouxing.github.io/techive/2021/07/10/Contest-2021RectPacking/"/>
    <id>http://suzhouxing.github.io/techive/2021/07/10/Contest-2021RectPacking/</id>
    <published>2021-07-10T09:21:42.000Z</published>
    <updated>2021-10-01T13:19:13.708Z</updated>
    
    <content type="html"><![CDATA[<p>矩形装箱问题是物流运输, 芯片制造与游戏开发等领域中的重要问题, 应用场景十分广泛. 矩形装箱问题主要研究如何将一系列矩形块不重叠地摆放至矩形容器中, 使得容器面积最小的问题. 比如玻璃制造过程中, 要在原料 (大矩形) 上进行切割得到一系列成品 (小矩形). 比如在集成电路的物理设计中, 需要用最小的面积排布大量宏单元和标准单元以节约成本. 比如在游戏贴图加载时, 需要将若干矩形图片拼合成大块的矩形图像以充分发挥显存性能. 因此, 高效的矩形装箱问题的求解算法具有极其重要的理论与应用价值.</p><h1 id="矩形装箱算法训练">矩形装箱算法训练</h1><h2 id="问题概述">问题概述</h2><p>给定一系列长宽固定的矩形块, 可以旋转 0 或 90 度, 请确定每个矩形块的左下角坐标, 使得在所有矩形块不重叠的情况下, 包络所有矩形块的矩形区域面积最小.</p><ul><li>参考文献.<ul><li>[1] L. Wei, W.-C. Oon, W. Zhu, and A. Lim, “A skyline heuristic for the 2D rectangular packing and strip packing problems,” European Journal of Operational Research, vol. 215, no. 2, pp. 337–346, 2011, doi: 10.1016/j.ejor.2011.06.022.</li><li>[2] L. Wei, T. Tian, W. Zhu, and A. Lim, “A block-based layer building approach for the 2D guillotine strip packing problem,” European Journal of Operational Research, vol. 239, no. 1, pp. 58–69, 2014, doi: 10.1016/j.ejor.2014.04.020.</li><li>[3] K. He, P. Ji, and C. Li, “Dynamic reduction heuristics for the rectangle packing area minimization problem,” European Journal of Operational Research, vol. 241, no. 3, pp. 674–685, 2015, doi: 10.1016/j.ejor.2014.09.042.</li><li>[4] L. Wei, Q. Hu, S. C. H. Leung, and N. Zhang, “An improved skyline based heuristic for the 2D strip packing problem and its efficient implementation,” Computers &amp; Operations Research, vol. 80, pp. 113–127, 2017, doi: 10.1016/j.cor.2016.11.024.</li><li>[5] K. He, H. Yang, Y. Jin, Q. Hu, and P. Ji, “The Orthogonal Packing and Scheduling Problem: Model, Heuristic, and Benchmark,” IEEE Transactions on Systems, Man, and Cybernetics: Systems, vol. 50, no. 4, pp. 1372–1383, Apr. 2020, doi: 10.1109/TSMC.2017.2768072.</li><li>[6] P. Ji, K. He, Z. Wang, Y. Jin, and J. Wu, “A Quasi-Newton-based Floorplanner for fixed-outline floorplanning,” Computers &amp; Operations Research, vol. 129, p. 105225, 2021, doi: 10.1016/j.cor.2021.105225.</li></ul></li></ul><h2 id="命令行参数">命令行参数</h2><p>请大家编写程序时支持两个命令行参数, 依次为运行时间上限 (单位为秒) 和随机种子 (0-65535). 算例文件已重定向至标准输入 <code>stdin</code>/<code>cin</code>, 标准输出 <code>stdout</code>/<code>cout</code> 已重定向至解文件 (如需打印调试信息, 请使用标准错误输出 <code>stderr</code>/<code>cerr</code>). 例如, 在控制台运行以下命令表示调用可执行文件 <code>packing.exe</code> 在限时 300 秒, 随机种子为 12345 的情况下求解路径为 <code>../data/gsrc.b10a221679.txt</code> 的算例, 解文件输出至 <code>sln.gsrc.b10a221679.txt</code>: <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">packing.exe 300 123456 &lt;../data/gsrc.b10a221679.txt &gt;sln.gsrc.b10a221679.txt</span><br></pre></td></tr></table></figure></p><ul><li>运行时间上限.<ul><li>超出运行时间上限后测试程序会强行终止算法, 请确保在此之前已输出解 (最好还能自行正常退出).</li></ul></li><li>随机种子设置.<ul><li>使用 C 语言随机数生成器请用 <code>srand</code>.</li><li>使用 C++ 随机数生成器 (如 <code>mt19937</code>) 请在构造时传参或调用 <code>seed()</code> 方法设置.</li></ul></li></ul><h2 id="输入的算例文件格式">输入的算例文件格式</h2><p>所有算例的矩形块均从 0 开始连续编号.</p><p>第一行给出一个整数 N, 表示矩形块的数量.</p><p>接下来连续 N 行, 每行包含两个由空白字符分隔的整数, 表示矩形块的长和宽 (不发生旋转的情况下，长度对应横坐标，宽度对应纵坐标).</p><p>例如, 以下算例文件表示需放置 4 个矩形块; 其中,<br>矩形块 0 的长为 1 宽为 3;<br>矩形块 1 的长为 3 宽为 1;<br>矩形块 2 的长为 2 宽为 2;<br>矩形块 3 的长为 2 宽为 2: <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">1 3</span><br><span class="line">3 1</span><br><span class="line">2 2</span><br><span class="line">2 2</span><br></pre></td></tr></table></figure></p><h2 id="输出的解文件格式">输出的解文件格式</h2><p>输出 N 行整数表示 N 个矩形块的放置情况, 第 i 行表示第 i 个矩形块的左下角坐标和旋转情况. 每行第一个整数为第 i 个矩形块的左下角横坐标, 第二个整数为第 i 个矩形块的左下角纵坐标, 第三个整数为第 i 个矩形块的旋转度数 (必须为 0 或 90).</p><p>例如, 以下解文件表示 4 个矩形块的放置情况; 其中,<br>矩形块 0 的左下角坐标为 (0, 0), 不旋转;<br>矩形块 1 的左下角坐标为 (1, 0), 旋转 90 度;<br>矩形块 2 的左下角坐标为 (2, 0), 不旋转;<br>矩形块 3 的左下角坐标为 (2, 2), 不旋转: <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0 0 0</span><br><span class="line">1 0 90</span><br><span class="line">2 0 0</span><br><span class="line">2 2 0</span><br></pre></td></tr></table></figure></p><h2 id="提交要求">提交要求</h2><ul><li>发送至邮箱 <a href="mailto:szx@duhe.tech" target="_blank" rel="noopener">szx@duhe.tech</a>.</li><li>邮件标题格式为 "<strong>Challenge2021RPP-姓名-学校-专业</strong>".</li><li>邮件附件为单个压缩包 (文件大小 2M 以内), 文件名为 "<strong>姓名-学校-专业</strong>", 其内包含下列文件.<ul><li><strong>必要</strong> 算法的可执行文件 (Windows 平台).<ul><li>建议基于官方 SDK 开发 (<a href="https://gitee.com/suzhouxing/npbenchmark/tree/main/SDK.RPP" target="_blank" rel="noopener">https://gitee.com/suzhouxing/npbenchmark/tree/main/SDK.RPP</a>).</li><li>用 g++ 的同学编译时请静态链接, 即添加 <code>-static-libgcc -static-libstdc++</code> 编译选项.</li></ul></li><li><strong>必要</strong> 算法源码.<ul><li>可重入 (可在同一线程内反复调用而不会出现数据初始化错误或内存泄漏).</li><li>可并发 (可在同一进程内的多个线程同时运行多个算法求解实例而互不干扰, 满足此要求一般不能有全局的非只读变量).</li><li>可伸缩 (数据结构可以根据算例规模动态申请内存, 而非根据预先指定的编译期常量进行内存分配).</li></ul></li><li><strong>可选</strong> 算法在各算例上的运行情况概要, 至少包括以下几项信息 (可选, 仅在无法成功调用算法输出可通过检查程序的解时作为参考).<ul><li>算例名.</li><li>剩余未覆盖元素数.</li><li>计算耗时.</li></ul></li><li><strong>可选</strong> 算法在各算例上求得包络矩形面积最小的解文件 (仅在无法成功调用算法输出可通过检查程序的解时作为参考).</li></ul></li><li>若成功提交, 在收到邮件时以及测试完成后系统均会自动发送邮件反馈提交情况.<ul><li>若测试结果较优, 可在排行榜页面看到自己的运行情况 (<a href="https://gitee.com/suzhouxing/npbenchmark/tree/data" target="_blank" rel="noopener">https://gitee.com/suzhouxing/npbenchmark/tree/data</a>).</li></ul></li></ul><p>例如: <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">苏宙行-华科-计科.zip</span><br><span class="line">|   packing.exe</span><br><span class="line">|   results.csv</span><br><span class="line">|</span><br><span class="line">+---src</span><br><span class="line">|       main.cpp</span><br><span class="line">|       algorithm.cpp</span><br><span class="line">|       algorithm.h</span><br><span class="line">|</span><br><span class="line">+---results</span><br><span class="line">        gsrc.b10a221679.txt</span><br><span class="line">        gsrc.b30a208591.txt</span><br><span class="line">        ...</span><br></pre></td></tr></table></figure></p><h2 id="算例清单">算例清单</h2><p>下载地址: <a href="https://gitee.com/suzhouxing/npbenchmark/tree/data/RPP/Instance" target="_blank" rel="noopener">https://gitee.com/suzhouxing/npbenchmark/tree/data/RPP/Instance</a></p><p>gsrc.b10a221679<br>gsrc.b30a208591<br>gsrc.b50a198579<br>gsrc.b100a179501<br>gsrc.b200a175696<br>gsrc.b300a273170<br>mcnc.ami33.b33a1156449<br>mcnc.ami49.b49a35445424<br>mcnc.apte.b9a46561628<br>mcnc.hp.b11a8830584<br>mcnc.xerox.b10a19350296</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;矩形装箱问题是物流运输, 芯片制造与游戏开发等领域中的重要问题, 应用场景十分广泛. 矩形装箱问题主要研究如何将一系列矩形块不重叠地摆放至矩形容器中, 使得容器面积最小的问题. 比如玻璃制造过程中, 要在原料 (大矩形) 上进行切割得到一系列成品 (小矩形). 比如在集成电
      
    
    </summary>
    
      <category term="算法挑战" scheme="http://suzhouxing.github.io/techive/categories/%E7%AE%97%E6%B3%95%E6%8C%91%E6%88%98/"/>
    
    
      <category term="组合优化" scheme="http://suzhouxing.github.io/techive/tags/%E7%BB%84%E5%90%88%E4%BC%98%E5%8C%96/"/>
    
      <category term="算法挑战" scheme="http://suzhouxing.github.io/techive/tags/%E7%AE%97%E6%B3%95%E6%8C%91%E6%88%98/"/>
    
  </entry>
  
  <entry>
    <title>SmartLab Challenge 2021 - Routing and Wavelength Assignment</title>
    <link href="http://suzhouxing.github.io/techive/2021/07/10/Contest-2021RWA/"/>
    <id>http://suzhouxing.github.io/techive/2021/07/10/Contest-2021RWA/</id>
    <published>2021-07-10T09:20:58.000Z</published>
    <updated>2021-09-29T12:20:46.074Z</updated>
    
    <content type="html"><![CDATA[<p>路由与波长分配问题是通信领域中的重要问题, 具有较高的实际应用价值. 路由与波长分配问题主要研究如何为通信业务规划传输路径并分配波长, 使得所有业务可以在互不干扰的情况下传输. 高效的路由与波长分配问题的求解算法对提高网络的传输效率具有意义重大. 同时, 路由与波长分配问题还与多智能体路径规划以及芯片布线十分相似, 具有重要的理论意义.</p><h1 id="路由与波长分配算法训练">路由与波长分配算法训练</h1><h2 id="问题概述">问题概述</h2><p>给定一个有向图, 以及一系列通信业务, 每个通信业务有固定的起点和终点. 请为每个通信业务规划一条传输路径, 并为其分配一个波长, 在确保每条有向边上经过的所有业务波长互不相同的前提下, 最小化使用的波长数.</p><ul><li>参考文献.<ul><li>[1] Y. Fang, Z. Lü, Z. Su, Y. Wang, T. Zhang, and Q. Zhang, “Local Search based on a New Neighborhood for Routing and Wavelength Assignment,” in 2020 IEEE International Conference on Systems, Man, and Cybernetics (SMC), 2020, pp. 1123–1128. doi: 10.1109/SMC42975.2020.9283031.</li></ul></li></ul><h2 id="命令行参数">命令行参数</h2><p>请大家编写程序时支持两个命令行参数, 依次为运行时间上限 (单位为秒) 和随机种子 (0-65535). 算例文件已重定向至标准输入 <code>stdin</code>/<code>cin</code>, 标准输出 <code>stdout</code>/<code>cout</code> 已重定向至解文件 (如需打印调试信息, 请使用标准错误输出 <code>stderr</code>/<code>cerr</code>). 例如, 在控制台运行以下命令表示调用可执行文件 <code>rwa.exe</code> 在限时 300 秒, 随机种子为 12345 的情况下求解路径为 <code>../data/ATT.n90e274t359.txt</code> 的算例, 解文件输出至 <code>sln.ATT.n90e274t359.txt</code>: <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rwa.exe 300 123456 &lt;../data/ATT.n90e274t359.txt &gt;sln.ATT.n90e274t359.txt</span><br></pre></td></tr></table></figure></p><ul><li>运行时间上限.<ul><li>超出运行时间上限后测试程序会强行终止算法, 请确保在此之前已输出解 (最好还能自行正常退出).</li></ul></li><li>随机种子设置.<ul><li>使用 C 语言随机数生成器请用 <code>srand</code>.</li><li>使用 C++ 随机数生成器 (如 <code>mt19937</code>) 请在构造时传参或调用 <code>seed()</code> 方法设置.</li></ul></li></ul><h2 id="输入的算例文件格式">输入的算例文件格式</h2><p>所有算例的节点从 0 开始连续编号.</p><p>第一行给出三个由空白字符分隔的整数, 分别表示节点数 N, 有向边数 E, 以及通信业务数 T. 接下来连续 E 行, 每行包含两个由空白字符分隔的整数, 第 i 行表示第 i 条有向边的源点和宿点. 接下来连续 T 行, 每行包含两个由空白字符分隔的整数, 第 i 行表示第 i 个通信业务的起点和终点.</p><p>例如, 以下算例文件表示在 4 个节点和 5 条有向边的有向图上传输 3 个通信业务; 其中,<br>有向图包含 0, 1, 2, 3 共 4 个节点以及 0-1, 1-2, 2-3, 3-0, 1-0 共 4 条有向边,<br>通信业务 0 的起点为 0 终点为 1,<br>通信业务 1 的起点为 1 终点为 0,<br>通信业务 2 的起点为 1 终点为 3: <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">4 5 3</span><br><span class="line">0 1</span><br><span class="line">1 2</span><br><span class="line">2 3</span><br><span class="line">3 0</span><br><span class="line">1 0</span><br><span class="line">0 1</span><br><span class="line">1 0</span><br><span class="line">1 3</span><br></pre></td></tr></table></figure></p><h2 id="输出的解文件格式">输出的解文件格式</h2><p>输出 T 行整数表示 T 个通信业务的传输方案, 第 i 行表示第 i 个通信业务的波长分配和传输路径. 每行第一个整数表示第 i 个通信业务使用的波长, 第二个整数表示传输路径上的节点数, 随后连续 P 个由空白字符分隔的整数表示传输路径上依次经过的节点.</p><p>波长可以取 <code>int</code> 范围内任意整数, 检查程序自动统计不同的整数的数量. 传输路径上的节点若不包含通信业务的起点和终点, 检查程序将自动将其添加至路径中.</p><p>例如, 以下解文件表示 3 个通信业务的波长分配和传输路径; 其中,<br>通信业务 0 使用的波长为 1, 依次经过节点 0 和 1;<br>通信业务 1 使用的波长为 1, 直接从起点 1 到达终点 0;<br>通信业务 2 使用的波长为 0, 依次经过节点 1 和 2, 最后到达终点 3: <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1 2 0 1</span><br><span class="line">1 0</span><br><span class="line">0 2 1 2</span><br></pre></td></tr></table></figure></p><h2 id="提交要求">提交要求</h2><ul><li>发送至邮箱 <a href="mailto:szx@duhe.tech" target="_blank" rel="noopener">szx@duhe.tech</a>.</li><li>邮件标题格式为 "<strong>Challenge2021RWA-姓名-学校-专业</strong>".</li><li>邮件附件为单个压缩包 (文件大小 2M 以内), 文件名为 "<strong>姓名-学校-专业</strong>", 其内包含下列文件.<ul><li><strong>必要</strong> 算法的可执行文件 (Windows 平台).<ul><li>建议基于官方 SDK 开发 (<a href="https://gitee.com/suzhouxing/npbenchmark/tree/main/SDK.RWA" target="_blank" rel="noopener">https://gitee.com/suzhouxing/npbenchmark/tree/main/SDK.RWA</a>).</li><li>用 g++ 的同学编译时请静态链接, 即添加 <code>-static-libgcc -static-libstdc++</code> 编译选项.</li></ul></li><li><strong>必要</strong> 算法源码.<ul><li>可重入 (可在同一线程内反复调用而不会出现数据初始化错误或内存泄漏).</li><li>可并发 (可在同一进程内的多个线程同时运行多个算法求解实例而互不干扰, 满足此要求一般不能有全局的非只读变量).</li><li>可伸缩 (数据结构可以根据算例规模动态申请内存, 而非根据预先指定的编译期常量进行内存分配).</li></ul></li><li><strong>可选</strong> 算法在各算例上的运行情况概要, 至少包括以下几项信息 (可选, 仅在无法成功调用算法输出可通过检查程序的解时作为参考).<ul><li>算例名.</li><li>使用的波长数.</li><li>计算耗时.</li></ul></li><li><strong>可选</strong> 算法在各算例上求得的使用波长数最少的解文件 (可选, 仅在无法成功调用算法输出可通过检查程序的解时作为参考).</li></ul></li><li>若成功提交, 在收到邮件时以及测试完成后系统均会自动发送邮件反馈提交情况.<ul><li>若测试结果较优, 可在排行榜页面看到自己的运行情况 (<a href="https://gitee.com/suzhouxing/npbenchmark/tree/data" target="_blank" rel="noopener">https://gitee.com/suzhouxing/npbenchmark/tree/data</a>).</li></ul></li></ul><p>例如: <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">苏宙行-华科-计科.zip</span><br><span class="line">|   rwa.exe</span><br><span class="line">|   results.csv</span><br><span class="line">|</span><br><span class="line">+---src</span><br><span class="line">|       main.cpp</span><br><span class="line">|       algorithm.cpp</span><br><span class="line">|       algorithm.h</span><br><span class="line">|</span><br><span class="line">+---results</span><br><span class="line">        ATT.n90e274t359.txt</span><br><span class="line">        ATT2.n71e350t2918.txt</span><br><span class="line">        ...</span><br></pre></td></tr></table></figure></p><h2 id="算例清单">算例清单</h2><p>下载地址: <a href="https://gitee.com/suzhouxing/npbenchmark/tree/data/RWA/Instance" target="_blank" rel="noopener">https://gitee.com/suzhouxing/npbenchmark/tree/data/RWA/Instance</a></p><p>算例规模从小到大依次为 (求解难度不一定随规模增加, 但除 Z* 以外的算例应该都很容易求解):</p><p>ATT.n90e274t359<br>ATT2.n71e350t2918<br>Brasil.n27e140t1370<br>EON.n20e78t373<br>Finland.n31e102t930<br>NSF-01.n14e42t284<br>NSF-03.n14e42t285<br>NSF-12.n14e42t551<br>NSF-48.n14e42t547<br>NSF2-01.n14e44t284<br>NSF2-03.n14e44t285<br>NSF2-12.n14e44t551<br>NSF2-48.n14e44t547<br>Y3-020-1.n100e344t1975<br>Y3-020-2.n100e368t1961<br>Y3-020-3.n100e356t2055<br>Y3-020-4.n100e354t1989<br>Y3-020-5.n100e350t1975<br>Y3-040-1.n100e344t3894<br>Y3-040-2.n100e368t3956<br>Y3-040-3.n100e356t4012<br>Y3-040-4.n100e354t3959<br>Y3-040-5.n100e350t3996<br>Y3-060-1.n100e344t5967<br>Y3-060-2.n100e368t5907<br>Y3-060-3.n100e356t5989<br>Y3-060-4.n100e354t5932<br>Y3-060-5.n100e350t5990<br>Y3-080-1.n100e344t7959<br>Y3-080-2.n100e368t7911<br>Y3-080-3.n100e356t7987<br>Y3-080-4.n100e354t7908<br>Y3-080-5.n100e350t7924<br>Y3-100-1.n100e344t9900<br>Y3-100-2.n100e368t9900<br>Y3-100-3.n100e356t9900<br>Y3-100-4.n100e354t9900<br>Y3-100-5.n100e350t9900<br>Y4-020-1.n100e440t1975<br>Y4-020-2.n100e460t1961<br>Y4-020-3.n100e436t2055<br>Y4-020-4.n100e442t1989<br>Y4-020-5.n100e430t1975<br>Y4-040-1.n100e440t3894<br>Y4-040-2.n100e460t3956<br>Y4-040-3.n100e436t4012<br>Y4-040-4.n100e442t3959<br>Y4-040-5.n100e430t3996<br>Y4-060-1.n100e440t5967<br>Y4-060-2.n100e460t5907<br>Y4-060-3.n100e436t5989<br>Y4-060-4.n100e442t5932<br>Y4-060-5.n100e430t5990<br>Y4-080-1.n100e440t7959<br>Y4-080-2.n100e460t7911<br>Y4-080-3.n100e436t7987<br>Y4-080-4.n100e442t7908<br>Y4-080-5.n100e430t7924<br>Y4-100-1.n100e440t9900<br>Y4-100-2.n100e460t9900<br>Y4-100-3.n100e436t9900<br>Y4-100-4.n100e442t9900<br>Y4-100-5.n100e430t9900<br>Y5-020-1.n100e570t1975<br>Y5-020-2.n100e504t1961<br>Y5-020-3.n100e582t2055<br>Y5-020-4.n100e548t1989<br>Y5-020-5.n100e568t1975<br>Y5-040-1.n100e570t3894<br>Y5-040-2.n100e504t3956<br>Y5-040-3.n100e582t4012<br>Y5-040-4.n100e548t3959<br>Y5-040-5.n100e568t3996<br>Y5-060-1.n100e570t5967<br>Y5-060-2.n100e504t5907<br>Y5-060-3.n100e582t5989<br>Y5-060-4.n100e548t5932<br>Y5-060-5.n100e568t5990<br>Y5-080-1.n100e570t7959<br>Y5-080-2.n100e504t7911<br>Y5-080-3.n100e582t7987<br>Y5-080-4.n100e548t7908<br>Y5-080-5.n100e568t7924<br>Y5-100-1.n100e570t9900<br>Y5-100-2.n100e504t9900<br>Y5-100-3.n100e582t9900<br>Y5-100-4.n100e548t9900<br>Y5-100-5.n100e568t9900<br>Z04x25-020.n100e400t1975<br>Z04x25-040.n100e400t3894<br>Z04x25-060.n100e400t5967<br>Z04x25-080.n100e400t7959<br>Z04x25-100.n100e400t9900<br>Z05x20-020.n100e400t1975<br>Z05x20-040.n100e400t3894<br>Z05x20-060.n100e400t5967<br>Z05x20-080.n100e400t7959<br>Z05x20-100.n100e400t9900<br>Z06x17-020.n102e408t1975<br>Z06x17-040.n102e408t3894<br>Z06x17-060.n102e408t5967<br>Z06x17-080.n102e408t7959<br>Z06x17-100.n102e408t10302<br>Z08x13-020.n104e416t1975<br>Z08x13-040.n104e416t3894<br>Z08x13-060.n104e416t5967<br>Z08x13-080.n104e416t7959<br>Z08x13-100.n104e416t10712<br>Z10x10-020.n100e400t1975<br>Z10x10-040.n100e400t3894<br>Z10x10-060.n100e400t5967<br>Z10x10-080.n100e400t7959<br>Z10x10-100.n100e400t9900</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;路由与波长分配问题是通信领域中的重要问题, 具有较高的实际应用价值. 路由与波长分配问题主要研究如何为通信业务规划传输路径并分配波长, 使得所有业务可以在互不干扰的情况下传输. 高效的路由与波长分配问题的求解算法对提高网络的传输效率具有意义重大. 同时, 路由与波长分配问题
      
    
    </summary>
    
      <category term="算法挑战" scheme="http://suzhouxing.github.io/techive/categories/%E7%AE%97%E6%B3%95%E6%8C%91%E6%88%98/"/>
    
    
      <category term="组合优化" scheme="http://suzhouxing.github.io/techive/tags/%E7%BB%84%E5%90%88%E4%BC%98%E5%8C%96/"/>
    
      <category term="算法挑战" scheme="http://suzhouxing.github.io/techive/tags/%E7%AE%97%E6%B3%95%E6%8C%91%E6%88%98/"/>
    
  </entry>
  
  <entry>
    <title>SmartLab Challenge 2020 - Flexible Job Shop Scheduling</title>
    <link href="http://suzhouxing.github.io/techive/2021/01/14/Contest-2020FJSP/"/>
    <id>http://suzhouxing.github.io/techive/2021/01/14/Contest-2020FJSP/</id>
    <published>2021-01-14T02:05:34.000Z</published>
    <updated>2021-09-29T12:21:38.832Z</updated>
    
    <content type="html"><![CDATA[<p>柔性作业车间调度问题是智能制造与高性能计算等领域中的重要问题, 具有广泛应用场景. 柔性作业车间调度问题主要研究如何调度有限的资源依次执行多项任务, 使得完成所有任务的完工时间最短的问题. 比如芯片代工厂生产芯片时, 每块晶圆需要在不同机台依次完成光刻与蚀刻等多道工序. 比如在某些大规模并行计算场景中, 计算任务间存在依赖关系, 后继任务的输入为前驱任务的输出. 高效的柔性作业车间调度问题的求解算法具有极其重要的理论与应用价值.</p><h1 id="柔性作业车间调度算法训练">柔性作业车间调度算法训练</h1><h2 id="问题概述">问题概述</h2><p>给定若干任务, 每个任务可由若干给定的机器中的任意一台花费给定的时间完成. 每个任务的全部前序任务完工后才能开工, 在不同机器间转移不消耗时间. 每台机器同一时间仅能执行一个任务且不可抢占, 即完成一个任务后才能开始下一个任务. 请确定每个任务何时在哪台机器上开工, 使得最后一个完工的任务最早完工.</p><p>柔性作业车间调度问题为上述任务调度问题的特例, 任务依赖拓扑为若干条单链. 即给定若干工件, 每个工件由一系列必须依次完成的工序组成.</p><ul><li>参考文献.<ul><li>[1] J. Ding, Z. Lü, C. M. Li, L. Shen, L. Xu, and F. Glover, “A two-individual based evolutionary algorithm for the flexible job shop scheduling problem,” in Proceedings of the AAAI Conference on Artificial Intelligence, Jul. 2019, vol. 33, pp. 2262–2271. doi: 10.1609/aaai.v33i01.33012262.</li><li>[2] C. Zhang, P. Li, Z. Guan, and Y. Rao, “A tabu search algorithm with a new neighborhood structure for the job shop scheduling problem,” Computers &amp; Operations Research, vol. 34, no. 11, pp. 3229–3242, 2007, doi: 10.1016/j.cor.2005.12.002.</li><li>[3] M. A. González, C. R. Vela, and R. Varela, “Scatter search with path relinking for the flexible job shop scheduling problem,” European Journal of Operational Research, vol. 245, no. 1, Art. no. 1, Aug. 2015, doi: 10.1016/j.ejor.2015.02.052.</li></ul></li></ul><h2 id="命令行参数">命令行参数</h2><p>请大家编写程序时支持两个命令行参数, 依次为运行时间上限 (单位为秒) 和随机种子 (0-65535). 算例文件已重定向至标准输入 <code>stdin</code>/<code>cin</code>, 标准输出 <code>stdout</code>/<code>cout</code> 已重定向至解文件 (如需打印调试信息, 请使用标准错误输出 <code>stderr</code>/<code>cerr</code>). 例如, 在控制台运行以下命令表示调用可执行文件 <code>fjsp.exe</code> 在限时 300 秒, 随机种子为 12345 的情况下求解路径为 <code>../data/jsp.FT06.m6j6c1.txt</code> 的算例, 解文件输出至 <code>sln.jsp.FT06.m6j6c1.txt</code>: <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fjsp.exe 300 123456 &lt;../data/jsp.FT06.m6j6c1.txt &gt;sln.jsp.FT06.m6j6c1.txt</span><br></pre></td></tr></table></figure></p><ul><li>运行时间上限.<ul><li>超出运行时间上限后测试程序会强行终止算法, 请确保在此之前已输出解 (最好还能自行正常退出).</li></ul></li><li>随机种子设置.<ul><li>使用 C 语言随机数生成器请用 <code>srand</code>.</li><li>使用 C++ 随机数生成器 (如 <code>mt19937</code>) 请在构造时传参或调用 <code>seed()</code> 方法设置.</li></ul></li></ul><h2 id="输入的算例文件格式">输入的算例文件格式</h2><p>所有算例的任务和机器分别从 0 开始连续编号.</p><p>第一行给出三个由空白字符分隔的整数, 分别表示任务数 N, 机器数 M, 以及所有任务所有工序的最大的候选机器数 C (若 C = 1 说明该算例为 JSP 算例). 接下来连续 N 行, 第 i 行表示第 i 个任务的信息. 每行第一个整数表示第 i 个任务的工序数 K, 随后连续 K 组由空白字符分隔的数据, 第 j 组数据表示该任务的第 j 道工序的信息. 每组数据第一个整数表示可执行该工序的候选机器数 S, 随后连续 S 个由空白字符分隔的二元组, 二元组 (G, D) 表示该工序可由机器 G 执行且加工时长为 D.</p><p>例如, 以下算例文件表示有 2 个任务和 4 台机器, 每个任务至多 2 台候选机器; 其中,<br>任务 0 由 4 道工序构成,<br>其工序 0 可由机器 1 花费时长 654 完成,<br>其工序 1 可由机器 2 花费时长 147 完成,<br>其工序 2 可由机器 3 花费时长 345 完成,<br>其工序 3 可由机器 0 花费时长 447 完成;<br>任务 1 由 3 道工序构成,<br>其工序 0 可由机器 1 花费时长 321 完成或由机器 0 花费时长 321 完成,<br>其工序 1 可由机器 2 花费时长 520 完成,<br>其工序 2 可由机器 3 花费时长 789 完成: <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2 4 2</span><br><span class="line">4    1  1 654    1  2 147   1  3 345    1  0 447</span><br><span class="line">3    2  1 321  0 321    1  2 520    1  3 789</span><br></pre></td></tr></table></figure></p><p>上述算例内数据的分组情况可以更加直观地表示成下面的情况: <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2 4 2</span><br><span class="line">4 [1 (1 654)] [1 (2 147)] [1 (3 345)] [1 (0 447)]</span><br><span class="line">3 [2 (1 321) (0 321)] [1 (2 520)] [1 (3 789)]</span><br></pre></td></tr></table></figure></p><p>为了使算例的数据分组更加直观, 给出的算例可能会按照如下约定: 使用 4 个空格分隔每行的 K 组数据, 使用 2 个空格分隔 S 个二元组.</p><h2 id="输出的解文件格式">输出的解文件格式</h2><p>输出 M 行整数表示 M 台机器的任务分配与排序情况, 第 i 行表示第 i 台机器上执行的工序的有序列表. 每一行第一个整数表示第 i 台机器加工的工序数 E, 随后连续 E 个由空白字符分隔的二元组, 二元组 (J, O) 表示加工了任务 J 的工序 O, 二元组的出现顺序表示第 i 台机器的加工顺序.</p><p>例如, 以下解文件表示 2 台机器上的任务分配与排序情况; 其中,<br>机器 0 执行了 3 道工序, 依次为任务 1 的工序 1, 任务 0 的工序 0, 任务 2 的工序 0;<br>机器 1 加工了 2 道工序, 依次为任务 0 的工序 1, 任务 1 的工序 0: <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">3    1 1  0 0  2 0</span><br><span class="line">2    0 1  1 0</span><br></pre></td></tr></table></figure></p><p>注意上述调度方案存在死锁, 不是可行的调度方案.</p><h2 id="提交要求">提交要求</h2><ul><li>发送至邮箱 <a href="mailto:szx@duhe.tech" target="_blank" rel="noopener">szx@duhe.tech</a>.</li><li>邮件标题格式为 "<strong>Challenge2020FJSP-姓名-学校-专业</strong>".</li><li>邮件附件为单个压缩包, 文件名为 "<strong>姓名-学校-专业</strong>", 其内包含下列文件.<ul><li><strong>必要</strong> 算法的可执行文件 (Windows 平台).<ul><li>建议基于官方 SDK 开发 (<a href="https://gitee.com/suzhouxing/npbenchmark/tree/main/SDK.FJSP" target="_blank" rel="noopener">https://gitee.com/suzhouxing/npbenchmark/tree/main/SDK.FJSP</a>).</li><li>用 g++ 的同学编译时请静态链接, 即添加 <code>-static-libgcc -static-libstdc++</code> 编译选项.</li></ul></li><li><strong>必要</strong> 算法源码.<ul><li>可重入 (可在同一线程内反复调用而不会出现数据初始化错误或内存泄漏).</li><li>可并发 (可在同一进程内的多个线程同时运行多个算法求解实例而互不干扰, 满足此要求一般不能有全局的非只读变量).</li><li>可伸缩 (数据结构可以根据算例规模动态申请内存, 而非根据预先指定的编译期常量进行内存分配).</li></ul></li><li><strong>可选</strong> 算法在各算例上的运行情况概要, 至少包括以下几项信息 (可选, 仅在无法成功调用算法输出可通过检查程序的解时作为参考).<ul><li>算例名.</li><li>所有任务的完工时间.</li><li>计算耗时.</li></ul></li><li><strong>可选</strong> 算法在各算例上求得的完工时间最短的解文件 (可选, 仅在无法成功调用算法输出可通过检查程序的解时作为参考).</li></ul></li><li>若成功提交, 在收到邮件时以及测试完成后系统均会自动发送邮件反馈提交情况.<ul><li>若测试结果较优, 可在排行榜页面看到自己的运行情况 (<a href="https://gitee.com/suzhouxing/npbenchmark/tree/data" target="_blank" rel="noopener">https://gitee.com/suzhouxing/npbenchmark/tree/data</a>).</li></ul></li></ul><p>例如: <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">苏宙行-华科-计科.zip</span><br><span class="line">|   fjsp.exe</span><br><span class="line">|   results.csv</span><br><span class="line">|</span><br><span class="line">+---src</span><br><span class="line">|       main.cpp</span><br><span class="line">|       algorithm.cpp</span><br><span class="line">|       algorithm.h</span><br><span class="line">|</span><br><span class="line">+---results</span><br><span class="line">        fjsp.barnes.mt10c1.m11j10c2.txt</span><br><span class="line">        fjsp.barnes.mt10cc.m12j10c2.txt</span><br><span class="line">        ...</span><br></pre></td></tr></table></figure></p><h2 id="算例清单">算例清单</h2><p>下载地址: <a href="https://gitee.com/suzhouxing/npbenchmark/tree/data/FJSP/Instance" target="_blank" rel="noopener">https://gitee.com/suzhouxing/npbenchmark/tree/data/FJSP/Instance</a></p><p>fjsp.barnes.mt10c1.m11j10c2<br>fjsp.barnes.mt10cc.m12j10c2<br>fjsp.barnes.mt10x.m11j10c2<br>fjsp.barnes.mt10xx.m12j10c3<br>fjsp.barnes.mt10xxx.m13j10c4<br>fjsp.barnes.mt10xy.m12j10c2<br>fjsp.barnes.mt10xyz.m13j10c2<br>fjsp.barnes.setb4c9.m11j15c2<br>fjsp.barnes.setb4cc.m12j15c2<br>fjsp.barnes.setb4x.m11j15c2<br>fjsp.barnes.setb4xx.m12j15c3<br>fjsp.barnes.setb4xxx.m13j15c4<br>fjsp.barnes.setb4xy.m12j15c2<br>fjsp.barnes.setb4xyz.m13j15c2<br>fjsp.barnes.seti5c12.m16j15c2<br>fjsp.barnes.seti5cc.m17j15c2<br>fjsp.barnes.seti5x.m16j15c2<br>fjsp.barnes.seti5xx.m17j15c3<br>fjsp.barnes.seti5xxx.m18j15c4<br>fjsp.barnes.seti5xy.m17j15c2<br>fjsp.barnes.seti5xyz.m18j15c2<br>fjsp.brandimarte.Mk01.m6j10c3<br>fjsp.brandimarte.Mk02.m6j10c6<br>fjsp.brandimarte.Mk03.m8j15c5<br>fjsp.brandimarte.Mk04.m8j15c3<br>fjsp.brandimarte.Mk05.m4j15c2<br>fjsp.brandimarte.Mk06.m15j10c5<br>fjsp.brandimarte.Mk07.m5j20c5<br>fjsp.brandimarte.Mk08.m10j20c2<br>fjsp.brandimarte.Mk09.m10j20c5<br>fjsp.brandimarte.Mk10.m15j20c5<br>fjsp.dauzere.01a.m5j10c3<br>fjsp.dauzere.02a.m5j10c4<br>fjsp.dauzere.03a.m5j10c5<br>fjsp.dauzere.04a.m5j10c3<br>fjsp.dauzere.05a.m5j10c4<br>fjsp.dauzere.06a.m5j10c5<br>fjsp.dauzere.07a.m8j15c4<br>fjsp.dauzere.08a.m8j15c6<br>fjsp.dauzere.09a.m8j15c8<br>fjsp.dauzere.10a.m8j15c4<br>fjsp.dauzere.11a.m8j15c6<br>fjsp.dauzere.12a.m8j15c8<br>fjsp.dauzere.13a.m10j20c4<br>fjsp.dauzere.14a.m10j20c7<br>fjsp.dauzere.15a.m10j20c10<br>fjsp.dauzere.16a.m10j20c4<br>fjsp.dauzere.17a.m10j20c7<br>fjsp.dauzere.18a.m10j20c10<br>fjsp.hurink.edata-abz5.m10j10c2<br>fjsp.hurink.edata-abz6.m10j10c2<br>fjsp.hurink.edata-abz7.m15j20c3<br>fjsp.hurink.edata-abz8.m15j20c3<br>fjsp.hurink.edata-abz9.m15j20c3<br>fjsp.hurink.edata-car1.m5j11c2<br>fjsp.hurink.edata-car2.m4j13c2<br>fjsp.hurink.edata-car3.m5j12c2<br>fjsp.hurink.edata-car4.m4j14c2<br>fjsp.hurink.edata-car5.m6j10c2<br>fjsp.hurink.edata-car6.m9j8c2<br>fjsp.hurink.edata-car7.m7j7c2<br>fjsp.hurink.edata-car8.m8j8c2<br>fjsp.hurink.edata-la01.m5j10c2<br>fjsp.hurink.edata-la02.m5j10c2<br>fjsp.hurink.edata-la03.m5j10c2<br>fjsp.hurink.edata-la04.m5j10c2<br>fjsp.hurink.edata-la05.m5j10c2<br>fjsp.hurink.edata-la06.m5j15c2<br>fjsp.hurink.edata-la07.m5j15c2<br>fjsp.hurink.edata-la08.m5j15c2<br>fjsp.hurink.edata-la09.m5j15c2<br>fjsp.hurink.edata-la10.m5j15c2<br>fjsp.hurink.edata-la11.m5j20c2<br>fjsp.hurink.edata-la12.m5j20c2<br>fjsp.hurink.edata-la13.m5j20c2<br>fjsp.hurink.edata-la14.m5j20c2<br>fjsp.hurink.edata-la15.m5j20c2<br>fjsp.hurink.edata-la16.m10j10c2<br>fjsp.hurink.edata-la17.m10j10c2<br>fjsp.hurink.edata-la18.m10j10c2<br>fjsp.hurink.edata-la19.m10j10c2<br>fjsp.hurink.edata-la20.m10j10c2<br>fjsp.hurink.edata-la21.m10j15c3<br>fjsp.hurink.edata-la22.m10j15c3<br>fjsp.hurink.edata-la23.m10j15c2<br>fjsp.hurink.edata-la24.m10j15c3<br>fjsp.hurink.edata-la25.m10j15c3<br>fjsp.hurink.edata-la26.m10j20c3<br>fjsp.hurink.edata-la27.m10j20c3<br>fjsp.hurink.edata-la28.m10j20c3<br>fjsp.hurink.edata-la29.m10j20c3<br>fjsp.hurink.edata-la30.m10j20c3<br>fjsp.hurink.edata-la31.m10j30c3<br>fjsp.hurink.edata-la32.m10j30c3<br>fjsp.hurink.edata-la33.m10j30c2<br>fjsp.hurink.edata-la34.m10j30c3<br>fjsp.hurink.edata-la35.m10j30c2<br>fjsp.hurink.edata-la36.m15j15c3<br>fjsp.hurink.edata-la37.m15j15c3<br>fjsp.hurink.edata-la38.m15j15c3<br>fjsp.hurink.edata-la39.m15j15c3<br>fjsp.hurink.edata-la40.m15j15c3<br>fjsp.hurink.edata-mt06.m6j6c2<br>fjsp.hurink.edata-mt10.m10j10c2<br>fjsp.hurink.edata-mt20.m5j20c2<br>fjsp.hurink.edata-orb01.m10j10c2<br>fjsp.hurink.edata-orb02.m10j10c2<br>fjsp.hurink.edata-orb03.m10j10c2<br>fjsp.hurink.edata-orb04.m10j10c2<br>fjsp.hurink.edata-orb05.m10j10c2<br>fjsp.hurink.edata-orb06.m10j10c2<br>fjsp.hurink.edata-orb07.m10j10c2<br>fjsp.hurink.edata-orb08.m10j10c2<br>fjsp.hurink.edata-orb09.m10j10c2<br>fjsp.hurink.edata-orb10.m10j10c2<br>fjsp.hurink.rdata-abz5.m10j10c3<br>fjsp.hurink.rdata-abz6.m10j10c3<br>fjsp.hurink.rdata-abz7.m15j20c3<br>fjsp.hurink.rdata-abz8.m15j20c3<br>fjsp.hurink.rdata-abz9.m15j20c3<br>fjsp.hurink.rdata-car1.m5j11c3<br>fjsp.hurink.rdata-car2.m4j13c3<br>fjsp.hurink.rdata-car3.m5j12c3<br>fjsp.hurink.rdata-car4.m4j14c3<br>fjsp.hurink.rdata-car5.m6j10c3<br>fjsp.hurink.rdata-car6.m9j8c3<br>fjsp.hurink.rdata-car7.m7j7c3<br>fjsp.hurink.rdata-car8.m8j8c3<br>fjsp.hurink.rdata-la01.m5j10c3<br>fjsp.hurink.rdata-la02.m5j10c3<br>fjsp.hurink.rdata-la03.m5j10c3<br>fjsp.hurink.rdata-la04.m5j10c3<br>fjsp.hurink.rdata-la05.m5j10c3<br>fjsp.hurink.rdata-la06.m5j15c3<br>fjsp.hurink.rdata-la07.m5j15c3<br>fjsp.hurink.rdata-la08.m5j15c3<br>fjsp.hurink.rdata-la09.m5j15c3<br>fjsp.hurink.rdata-la10.m5j15c3<br>fjsp.hurink.rdata-la11.m5j20c3<br>fjsp.hurink.rdata-la12.m5j20c3<br>fjsp.hurink.rdata-la13.m5j20c3<br>fjsp.hurink.rdata-la14.m5j20c3<br>fjsp.hurink.rdata-la15.m5j20c3<br>fjsp.hurink.rdata-la16.m10j10c3<br>fjsp.hurink.rdata-la17.m10j10c3<br>fjsp.hurink.rdata-la18.m10j10c3<br>fjsp.hurink.rdata-la19.m10j10c3<br>fjsp.hurink.rdata-la20.m10j10c3<br>fjsp.hurink.rdata-la21.m10j15c3<br>fjsp.hurink.rdata-la22.m10j15c3<br>fjsp.hurink.rdata-la23.m10j15c3<br>fjsp.hurink.rdata-la24.m10j15c3<br>fjsp.hurink.rdata-la25.m10j15c3<br>fjsp.hurink.rdata-la26.m10j20c3<br>fjsp.hurink.rdata-la27.m10j20c3<br>fjsp.hurink.rdata-la28.m10j20c3<br>fjsp.hurink.rdata-la29.m10j20c3<br>fjsp.hurink.rdata-la30.m10j20c3<br>fjsp.hurink.rdata-la31.m10j30c3<br>fjsp.hurink.rdata-la32.m10j30c3<br>fjsp.hurink.rdata-la33.m10j30c3<br>fjsp.hurink.rdata-la34.m10j30c3<br>fjsp.hurink.rdata-la35.m10j30c3<br>fjsp.hurink.rdata-la36.m15j15c3<br>fjsp.hurink.rdata-la37.m15j15c3<br>fjsp.hurink.rdata-la38.m15j15c3<br>fjsp.hurink.rdata-la39.m15j15c3<br>fjsp.hurink.rdata-la40.m15j15c3<br>fjsp.hurink.rdata-mt06.m6j6c3<br>fjsp.hurink.rdata-mt10.m10j10c3<br>fjsp.hurink.rdata-mt20.m5j20c3<br>fjsp.hurink.rdata-orb01.m10j10c3<br>fjsp.hurink.rdata-orb02.m10j10c3<br>fjsp.hurink.rdata-orb03.m10j10c3<br>fjsp.hurink.rdata-orb04.m10j10c3<br>fjsp.hurink.rdata-orb05.m10j10c3<br>fjsp.hurink.rdata-orb06.m10j10c3<br>fjsp.hurink.rdata-orb07.m10j10c3<br>fjsp.hurink.rdata-orb08.m10j10c3<br>fjsp.hurink.rdata-orb09.m10j10c3<br>fjsp.hurink.rdata-orb10.m10j10c3<br>##fjsp.hurink.sdata-abz5.m10j10c1 &lt;=&gt; jsp.ABZ05.m10j10c1<br>##fjsp.hurink.sdata-abz6.m10j10c1 &lt;=&gt; jsp.ABZ06.m10j10c1<br>##fjsp.hurink.sdata-abz7.m15j20c1 &lt;=&gt; jsp.ABZ07.m15j20c1<br>##fjsp.hurink.sdata-abz8.m15j20c1 &lt;=&gt; jsp.ABZ08.m15j20c1<br>##fjsp.hurink.sdata-abz9.m15j20c1 &lt;=&gt; jsp.ABZ09.m15j20c1<br>fjsp.hurink.sdata-car1.m5j11c1<br>fjsp.hurink.sdata-car2.m4j13c1<br>fjsp.hurink.sdata-car3.m5j12c1<br>fjsp.hurink.sdata-car4.m4j14c1<br>fjsp.hurink.sdata-car5.m6j10c1<br>fjsp.hurink.sdata-car6.m9j8c1<br>fjsp.hurink.sdata-car7.m7j7c1<br>fjsp.hurink.sdata-car8.m8j8c1<br>##fjsp.hurink.sdata-la01.m5j10c1 &lt;=&gt; jsp.LA01.m5j10c1<br>##fjsp.hurink.sdata-la02.m5j10c1 &lt;=&gt; jsp.LA02.m5j10c1<br>##fjsp.hurink.sdata-la03.m5j10c1 &lt;=&gt; jsp.LA03.m5j10c1<br>##fjsp.hurink.sdata-la04.m5j10c1 &lt;=&gt; jsp.LA04.m5j10c1<br>##fjsp.hurink.sdata-la05.m5j10c1 &lt;=&gt; jsp.LA05.m5j10c1<br>##fjsp.hurink.sdata-la06.m5j15c1 &lt;=&gt; jsp.LA06.m5j15c1<br>##fjsp.hurink.sdata-la07.m5j15c1 &lt;=&gt; jsp.LA07.m5j15c1<br>##fjsp.hurink.sdata-la08.m5j15c1 &lt;=&gt; jsp.LA08.m5j15c1<br>##fjsp.hurink.sdata-la09.m5j15c1 &lt;=&gt; jsp.LA09.m5j15c1<br>##fjsp.hurink.sdata-la10.m5j15c1 &lt;=&gt; jsp.LA10.m5j15c1<br>##fjsp.hurink.sdata-la11.m5j20c1 &lt;=&gt; jsp.LA11.m5j20c1<br>##fjsp.hurink.sdata-la12.m5j20c1 &lt;=&gt; jsp.LA12.m5j20c1<br>##fjsp.hurink.sdata-la13.m5j20c1 &lt;=&gt; jsp.LA13.m5j20c1<br>##fjsp.hurink.sdata-la14.m5j20c1 &lt;=&gt; jsp.LA14.m5j20c1<br>##fjsp.hurink.sdata-la15.m5j20c1 &lt;=&gt; jsp.LA15.m5j20c1<br>##fjsp.hurink.sdata-la16.m10j10c1 &lt;=&gt; jsp.LA16.m10j10c1<br>##fjsp.hurink.sdata-la17.m10j10c1 &lt;=&gt; jsp.LA17.m10j10c1<br>##fjsp.hurink.sdata-la18.m10j10c1 &lt;=&gt; jsp.LA18.m10j10c1<br>##fjsp.hurink.sdata-la19.m10j10c1 &lt;=&gt; jsp.LA19.m10j10c1<br>##fjsp.hurink.sdata-la20.m10j10c1 &lt;=&gt; jsp.LA20.m10j10c1<br>##fjsp.hurink.sdata-la21.m10j15c1 &lt;=&gt; jsp.LA21.m10j15c1<br>##fjsp.hurink.sdata-la22.m10j15c1 &lt;=&gt; jsp.LA22.m10j15c1<br>##fjsp.hurink.sdata-la23.m10j15c1 &lt;=&gt; jsp.LA23.m10j15c1<br>##fjsp.hurink.sdata-la24.m10j15c1 &lt;=&gt; jsp.LA24.m10j15c1<br>##fjsp.hurink.sdata-la25.m10j15c1 &lt;=&gt; jsp.LA25.m10j15c1<br>##fjsp.hurink.sdata-la26.m10j20c1 &lt;=&gt; jsp.LA26.m10j20c1<br>##fjsp.hurink.sdata-la27.m10j20c1 &lt;=&gt; jsp.LA27.m10j20c1<br>##fjsp.hurink.sdata-la28.m10j20c1 &lt;=&gt; jsp.LA28.m10j20c1<br>##fjsp.hurink.sdata-la29.m10j20c1 &lt;=&gt; jsp.LA29.m10j20c1<br>##fjsp.hurink.sdata-la30.m10j20c1 &lt;=&gt; jsp.LA30.m10j20c1<br>##fjsp.hurink.sdata-la31.m10j30c1 &lt;=&gt; jsp.LA31.m10j30c1<br>##fjsp.hurink.sdata-la32.m10j30c1 &lt;=&gt; jsp.LA32.m10j30c1<br>##fjsp.hurink.sdata-la33.m10j30c1 &lt;=&gt; jsp.LA33.m10j30c1<br>##fjsp.hurink.sdata-la34.m10j30c1 &lt;=&gt; jsp.LA34.m10j30c1<br>##fjsp.hurink.sdata-la35.m10j30c1 &lt;=&gt; jsp.LA35.m10j30c1<br>##fjsp.hurink.sdata-la36.m15j15c1 &lt;=&gt; jsp.LA36.m15j15c1<br>##fjsp.hurink.sdata-la37.m15j15c1 &lt;=&gt; jsp.LA37.m15j15c1<br>##fjsp.hurink.sdata-la38.m15j15c1 &lt;=&gt; jsp.LA38.m15j15c1<br>##fjsp.hurink.sdata-la39.m15j15c1 &lt;=&gt; jsp.LA39.m15j15c1<br>##fjsp.hurink.sdata-la40.m15j15c1 &lt;=&gt; jsp.LA40.m15j15c1<br>##fjsp.hurink.sdata-mt06.m6j6c1 &lt;=&gt; jsp.FT06.m6j6c1<br>##fjsp.hurink.sdata-mt10.m10j10c1 &lt;=&gt; jsp.FT10.m10j10c1<br>##fjsp.hurink.sdata-mt20.m5j20c1 &lt;=&gt; jsp.FT20.m5j20c1<br>##fjsp.hurink.sdata-orb01.m10j10c1 &lt;=&gt; jsp.ORB01.m10j10c1<br>##fjsp.hurink.sdata-orb02.m10j10c1 &lt;=&gt; jsp.ORB02.m10j10c1<br>##fjsp.hurink.sdata-orb03.m10j10c1 &lt;=&gt; jsp.ORB03.m10j10c1<br>##fjsp.hurink.sdata-orb04.m10j10c1 &lt;=&gt; jsp.ORB04.m10j10c1<br>##fjsp.hurink.sdata-orb05.m10j10c1 &lt;=&gt; jsp.ORB05.m10j10c1<br>##fjsp.hurink.sdata-orb06.m10j10c1 &lt;=&gt; jsp.ORB06.m10j10c1<br>##fjsp.hurink.sdata-orb07.m10j10c1 &lt;=&gt; jsp.ORB07.m10j10c1<br>##fjsp.hurink.sdata-orb08.m10j10c1 &lt;=&gt; jsp.ORB08.m10j10c1<br>##fjsp.hurink.sdata-orb09.m10j10c1 &lt;=&gt; jsp.ORB09.m10j10c1<br>##fjsp.hurink.sdata-orb10.m10j10c1 &lt;=&gt; jsp.ORB10.m10j10c1<br>fjsp.hurink.vdata-abz5.m10j10c9<br>fjsp.hurink.vdata-abz6.m10j10c8<br>fjsp.hurink.vdata-abz7.m15j20c11<br>fjsp.hurink.vdata-abz8.m15j20c13<br>fjsp.hurink.vdata-abz9.m15j20c12<br>fjsp.hurink.vdata-car1.m5j11c5<br>fjsp.hurink.vdata-car2.m4j13c4<br>fjsp.hurink.vdata-car3.m5j12c4<br>fjsp.hurink.vdata-car4.m4j14c3<br>fjsp.hurink.vdata-car5.m6j10c5<br>fjsp.hurink.vdata-car6.m9j8c7<br>fjsp.hurink.vdata-car7.m7j7c6<br>fjsp.hurink.vdata-car8.m8j8c7<br>fjsp.hurink.vdata-la01.m5j10c5<br>fjsp.hurink.vdata-la02.m5j10c5<br>fjsp.hurink.vdata-la03.m5j10c5<br>fjsp.hurink.vdata-la04.m5j10c4<br>fjsp.hurink.vdata-la05.m5j10c5<br>fjsp.hurink.vdata-la06.m5j15c5<br>fjsp.hurink.vdata-la07.m5j15c5<br>fjsp.hurink.vdata-la08.m5j15c5<br>fjsp.hurink.vdata-la09.m5j15c5<br>fjsp.hurink.vdata-la10.m5j15c5<br>fjsp.hurink.vdata-la11.m5j20c5<br>fjsp.hurink.vdata-la12.m5j20c5<br>fjsp.hurink.vdata-la13.m5j20c4<br>fjsp.hurink.vdata-la14.m5j20c5<br>fjsp.hurink.vdata-la15.m5j20c5<br>fjsp.hurink.vdata-la16.m10j10c8<br>fjsp.hurink.vdata-la17.m10j10c9<br>fjsp.hurink.vdata-la18.m10j10c9<br>fjsp.hurink.vdata-la19.m10j10c8<br>fjsp.hurink.vdata-la20.m10j10c8<br>fjsp.hurink.vdata-la21.m10j15c8<br>fjsp.hurink.vdata-la22.m10j15c8<br>fjsp.hurink.vdata-la23.m10j15c8<br>fjsp.hurink.vdata-la24.m10j15c8<br>fjsp.hurink.vdata-la25.m10j15c9<br>fjsp.hurink.vdata-la26.m10j20c9<br>fjsp.hurink.vdata-la27.m10j20c9<br>fjsp.hurink.vdata-la28.m10j20c9<br>fjsp.hurink.vdata-la29.m10j20c9<br>fjsp.hurink.vdata-la30.m10j20c9<br>fjsp.hurink.vdata-la31.m10j30c9<br>fjsp.hurink.vdata-la32.m10j30c9<br>fjsp.hurink.vdata-la33.m10j30c8<br>fjsp.hurink.vdata-la34.m10j30c9<br>fjsp.hurink.vdata-la35.m10j30c9<br>fjsp.hurink.vdata-la36.m15j15c12<br>fjsp.hurink.vdata-la37.m15j15c12<br>fjsp.hurink.vdata-la38.m15j15c12<br>fjsp.hurink.vdata-la39.m15j15c11<br>fjsp.hurink.vdata-la40.m15j15c11<br>fjsp.hurink.vdata-mt06.m6j6c5<br>fjsp.hurink.vdata-mt10.m10j10c8<br>fjsp.hurink.vdata-mt20.m5j20c5<br>fjsp.hurink.vdata-orb01.m10j10c8<br>fjsp.hurink.vdata-orb02.m10j10c8<br>fjsp.hurink.vdata-orb03.m10j10c8<br>fjsp.hurink.vdata-orb04.m10j10c9<br>fjsp.hurink.vdata-orb05.m10j10c8<br>fjsp.hurink.vdata-orb06.m10j10c8<br>fjsp.hurink.vdata-orb07.m10j10c8<br>fjsp.hurink.vdata-orb08.m10j10c8<br>fjsp.hurink.vdata-orb09.m10j10c8<br>fjsp.hurink.vdata-orb10.m10j10c8<br>jsp.ABZ05.m10j10c1<br>jsp.ABZ06.m10j10c1<br>jsp.ABZ07.m15j20c1<br>jsp.ABZ08.m15j20c1<br>jsp.ABZ09.m15j20c1<br>jsp.DMU01.m15j20c1<br>jsp.DMU02.m15j20c1<br>jsp.DMU03.m15j20c1<br>jsp.DMU04.m15j20c1<br>jsp.DMU05.m15j20c1<br>jsp.DMU06.m20j20c1<br>jsp.DMU07.m20j20c1<br>jsp.DMU08.m20j20c1<br>jsp.DMU09.m20j20c1<br>jsp.DMU10.m20j20c1<br>jsp.DMU11.m15j30c1<br>jsp.DMU12.m15j30c1<br>jsp.DMU13.m15j30c1<br>jsp.DMU14.m15j30c1<br>jsp.DMU15.m15j30c1<br>jsp.DMU16.m20j30c1<br>jsp.DMU17.m20j30c1<br>jsp.DMU18.m20j30c1<br>jsp.DMU19.m20j30c1<br>jsp.DMU20.m20j30c1<br>jsp.DMU21.m15j40c1<br>jsp.DMU22.m15j40c1<br>jsp.DMU23.m15j40c1<br>jsp.DMU24.m15j40c1<br>jsp.DMU25.m15j40c1<br>jsp.DMU26.m20j40c1<br>jsp.DMU27.m20j40c1<br>jsp.DMU28.m20j40c1<br>jsp.DMU29.m20j40c1<br>jsp.DMU30.m20j40c1<br>jsp.DMU31.m15j50c1<br>jsp.DMU32.m15j50c1<br>jsp.DMU33.m15j50c1<br>jsp.DMU34.m15j50c1<br>jsp.DMU35.m15j50c1<br>jsp.DMU36.m20j50c1<br>jsp.DMU37.m20j50c1<br>jsp.DMU38.m20j50c1<br>jsp.DMU39.m20j50c1<br>jsp.DMU40.m20j50c1<br>jsp.DMU41.m15j20c1<br>jsp.DMU42.m15j20c1<br>jsp.DMU43.m15j20c1<br>jsp.DMU44.m15j20c1<br>jsp.DMU45.m15j20c1<br>jsp.DMU46.m20j20c1<br>jsp.DMU47.m20j20c1<br>jsp.DMU48.m20j20c1<br>jsp.DMU49.m20j20c1<br>jsp.DMU50.m20j20c1<br>jsp.DMU51.m15j30c1<br>jsp.DMU52.m15j30c1<br>jsp.DMU53.m15j30c1<br>jsp.DMU54.m15j30c1<br>jsp.DMU55.m15j30c1<br>jsp.DMU56.m20j30c1<br>jsp.DMU57.m20j30c1<br>jsp.DMU58.m20j30c1<br>jsp.DMU59.m20j30c1<br>jsp.DMU60.m20j30c1<br>jsp.DMU61.m15j40c1<br>jsp.DMU62.m15j40c1<br>jsp.DMU63.m15j40c1<br>jsp.DMU64.m15j40c1<br>jsp.DMU65.m15j40c1<br>jsp.DMU66.m20j40c1<br>jsp.DMU67.m20j40c1<br>jsp.DMU68.m20j40c1<br>jsp.DMU69.m20j40c1<br>jsp.DMU70.m20j40c1<br>jsp.DMU71.m15j50c1<br>jsp.DMU72.m15j50c1<br>jsp.DMU73.m15j50c1<br>jsp.DMU74.m15j50c1<br>jsp.DMU75.m15j50c1<br>jsp.DMU76.m20j50c1<br>jsp.DMU77.m20j50c1<br>jsp.DMU78.m20j50c1<br>jsp.DMU79.m20j50c1<br>jsp.DMU80.m20j50c1<br>jsp.FT06.m6j6c1<br>jsp.FT10.m10j10c1<br>jsp.FT20.m5j20c1<br>jsp.LA01.m5j10c1<br>jsp.LA02.m5j10c1<br>jsp.LA03.m5j10c1<br>jsp.LA04.m5j10c1<br>jsp.LA05.m5j10c1<br>jsp.LA06.m5j15c1<br>jsp.LA07.m5j15c1<br>jsp.LA08.m5j15c1<br>jsp.LA09.m5j15c1<br>jsp.LA10.m5j15c1<br>jsp.LA11.m5j20c1<br>jsp.LA12.m5j20c1<br>jsp.LA13.m5j20c1<br>jsp.LA14.m5j20c1<br>jsp.LA15.m5j20c1<br>jsp.LA16.m10j10c1<br>jsp.LA17.m10j10c1<br>jsp.LA18.m10j10c1<br>jsp.LA19.m10j10c1<br>jsp.LA20.m10j10c1<br>jsp.LA21.m10j15c1<br>jsp.LA22.m10j15c1<br>jsp.LA23.m10j15c1<br>jsp.LA24.m10j15c1<br>jsp.LA25.m10j15c1<br>jsp.LA26.m10j20c1<br>jsp.LA27.m10j20c1<br>jsp.LA28.m10j20c1<br>jsp.LA29.m10j20c1<br>jsp.LA30.m10j20c1<br>jsp.LA31.m10j30c1<br>jsp.LA32.m10j30c1<br>jsp.LA33.m10j30c1<br>jsp.LA34.m10j30c1<br>jsp.LA35.m10j30c1<br>jsp.LA36.m15j15c1<br>jsp.LA37.m15j15c1<br>jsp.LA38.m15j15c1<br>jsp.LA39.m15j15c1<br>jsp.LA40.m15j15c1<br>jsp.ORB01.m10j10c1<br>jsp.ORB02.m10j10c1<br>jsp.ORB03.m10j10c1<br>jsp.ORB04.m10j10c1<br>jsp.ORB05.m10j10c1<br>jsp.ORB06.m10j10c1<br>jsp.ORB07.m10j10c1<br>jsp.ORB08.m10j10c1<br>jsp.ORB09.m10j10c1<br>jsp.ORB10.m10j10c1<br>jsp.SWV01.m10j20c1<br>jsp.SWV02.m10j20c1<br>jsp.SWV03.m10j20c1<br>jsp.SWV04.m10j20c1<br>jsp.SWV05.m10j20c1<br>jsp.SWV06.m15j20c1<br>jsp.SWV07.m15j20c1<br>jsp.SWV08.m15j20c1<br>jsp.SWV09.m15j20c1<br>jsp.SWV10.m15j20c1<br>jsp.SWV11.m10j50c1<br>jsp.SWV12.m10j50c1<br>jsp.SWV13.m10j50c1<br>jsp.SWV14.m10j50c1<br>jsp.SWV15.m10j50c1<br>jsp.SWV16.m10j50c1<br>jsp.SWV17.m10j50c1<br>jsp.SWV18.m10j50c1<br>jsp.SWV19.m10j50c1<br>jsp.SWV20.m10j50c1<br>jsp.TA01.m15j15c1<br>jsp.TA02.m15j15c1<br>jsp.TA03.m15j15c1<br>jsp.TA04.m15j15c1<br>jsp.TA05.m15j15c1<br>jsp.TA06.m15j15c1<br>jsp.TA07.m15j15c1<br>jsp.TA08.m15j15c1<br>jsp.TA09.m15j15c1<br>jsp.TA10.m15j15c1<br>jsp.TA11.m15j20c1<br>jsp.TA12.m15j20c1<br>jsp.TA13.m15j20c1<br>jsp.TA14.m15j20c1<br>jsp.TA15.m15j20c1<br>jsp.TA16.m15j20c1<br>jsp.TA17.m15j20c1<br>jsp.TA18.m15j20c1<br>jsp.TA19.m15j20c1<br>jsp.TA20.m15j20c1<br>jsp.TA21.m20j20c1<br>jsp.TA22.m20j20c1<br>jsp.TA23.m20j20c1<br>jsp.TA24.m20j20c1<br>jsp.TA25.m20j20c1<br>jsp.TA26.m20j20c1<br>jsp.TA27.m20j20c1<br>jsp.TA28.m20j20c1<br>jsp.TA29.m20j20c1<br>jsp.TA30.m20j20c1<br>jsp.TA31.m15j30c1<br>jsp.TA32.m15j30c1<br>jsp.TA33.m15j30c1<br>jsp.TA34.m15j30c1<br>jsp.TA35.m15j30c1<br>jsp.TA36.m15j30c1<br>jsp.TA37.m15j30c1<br>jsp.TA38.m15j30c1<br>jsp.TA39.m15j30c1<br>jsp.TA40.m15j30c1<br>jsp.TA41.m20j30c1<br>jsp.TA42.m20j30c1<br>jsp.TA43.m20j30c1<br>jsp.TA44.m20j30c1<br>jsp.TA45.m20j30c1<br>jsp.TA46.m20j30c1<br>jsp.TA47.m20j30c1<br>jsp.TA48.m20j30c1<br>jsp.TA49.m20j30c1<br>jsp.TA50.m20j30c1<br>jsp.TA51.m15j50c1<br>jsp.TA52.m15j50c1<br>jsp.TA53.m15j50c1<br>jsp.TA54.m15j50c1<br>jsp.TA55.m15j50c1<br>jsp.TA56.m15j50c1<br>jsp.TA57.m15j50c1<br>jsp.TA58.m15j50c1<br>jsp.TA59.m15j50c1<br>jsp.TA60.m15j50c1<br>jsp.TA61.m20j50c1<br>jsp.TA62.m20j50c1<br>jsp.TA63.m20j50c1<br>jsp.TA64.m20j50c1<br>jsp.TA65.m20j50c1<br>jsp.TA66.m20j50c1<br>jsp.TA67.m20j50c1<br>jsp.TA68.m20j50c1<br>jsp.TA69.m20j50c1<br>jsp.TA70.m20j50c1<br>jsp.TA71.m20j100c1<br>jsp.TA72.m20j100c1<br>jsp.TA73.m20j100c1<br>jsp.TA74.m20j100c1<br>jsp.TA75.m20j100c1<br>jsp.TA76.m20j100c1<br>jsp.TA77.m20j100c1<br>jsp.TA78.m20j100c1<br>jsp.TA79.m20j100c1<br>jsp.TA80.m20j100c1<br>jsp.YN01.m20j20c1<br>jsp.YN02.m20j20c1<br>jsp.YN03.m20j20c1<br>jsp.YN04.m20j20c1</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;柔性作业车间调度问题是智能制造与高性能计算等领域中的重要问题, 具有广泛应用场景. 柔性作业车间调度问题主要研究如何调度有限的资源依次执行多项任务, 使得完成所有任务的完工时间最短的问题. 比如芯片代工厂生产芯片时, 每块晶圆需要在不同机台依次完成光刻与蚀刻等多道工序. 比
      
    
    </summary>
    
      <category term="算法挑战" scheme="http://suzhouxing.github.io/techive/categories/%E7%AE%97%E6%B3%95%E6%8C%91%E6%88%98/"/>
    
    
      <category term="组合优化" scheme="http://suzhouxing.github.io/techive/tags/%E7%BB%84%E5%90%88%E4%BC%98%E5%8C%96/"/>
    
      <category term="算法挑战" scheme="http://suzhouxing.github.io/techive/tags/%E7%AE%97%E6%B3%95%E6%8C%91%E6%88%98/"/>
    
  </entry>
  
  <entry>
    <title>SmartLab Challenge 2020 - p-Center and Unicost Set Covering</title>
    <link href="http://suzhouxing.github.io/techive/2020/12/22/Contest-2020pCenter/"/>
    <id>http://suzhouxing.github.io/techive/2020/12/22/Contest-2020pCenter/</id>
    <published>2020-12-22T02:19:15.000Z</published>
    <updated>2021-09-29T12:22:03.544Z</updated>
    
    <content type="html"><![CDATA[<p>中心选址问题是通信与物流等领域中的重要问题, 其背后的单一成本集合覆盖问题更是用途广泛. 中心选址问题和单一成本集合覆盖问题主要研究如何使用有限的资源提供尽可能高质量的服务的问题. 例如, 移动基站, 消防站, 物流仓库, 数据中心等众多设施的选址都可以建模为中心选址问题. 高效的中心选址或单一成本集合覆盖问题的求解算法具有极其重要的理论与应用价值.</p><h1 id="中心选址与单一成本集合覆盖算法训练">中心选址与单一成本集合覆盖算法训练</h1><h2 id="问题概述">问题概述</h2><p>给定一系列节点, 从中选出若干节点作为中心为其他节点提供服务. 若一个节点由某个中心服务, 则认为其间存在一条服务边. 在确保每个节点至少由一个中心服务的前提下, 使最长的服务边最短.</p><p>若固定服务半径 (服务边的最大长度), 该问题等价于集合覆盖问题. 即给定一系列元素与若干子集, 请选择给定数量的子集, 使其并集等于所有元素的全集.</p><ul><li>参考文献.<ul><li>[1] Z. Su, Q. Zhang, Z. Lü, C.-M. Li, W. Lin, and F. Ma, “Weighting-based Variable Neighborhood Search for Optimal Camera Placement,” Proceedings of the AAAI Conference on Artificial Intelligence, vol. 35, no. 14, pp. 12400–12408, 2021.</li><li>[2] Q. Zhang, Z. Lü, Z. Su, C. Li, Y. Fang, and F. Ma, “Vertex Weighting-Based Tabu Search for p-Center Problem,” in Proceedings of the Twenty-Ninth International Joint Conference on Artificial Intelligence, IJCAI-20, 2020, pp. 1481–1487. doi: 10.24963/ijcai.2020/206.</li></ul></li></ul><h2 id="命令行参数">命令行参数</h2><p>请大家编写程序时支持两个命令行参数, 依次为运行时间上限 (单位为秒) 和随机种子 (0-65535). 算例文件已重定向至标准输入 <code>stdin</code>/<code>cin</code>, 标准输出 <code>stdout</code>/<code>cout</code> 已重定向至解文件 (如需打印调试信息, 请使用标准错误输出 <code>stderr</code>/<code>cerr</code>). 例如, 在控制台运行以下命令表示调用可执行文件 <code>pcenter.exe</code> 在限时 1000 秒, 随机种子为 12345 的情况下求解路径为 <code>../data/pmed1.n100p5.txt</code> 的算例, 解文件输出至 <code>sln.pmed1.n100p5.txt</code>: <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pcenter.exe 1000 123456 &lt;../data/pmed1.n100p5.txt &gt;sln.pmed1.n100p5.txt</span><br></pre></td></tr></table></figure></p><ul><li>运行时间上限.<ul><li>超出运行时间上限后测试程序会强行终止算法, 请确保在此之前已输出解 (最好还能自行正常退出).</li></ul></li><li>随机种子设置.<ul><li>使用 C 语言随机数生成器请用 <code>srand</code>.</li><li>使用 C++ 随机数生成器 (如 <code>mt19937</code>) 请在构造时传参或调用 <code>seed()</code> 方法设置.</li></ul></li></ul><h2 id="输入的算例文件格式">输入的算例文件格式</h2><p>所有算例均已根据给定覆盖半径转换为判定问题, 处理为一系列固定集合数的单一成本集合覆盖算例, 并附有逐步缩小半径时新增的无法覆盖的节点的信息. 转换后每个节点都可以覆盖若干节点, 同时也对称地被若干节点覆盖, 故转换后的单一成本集合覆盖算例中集合数等于元素数.</p><p>所有算例的元素和集合分别从 0 开始连续编号.</p><p>第一行给出两个由空白字符分隔的整数 N 和 P, 分别表示节点数和中心数 (从集合覆盖的角度来看, N 既是集合数又是元素数, P 为可挑选出的集合数).</p><p>接下来每两行一组, 连续 N 组给出每个集合的覆盖范围. 每组中第一行为该集合能覆盖的元素数量 C, 第二行为空白字符分隔的 C 个数字, 分别表示该集合能覆盖的元素的编号.</p><p>然后给出两个由空白字符分隔的整数 U 和 L, 分别表示覆盖半径边长序号的上界和下界 (其中上界即前面给出的判定问题对应的覆盖半径的边长序号, 下界为估计值).</p><p>接下来连续 U - L 行给出每缩小一次覆盖半径新增的无法覆盖的元素的信息 (若 U = L = 0, 说明前面给出的判定问题对应的覆盖半径已经为最优半径, 缩小半径后已不存在可行解). 每行第一个整数 K 表示本次缩小半径将导致 K 个元素不再被某个集合覆盖, 随后连续 K 个由空白字符分隔的整数 S 表示集合 S 将新增一个无法覆盖的元素 (同一个集合可能重复出现多次). 注意, 在前面给出的判定问题数据中, 每个集合可覆盖的元素已按从近到远的顺序排序, 即每次只用将集合 S 可覆盖元素列表末尾的一个元素删除即可.</p><p>例如, 以下算例文件表示集合和元素的数量均为 4, 要求挑选出 2 个集合覆盖所有元素; 其中,<br>集合 0 可以覆盖 2 个元素, 分别为元素 0 和 3;<br>集合 1 可以覆盖 2 个元素, 分别为元素 1 和 2;<br>集合 2 可以覆盖 3 个元素, 分别为元素 1, 2 和 3;<br>集合 3 可以覆盖 2 个元素, 分别为元素 0 和 2;<br>覆盖半径边长序号的上界为 5 下界为 3; 其中,<br>半径缩小为第 4 短的边时, 集合 2 无法再覆盖最远的元素 3, 集合 3 无法再覆盖最远的元素 2;<br>半径缩小为第 3 短的边时, 集合 1 无法再覆盖最远的元素 2, 集合 2 无法再覆盖最远的元素 1: <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">4 2</span><br><span class="line">2</span><br><span class="line">0 3</span><br><span class="line">2</span><br><span class="line">1 2</span><br><span class="line">3</span><br><span class="line">1 2 3</span><br><span class="line">2</span><br><span class="line">0 2</span><br><span class="line">5 3</span><br><span class="line">22 3</span><br><span class="line">21 2</span><br></pre></td></tr></table></figure></p><h2 id="输出的解文件格式">输出的解文件格式</h2><p>输出 P 个用空白字符 (建议使用换行符) 分隔的整数, 分别表示挑选出的 P 个中心 (集合).</p><p>例如, 以下解文件表示选择节点 0 和 2 作为中心 (集合): <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0</span><br><span class="line">2</span><br></pre></td></tr></table></figure></p><h2 id="提交要求">提交要求</h2><ul><li>发送至邮箱 <a href="mailto:szx@duhe.tech" target="_blank" rel="noopener">szx@duhe.tech</a>.</li><li>邮件标题格式为 "<strong>Challenge2020PCP-姓名-学校-专业</strong>".</li><li>邮件附件为单个压缩包 (文件大小 2M 以内), 文件名为 "<strong>姓名-学校-专业</strong>", 其内包含下列文件.<ul><li><strong>必要</strong> 算法的可执行文件 (Windows 平台).<ul><li>建议基于官方 SDK 开发 (<a href="https://gitee.com/suzhouxing/npbenchmark/tree/main/SDK.PCP" target="_blank" rel="noopener">https://gitee.com/suzhouxing/npbenchmark/tree/main/SDK.PCP</a>).</li><li>用 g++ 的同学编译时请静态链接, 即添加 <code>-static-libgcc -static-libstdc++</code> 编译选项.</li></ul></li><li><strong>必要</strong> 算法源码.<ul><li>可重入 (可在同一线程内反复调用而不会出现数据初始化错误或内存泄漏).</li><li>可并发 (可在同一进程内的多个线程同时运行多个算法求解实例而互不干扰, 满足此要求一般不能有全局的非只读变量).</li><li>可伸缩 (数据结构可以根据算例规模动态申请内存, 而非根据预先指定的编译期常量进行内存分配).</li></ul></li><li><strong>可选</strong> 算法在各算例上的运行情况概要, 至少包括以下几项信息 (可选, 仅在无法成功调用算法输出可通过检查程序的解时作为参考).<ul><li>算例名.</li><li>服务半径.</li><li>计算耗时.</li></ul></li><li><strong>可选</strong> 算法在各算例上求得的完全覆盖的解文件 (可选, 仅在无法成功调用算法输出可通过检查程序的解时作为参考).</li></ul></li><li>若成功提交, 在收到邮件时以及测试完成后系统均会自动发送邮件反馈提交情况.<ul><li>若测试结果较优, 可在排行榜页面看到自己的运行情况 (<a href="https://gitee.com/suzhouxing/npbenchmark/tree/data" target="_blank" rel="noopener">https://gitee.com/suzhouxing/npbenchmark/tree/data</a>).</li></ul></li></ul><p>例如: <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">苏宙行-华科-计科.zip</span><br><span class="line">|   pcenter.exe</span><br><span class="line">|   results.csv</span><br><span class="line">|</span><br><span class="line">+---src</span><br><span class="line">|       main.cpp</span><br><span class="line">|       algorithm.cpp</span><br><span class="line">|       algorithm.h</span><br><span class="line">|</span><br><span class="line">+---results</span><br><span class="line">        pmed1.n100p5.txt</span><br><span class="line">        pmed2.n100p10.txt</span><br><span class="line">        ...</span><br></pre></td></tr></table></figure></p><h2 id="算例清单">算例清单</h2><p>下载地址: <a href="https://gitee.com/suzhouxing/npbenchmark/tree/data/PCP/Instance" target="_blank" rel="noopener">https://gitee.com/suzhouxing/npbenchmark/tree/data/PCP/Instance</a></p><p>算例规模从小到大依次为 (求解难度不一定随规模增加, 但除 pcb3038* 以外的算例应该都很容易求解):</p><p>pmed01.n100p005<br>pmed02.n100p010<br>pmed03.n100p010<br>pmed04.n100p020<br>pmed05.n100p033<br>pmed06.n200p005<br>pmed07.n200p010<br>pmed08.n200p020<br>pmed09.n200p040<br>pmed10.n200p067<br>pmed11.n300p005<br>pmed12.n300p010<br>pmed13.n300p030<br>pmed14.n300p060<br>pmed15.n300p100<br>pmed16.n400p005<br>pmed17.n400p010<br>pmed18.n400p040<br>pmed19.n400p080<br>pmed20.n400p133<br>pmed21.n500p005<br>pmed22.n500p010<br>pmed23.n500p050<br>pmed24.n500p100<br>pmed25.n500p167<br>pmed26.n600p005<br>pmed27.n600p010<br>pmed28.n600p060<br>pmed29.n600p120<br>pmed30.n600p200<br>pmed31.n700p005<br>pmed32.n700p010<br>pmed33.n700p070<br>pmed34.n700p140<br>pmed35.n800p005<br>pmed36.n800p010<br>pmed37.n800p080<br>pmed38.n900p005<br>pmed39.n900p010<br>pmed40.n900p090<br>u1060p010<br>u1060p020<br>u1060p030<br>u1060p040<br>u1060p050<br>u1060p060<br>u1060p070<br>u1060p080<br>u1060p090<br>u1060p100<br>u1060p110<br>u1060p120<br>u1060p130<br>u1060p140<br>u1060p150<br>rl1323p010<br>rl1323p020<br>rl1323p030<br>rl1323p040<br>rl1323p050<br>rl1323p060<br>rl1323p070<br>rl1323p080<br>rl1323p090<br>rl1323p100<br>u1817p010<br>u1817p020<br>u1817p030<br>u1817p040<br>u1817p050<br>u1817p060<br>u1817p070<br>u1817p080<br>u1817p090<br>u1817p100<br>u1817p110<br>u1817p120<br>u1817p130<br>u1817p140<br>u1817p150<br>pcb3038p010r729<br>pcb3038p020r494<br>pcb3038p030r394<br>pcb3038p040r337<br>pcb3038p050r299<br>pcb3038p100r207<br>pcb3038p150r165<br>pcb3038p200r141<br>pcb3038p250r123<br>pcb3038p300r116<br>pcb3038p350r105<br>pcb3038p400r97<br>pcb3038p450r89<br>pcb3038p500r85</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;中心选址问题是通信与物流等领域中的重要问题, 其背后的单一成本集合覆盖问题更是用途广泛. 中心选址问题和单一成本集合覆盖问题主要研究如何使用有限的资源提供尽可能高质量的服务的问题. 例如, 移动基站, 消防站, 物流仓库, 数据中心等众多设施的选址都可以建模为中心选址问题.
      
    
    </summary>
    
      <category term="算法挑战" scheme="http://suzhouxing.github.io/techive/categories/%E7%AE%97%E6%B3%95%E6%8C%91%E6%88%98/"/>
    
    
      <category term="组合优化" scheme="http://suzhouxing.github.io/techive/tags/%E7%BB%84%E5%90%88%E4%BC%98%E5%8C%96/"/>
    
      <category term="算法挑战" scheme="http://suzhouxing.github.io/techive/tags/%E7%AE%97%E6%B3%95%E6%8C%91%E6%88%98/"/>
    
  </entry>
  
  <entry>
    <title>SmartLab Challenge 2020 - Graph Coloring</title>
    <link href="http://suzhouxing.github.io/techive/2020/12/09/Contest-2020GraphColoring/"/>
    <id>http://suzhouxing.github.io/techive/2020/12/09/Contest-2020GraphColoring/</id>
    <published>2020-12-09T02:28:35.000Z</published>
    <updated>2021-09-29T12:22:12.535Z</updated>
    
    <content type="html"><![CDATA[<p>图着色问题在众多领域中有广泛的应用, 可以用来对各种各样的组合优化问题进行建模. 图着色问题主要研究独占资源的分配问题. 比如在编译器给变量分配寄存器分配时, 如果两个变量的生命周期有交集, 则不能分配至同一寄存器. 比如在机场分配停机位时, 如果两架飞机的过站时间有交集, 则不能分配至同一停机位. 比如在光纤网络中进行波长分配时, 如果两条光路经过同一条链路, 则不能使用同一波长传输. 比如移动基站进行通讯频率分配时, 如果两个终端设备位于同一组天线的覆盖范围内, 则不能使用同一通讯频率. 比如在学校排课表时, 如果两个班级要上同一位教师的课, 则其上课时间不能相同. 高效的图着色问题求解算法具有极其重要的理论与应用价值.</p><h1 id="图着色算法训练">图着色算法训练</h1><h2 id="问题概述">问题概述</h2><p>给定一个无向图, 请为每个节点染一种颜色, 在任意一条无向边两端的节点颜色不同的情况下, 最小化使用的颜色数.</p><ul><li>参考文献.<ul><li>[1] Z. Lü and J.-K. Hao, “A memetic algorithm for graph coloring,” European Journal of Operational Research, vol. 203, no. 1, pp. 241–250, 2010, doi: 10.1016/j.ejor.2009.07.016.</li><li>[2] L. Moalic and A. Gondran, “Variations on memetic algorithms for graph coloring problems,” Journal of Heuristics, vol. 24, no. 1, pp. 1–24, 2018, doi: 10.1007/s10732-017-9354-9.</li></ul></li></ul><h2 id="命令行参数">命令行参数</h2><p>请大家编写程序时支持两个命令行参数, 依次为运行时间上限 (单位为秒) 和随机种子 (0-65535). 算例文件已重定向至标准输入 <code>stdin</code>/<code>cin</code>, 标准输出 <code>stdout</code>/<code>cout</code> 已重定向至解文件 (如需打印调试信息, 请使用标准错误输出 <code>stderr</code>/<code>cerr</code>). 例如, 在控制台运行以下命令表示调用可执行文件 <code>gcp.exe</code> 在限时 600 秒, 随机种子为 12345 的情况下求解路径为 <code>../data/DSJC500.5.txt</code> 的算例, 解文件输出至 <code>sln.dsjc500.5.txt</code>: <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcp.exe 600 123456 &lt;../data/DSJC500.5.txt &gt;sln.dsjc500.5.txt</span><br></pre></td></tr></table></figure></p><ul><li>运行时间上限.<ul><li>超出运行时间上限后测试程序会强行终止算法, 请确保在此之前已输出解 (最好还能自行正常退出).</li></ul></li><li>随机种子设置.<ul><li>使用 C 语言随机数生成器请用 <code>srand</code>.</li><li>使用 C++ 随机数生成器 (如 <code>mt19937</code>) 请在构造时传参或调用 <code>seed()</code> 方法设置.</li></ul></li></ul><h2 id="输入的算例文件格式">输入的算例文件格式</h2><p>所有算例的节点从 0 开始连续编号.</p><p>第一行给出三个由空白字符分隔的整数, 分别表示节点数 N, 无向边数 E (有向边数为 2E), 以及参考颜色数 C (相对容易求得可行解, 非最优颜色数). 接下来连续 E 行, 每行包含两个由空白字符分隔的整数, 表示一条无向边的两个端点.</p><p>例如, 以下算例文件表示节点数为 4, 无向边数为 3, 参考颜色数为 2; 其中:<br>节点 0 分别与 1, 2, 3 相邻. <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">4 3 2</span><br><span class="line">0 1</span><br><span class="line">0 2</span><br><span class="line">3 0</span><br></pre></td></tr></table></figure></p><h2 id="输出的解文件格式">输出的解文件格式</h2><p>输出 N 个用空白字符 (建议使用换行符) 分隔整数表示 N 个节点的染色情况, 第 i 个整数表示第 i 个节点的颜色.</p><p>颜色可以取 <code>int</code> 范围内任意非负整数, 检查程序自动统计不同的非负整数的数量.</p><p>例如, 以下解文件表示节点 0 染颜色 0, 节点 1 染颜色 1, 节点 2 染颜色 1, 节点 3 染颜色 1: <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0</span><br><span class="line">1</span><br><span class="line">1</span><br><span class="line">1</span><br></pre></td></tr></table></figure></p><h2 id="提交要求">提交要求</h2><ul><li>发送至邮箱 <a href="mailto:szx@duhe.tech" target="_blank" rel="noopener">szx@duhe.tech</a>.</li><li>邮件标题格式为 "<strong>Challenge2020GCP-姓名-学校-专业</strong>".</li><li>邮件附件为单个压缩包 (文件大小 2M 以内), 文件名为 "<strong>姓名-学校-专业</strong>", 其内包含下列文件.<ul><li><strong>必要</strong> 算法的可执行文件 (Windows 平台).<ul><li>建议基于官方 SDK 开发 (<a href="https://gitee.com/suzhouxing/npbenchmark/tree/main/SDK.GCP" target="_blank" rel="noopener">https://gitee.com/suzhouxing/npbenchmark/tree/main/SDK.GCP</a>).</li><li>用 g++ 的同学编译时建议静态链接, 即添加 <code>-static-libgcc -static-libstdc++</code> 编译选项.</li></ul></li><li><strong>必要</strong> 算法源码.<ul><li>可重入 (可在同一线程内反复调用而不会出现数据初始化错误或内存泄漏).</li><li>可并发 (可在同一进程内的多个线程同时运行多个算法求解实例而互不干扰, 满足此要求一般不能有全局的非只读变量).</li><li>可伸缩 (数据结构可以根据算例规模动态申请内存, 而非根据预先指定的编译期常量进行内存分配).</li></ul></li><li><strong>可选</strong> 算法在各算例上的运行情况概要, 至少包括以下几项信息 (可选, 仅在无法成功调用算法输出可通过检查程序的解时作为参考).<ul><li>算例名.</li><li>颜色数.</li><li>计算耗时.</li></ul></li><li><strong>可选</strong> 算法在各算例上求得的颜色数最少的解文件 (可选, 仅在无法成功调用算法输出可通过检查程序的解时作为参考).</li></ul></li><li>若成功提交, 在收到邮件时以及测试完成后系统均会自动发送邮件反馈提交情况.<ul><li>若测试结果较优, 可在排行榜页面看到自己的运行情况 (<a href="https://gitee.com/suzhouxing/npbenchmark/tree/data" target="_blank" rel="noopener">https://gitee.com/suzhouxing/npbenchmark/tree/data</a>).</li></ul></li></ul><p>例如: <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">苏宙行-华科-计科.zip</span><br><span class="line">|   gc.exe</span><br><span class="line">|   results.csv</span><br><span class="line">|</span><br><span class="line">+---src</span><br><span class="line">|       main.cpp</span><br><span class="line">|       algorithm.cpp</span><br><span class="line">|       algorithm.h</span><br><span class="line">|</span><br><span class="line">+---results</span><br><span class="line">        DSJC125.1.txt</span><br><span class="line">        DSJC125.5.txt</span><br><span class="line">        ...</span><br></pre></td></tr></table></figure></p><h2 id="算例清单">算例清单</h2><p>下载地址: <a href="https://gitee.com/suzhouxing/npbenchmark/tree/data/GCP/Instance" target="_blank" rel="noopener">https://gitee.com/suzhouxing/npbenchmark/tree/data/GCP/Instance</a></p><p>算例规模从小到大依次为 (求解难度不一定随规模增加, 但 DSJC500.5 以前的算例应该都很容易求解):</p><p>DSJC0125.1<br>DSJC0125.5<br>DSJC0125.9<br>DSJC0250.1<br>DSJC0250.5<br>DSJC0250.9<br>DSJC0500.1<br>DSJC0500.5<br>DSJC0500.9<br>DSJC1000.1<br>DSJC1000.5<br>DSJC1000.9</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;图着色问题在众多领域中有广泛的应用, 可以用来对各种各样的组合优化问题进行建模. 图着色问题主要研究独占资源的分配问题. 比如在编译器给变量分配寄存器分配时, 如果两个变量的生命周期有交集, 则不能分配至同一寄存器. 比如在机场分配停机位时, 如果两架飞机的过站时间有交集,
      
    
    </summary>
    
      <category term="算法挑战" scheme="http://suzhouxing.github.io/techive/categories/%E7%AE%97%E6%B3%95%E6%8C%91%E6%88%98/"/>
    
    
      <category term="组合优化" scheme="http://suzhouxing.github.io/techive/tags/%E7%BB%84%E5%90%88%E4%BC%98%E5%8C%96/"/>
    
      <category term="算法挑战" scheme="http://suzhouxing.github.io/techive/tags/%E7%AE%97%E6%B3%95%E6%8C%91%E6%88%98/"/>
    
  </entry>
  
  <entry>
    <title>用 Gitea 搭建自己的 Git 服务器</title>
    <link href="http://suzhouxing.github.io/techive/2019/10/17/SetupGitServerWithGitea/"/>
    <id>http://suzhouxing.github.io/techive/2019/10/17/SetupGitServerWithGitea/</id>
    <published>2019-10-17T06:18:36.000Z</published>
    <updated>2019-10-17T09:06:06.683Z</updated>
    
    <content type="html"><![CDATA[<p>在永恒之蓝等通过网络文件共享传播的病毒肆虐之后, 很多网络供应商都封禁了文件共享相关端口, 以至于无法简单地通过映射网络驱动器来搭建 Git 的远端仓库, 然后使用 "哑协议" 执行 clone, push, pull 等操作. 因此, 我们可能需要使用支持 http 或者 ssh 的 Git 服务器. 目前功能最强大的免费 Git 服务器为 <a href="https://about.gitlab.com/install/" target="_blank" rel="noopener">Gitlab</a>, 它可以让用户自己搭建与 https://github.com 或者 https://gitlab.com 一样的网站. 但 Gitlab 不支持免费用于商业用途. 此外, 同类开源或免费软件还有 <a href="https://bonobogitserver.com/" target="_blank" rel="noopener">Bonobo</a>, <a href="https://gogs.io/" target="_blank" rel="noopener">Gogs</a>, <a href="https://www.scm-manager.org/" target="_blank" rel="noopener">SCM-Manager</a>, <a href="http://gitblit.com/" target="_blank" rel="noopener">Gitblit</a> 等.</p><h1 id="windows-环境下操作步骤">Windows 环境下操作步骤</h1><h2 id="第三方库依赖">第三方库依赖</h2><ol type="1"><li>安装 Git<ol type="1"><li>在<a href="https://git-scm.com/" target="_blank" rel="noopener">官方网站</a>下载最新版安装包</li><li>双击运行安装包按照安装向导的提示点下一步即可</li></ol></li></ol><h2 id="基本流程">基本流程</h2><ol type="1"><li><p>在<a href="https://gitea.io" target="_blank" rel="noopener">官方网站</a>或者 <a href="https://github.com/go-gitea/gitea/releases" target="_blank" rel="noopener">Github 的 release 页面</a>下载最新版本</p><ul><li>截至本文发布时最新版本为 <code>gitea-1.9.4-windows-4.0-amd64.exe</code></li></ul></li><li><p>将下载的文件重命名为 <code>gitea.exe</code> 并移动至任意目录下 (本文后续将使用 <code>C:\YOUR\INSTALL\PATH</code> 作为安装目录, 读者请根据自己的情况将其替换为实际的路径)</p></li><li><p>以管理员身份打开命令行, 执行以下命令添加 Gitea 为 Windows 服务 <code>sc create gitea start= auto binPath= ""C:\YOUR\INSTALL\PATH\gitea.exe" web --config "C:\YOUR\INSTALL\PATH\custom\conf\app.ini""</code></p><ul><li>详情请见 https://docs.gitea.io/zh-cn/windows-service/</li><li>在 PowerShell 中执行上述命令可能会失败, 需要使用经典的 cmd</li><li>假设使用的管理员账号为 <code>admin</code>, 密码为 <code>123</code>, 后面其他地方要用时最好保持一致</li></ul></li><li><p>如果该服务未自动启动, 在 Windows 的服务列表中找到 <code>gitea</code> 并启动</p><ol type="1"><li>以管理员身份打开服务列表<ul><li>开始按钮上点右键 -&gt; 计算机管理 -&gt; 服务和应用程序 -&gt; 服务</li><li>Ctrl+Shift+Esc 打开任务管理器 -&gt; 服务 -&gt; 打开服务</li><li>控制面板 -&gt; 系统和安全 -&gt; 管理工具 -&gt; 服务</li></ul></li><li>建议在 <code>gitea</code> 服务上点右键 -&gt; 属性 -&gt; 登陆 -&gt; 此账户, 设置账户为之前使用的管理员账户 <code>admin</code>, 然后重启服务</li></ol></li><li><p>在浏览器中访问默认的地址 <code>http://localhost:3000</code> 打开网页端, 点击注册按钮</p><ol type="1"><li>第一次点击注册时将进入初始配置页面<ol type="1"><li>数据库推荐选择 SQLite3, 数据库路径建议使用默认的安装目录下的子目录</li><li><code>站点名称</code> 随便填</li><li><code>仓库根目录</code> 建议更改至安装目录下, 例如 <code>C:\YOUR\INSTALL\PATH\data\repo</code></li><li><code>以用户名运行</code> 建议使用上面用过的管理员账号 <code>admin</code></li><li>把 <code>SSH 服务域名</code> 和 <code>Gitea 基本 URL</code> 中的 <code>localhost</code> 替换为服务器的 IP 地址或域名</li><li>端口根据个人偏好设置, 设为 80 的话以后的仓库链接可以省略端口号, 但是有和其他 web 服务冲突的可能性, 建议使用默认端口</li><li>可选设置中的 <code>管理员账号设置</code> 为 Gitea 网页端的管理员, 不是操作系统的管理员, 如果此时不设置则第一个注册的用户将自动成为管理员</li></ol></li><li>再次点击注册, 完成用户注册</li></ol></li></ol><h2 id="疑难解答">疑难解答</h2><ol type="1"><li>更改配置<ol type="1"><li>在 <code>C:\YOUR\INSTALL\PATH\custom\conf\app.ini</code> 文件中修改相关项目<ul><li>网页端地址或者代码仓库地址前缀: <code>ROOT_URL</code>, <code>DOMAIN</code>, <code>SSH_DOMAIN</code></li><li>端口: <code>HTTP_PORT</code>, <code>SSH_PORT</code></li></ul></li><li>参考资料<ul><li>https://docs.gitea.io/zh-cn/customizing-gitea/</li><li>https://docs.gitea.io/zh-cn/config-cheat-sheet/</li><li>https://github.com/go-gitea/gitea/blob/master/custom/conf/app.ini.sample</li></ul></li></ol></li><li>局域网或者互联网上其他机器无法访问网页端<ol type="1"><li>添加防火墙放行规则<ol type="1"><li>控制面板 -&gt; 系统和安全 -&gt; Windows Defender 防火墙 -&gt; 允许应用或功能通过 Windows Defender 防火墙 -&gt; 更改设置 -&gt; 允许其他应用 -&gt; 浏览 -&gt; 选中 <code>C:\YOUR\INSTALL\PATH\gitea.exe</code> -&gt; 网络类型 -&gt; 确保公用和专用均被勾选</li></ol></li><li>更换端口</li><li>咨询单位网管或互联网服务提供商</li></ol></li><li>初始化设置时无法创建数据库<ol type="1"><li>设置 <code>gitea</code> 服务以管理员账号启动</li><li>安装 SQLite3<ol type="1"><li>从<a href="https://sqlite.org" target="_blank" rel="noopener">官方网站</a>下载 SQLite3<ul><li>截至本文发布时最新版本为 <code>sqlite-dll-win64-x64-3300100.zip</code></li></ul></li><li>将压缩包内的文件解压至任意目录下<ul><li>本文后续将使用 <code>C:\SQLITE3\INSTALL\PATH</code> 作为安装目录, 读者请根据自己的情况将其替换为实际的路径</li></ul></li></ol></li><li>在环境变量 <code>Path</code> 中添加安装目录<ol type="1"><li>控制面板 -&gt; 系统和安全 -&gt; 系统 -&gt; 高级系统设置 -&gt; 环境变量 -&gt; 系统变量 -&gt; 双击变量 <code>Path</code></li><li>新建一行 <code>C:\SQLITE3\INSTALL\PATH</code> 或者在变量值字符串开头添加 <code>C:\SQLITE3\INSTALL\PATH;</code></li></ol></li></ol></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在永恒之蓝等通过网络文件共享传播的病毒肆虐之后, 很多网络供应商都封禁了文件共享相关端口, 以至于无法简单地通过映射网络驱动器来搭建 Git 的远端仓库, 然后使用 &quot;哑协议&quot; 执行 clone, push, pull 等操作. 因此, 我们可能需要使用支持 http 或者
      
    
    </summary>
    
      <category term="技术" scheme="http://suzhouxing.github.io/techive/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="技术" scheme="http://suzhouxing.github.io/techive/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="Git" scheme="http://suzhouxing.github.io/techive/tags/Git/"/>
    
      <category term="Gitea" scheme="http://suzhouxing.github.io/techive/tags/Gitea/"/>
    
  </entry>
  
  <entry>
    <title>组合优化 (五) 数学规划进阶</title>
    <link href="http://suzhouxing.github.io/techive/2019/01/13/Opt-AdvancedMathematicalProgramming/"/>
    <id>http://suzhouxing.github.io/techive/2019/01/13/Opt-AdvancedMathematicalProgramming/</id>
    <published>2019-01-13T03:14:59.000Z</published>
    <updated>2019-10-22T06:06:32.205Z</updated>
    
    <content type="html"><![CDATA[<p>虽然目前最顶尖的商业求解器已经非常高效, 直接求解完整的问题模型往往比普通人自己实现算法性能更好, 但是面对特定的问题, 仍然有改进空间. 另一方面, 先贤们告诉我们要站在巨人的肩膀上, 要重用前人的优秀成果. 于是, 我们可以得到一个在完全自行设计算法和完全使用通用求解器之间的折中的方案, 发挥多种方法各自的优势, 更好地解决问题.</p><h1 id="线性规划与混合整数规划-进阶技巧">线性规划与混合整数规划 (进阶技巧)</h1><h2 id="非线性表达式">非线性表达式</h2><ul><li>可以转化为线性表达式的非线性表达式<ul><li>最大值最小值</li><li>绝对值</li><li>分段线性函数</li><li>...</li></ul></li><li>可以较高效求解的非线性表达式<ul><li>Quadratic Program (QP)</li><li>Special Ordered Set (SOS)</li><li>Mixed Integer Program (MIP)</li><li>...</li></ul></li></ul><p>详见 <a href="https://github.com/HUST-Smart/Training/blob/master/%5B1.5%5D%20%E7%BA%BF%E6%80%A7%E5%8C%96%E9%9D%9E%E7%BA%BF%E6%80%A7%E8%A1%A8%E8%BE%BE%E5%BC%8F.docx" target="_blank" rel="noopener">[1.5] 线性化非线性表达式.docx</a>.</p><h3 id="最小化最大值">最小化最大值</h3><ul><li>使用一个辅助变量限制决策变量的界</li><li>约束的可行区域应与优化方向 "相反"<ul><li>最小化一个表达式 <span class="math inline">\(l = f(x)\)</span>, 应该确定 <span class="math inline">\(l\)</span> 的下界, 即 <span class="math inline">\(g(x) \le l \le +\infty\)</span></li><li>最大化一个表达式 <span class="math inline">\(u = f(x)\)</span>, 如果只约束其下界, 将导致目标无限增大</li></ul></li></ul><h3 id="最小化最小值">最小化最小值</h3><ul><li>最小值的下界? 让较大的值都可以忽略</li><li>Big-M (充分大的 M)</li></ul><h3 id="课堂练习">课堂练习</h3><ul><li>最大化最大值?</li><li>最大化绝对值?</li></ul><h2 id="多目标">多目标</h2><ul><li>线性加权模式<ul><li>简单, 本质上就是单目标</li><li>各目标量纲不同时难以确定权重系数</li></ul></li><li>优先级模式<ul><li>高优先级对低优先级有压倒性优势</li><li>高优先级目标有一定的绝对/相对容差范围</li></ul></li></ul><h3 id="实现优先级模式">实现优先级模式</h3><ul><li>使用线性加权模式模拟<ul><li>难以确定各目标的取值范围以形成隔离</li><li>目标过多容易溢出或者产生巨大的数值误差</li></ul></li><li>迭代求解<ul><li>按优先级逐个优化</li><li>每个目标算到最优解后根据容差范围添加约束限制目标函数的取值</li><li>求解性能依赖热启动 (warm start) 效果</li></ul></li></ul><h2 id="约束类型">约束类型</h2><table><thead><tr class="header"><th>类型</th><th>特征</th><th>最优性</th><th>完整性</th><th>检查时间</th><th>被忽略</th></tr></thead><tbody><tr class="odd"><td>user cut</td><td>排除显然不可能最优的解向量</td><td>不改变最优解</td><td>不影响模型的完整性</td><td>可能在任意时刻被检查</td><td>可能</td></tr><tr class="even"><td>lazy constraint</td><td>最优解不太可能违反的约束</td><td>会改变最优解</td><td>影响模型的完整性</td><td>仅在找到解时才被检查</td><td>不会</td></tr><tr class="odd"><td>constraint</td><td>容易与优化目标产生冲突的约束</td><td>会改变最优解</td><td>影响模型的完整性</td><td>在任意时刻都会被检查</td><td>不会</td></tr></tbody></table><p>注: 在 MIP 中, 整数解才是原始问题的解, 故在找到松弛的实数解时不会触发惰性约束.</p><p>以下为 CPLEX 对惰性约束和用户割平面的介绍:</p><blockquote><p>In contrast to the cuts that IBM ILOG CPLEX may automatically add while solving a problem, user cuts are those cuts that a user defines based on information already implied about the problem by the constraints; user cuts may not be strictly necessary to the problem, but they tighten the model. Lazy constraints are constraints that the user knows are unlikely to be violated, and in consequence, the user wants them applied lazily, that is, only as necessary or not before needed. User cuts can be grouped together in a pool of user cuts. Likewise, lazy constraints can also be grouped into a pool of lazy constraints.</p><p>Cuts may resemble ordinary constraints, but are conventionally defined to mean those which can change the feasible space of the continuous relaxation but do not rule out any feasible integer solution that the rest of the model permits. A collection of cuts, therefore, involves an element of freedom: whether or not to apply them, individually or collectively, during the optimization of a MIP model; the formulation of the model remains correct whether or not the cuts are included. This degree of freedom means that if valid and necessary constraints are mis-identified by the user and passed to CPLEX as user cuts, unpredictable and possibly incorrect results could occur.</p><p>By contrast, lazy constraints represent simply one portion of the constraint set, and the model would be incomplete (and possibly would deliver incorrect answers) in their absence. CPLEX always makes sure that lazy constraints are satisfied before producing any solution to a MIP model. Needed lazy constraints are also kept in effect after the MIP optimization terminates, for example, when you change the problem type to fixed-integer and re-optimize with a continuous optimizer.</p><p>Another important difference between pools of user cuts and pools of lazy constraints lies in the timing by which these pools are applied. CPLEX may check user cuts for violation and apply them at any stage of the optimization. Conversely, it does not guarantee to check them at the time an integer-feasible solution candidate has been identified. Lazy constraints are only (and always) checked when an integer-feasible solution candidate has been identified, and of course, any of these constraints that turn out to be violated will then be applied to the full model.</p><p>Cuts that are based on <strong>optimality</strong> and that <strong>remove</strong> integer feasible solutions without removing all optimal solutions are known as <strong>optimality-based cuts</strong>. Optimality-based cuts do not fit the definition of either a user cut nor a lazy constraint. For example, <strong>symmetry-breaking constraints</strong> are sometimes known as optimality-based cuts because symmetry-breaking constraints can remove integer feasible solutions without removing all optimal solutions. Symmetry-breaking constraints are <strong>not</strong> user cuts in the sense addressed here. Symmetry-breaking constraints are not necessarily lazy constraints either. However, CPLEX can support optimality-based cuts as lazy constraints. If you add an optimality-based cut as a lazy constraint in your model, you can also add it to the user cut pool. This practice of adding an optimality-based cut as a lazy constraint and simultaneously adding it to the user cut pool makes sure that CPLEX checks the optimality-based cut at each node relaxation as well as when CPLEX finds an integer feasible solution.</p><p>Another way of comparing these two types of pools is to note that the user designates constraints as lazy in the strong hope and expectation that they will not need to be applied, thus saving computation time by their absence from the working problem. In practice, it is relatively costly (for a variety of reasons) to apply a lazy constraint after a violation is identified, and so the user should err on the side of caution when deciding whether a constraint should be marked as lazy. In contrast, user cuts may be more liberally added to a model because CPLEX is not obligated to use any of them and can apply its own rules to govern their efficient use.</p></blockquote><p>user cut 与约束编程 (Constraint Programming) 中的 surrogate constraints 功能类似:</p><blockquote><p>Since constraint propagation decreases the size of the search space by reducing the domains of variables, it is obviously important to express all necessary constraints. In some cases, it is even a good idea to introduce implicit constraints to reduce the size of the search space by supplementary propagation. Processing supplementary constraints inevitably slows down execution. However, this slowing down may be negligible in certain problems when it is compared with the efficiency gained from reducing the size of the search space.</p><p>A surrogate constraint makes explicit a property that satisfies a solution implicitly. Such a constraint should not change the nature of the solution, but its propagation should delimit the general shape of the solution more quickly. Of course, there is no need to express grossly obvious redundant constraints since the highly optimized algorithms that CP Optimizer uses to insure arc consistency already work well enough. For example, given this system of equations: <span class="math inline">\(x = y + z\)</span> <span class="math inline">\(z = a + b\)</span> no efficiency whatsoever is gained by adding this constraint: <span class="math inline">\(x = y + a + b\)</span> However, in any case where an implicit property makes good sense, or derives from experience, or satisfies formal computations, its explicit implementation as a surrogate constraint can be beneficial.</p><p>Consider the problem of the magic sequence. Assume that there are n+1 unknowns, namely, <span class="math inline">\(x_0, x_1, . . . , x_n\)</span>. These <span class="math inline">\(x_i\)</span> must respect the following constraints: 0 appears <span class="math inline">\(x_0\)</span> times in the solution. 1 appears <span class="math inline">\(x_1\)</span> times. In general, <span class="math inline">\(i\)</span> appears <span class="math inline">\(x_i\)</span> times. <span class="math inline">\(n\)</span> appears <span class="math inline">\(x_n\)</span> times. The constraint of this problem can easily be written, using the specialized distribute constraint. However, the search for a solution can be greatly accelerated by introducing the following surrogate constraint that expresses the fact that <span class="math inline">\(n+1\)</span> numbers are counted. <span class="math inline">\(1*x_1 + 2*x_2 + . . . + n*x_n = n+1\)</span>.</p></blockquote><h2 id="列生成-column-generation">列生成 (Column Generation)</h2><p>如果说 TSP 中经典的子回路消除 (割平面法) 是一种逐步添加惰性约束的 "行生成" 算法, 那么其对偶算法就是逐步添加决策变量的 "列生成" 算法. 前者适用于原始问题约束非常多, 但是真正对限制最优解的取值发挥作用的重要约束很少的情况; 后者则恰好相反, 适用于决策变量非常多, 但大多数决策变量的子集的取值组合不可能出现在最优解中的情况.</p><h3 id="原理">原理</h3><p>给定主问题及其对偶问题的线性规划模型 <span class="math display">\[\begin{align}\min &amp;  &amp; \mathbf{c}^{T} \mathbf{x}            &amp; &amp;                 &amp; &amp; \max &amp;  &amp; \mathbf{y}^{T} \mathbf{b}\\s.t. &amp;  &amp; \mathbf{A} \mathbf{x} \ge \mathbf{b} &amp; &amp; \Leftrightarrow &amp; &amp; s.t. &amp;  &amp; \mathbf{y}^{T} \mathbf{A} \le \mathbf{c}^{T}\\     &amp;  &amp; \mathbf{x} \ge \mathbf{0}            &amp; &amp;                 &amp; &amp;      &amp;  &amp; \mathbf{y} \ge \mathbf{0}\end{align}\]</span></p><p>令 <span class="math inline">\(\mathbf{x}^{T} = [\mathbf{x}^{T}_{B}, \mathbf{x}^{T}_{N}]\)</span>, 其中 <span class="math inline">\(\mathbf{x}_{B}\)</span> 表示基向量, <span class="math inline">\(\mathbf{x}_{N}\)</span> 表示非基变量. 对应地, <span class="math inline">\(\mathbf{A} = [\mathbf{B}, \mathbf{N}]\)</span>, <span class="math inline">\(\mathbf{c} = [\mathbf{c}_{B}, \mathbf{c}_{N}]\)</span>.</p><p>对约束进行如下等价变换 <span class="math display">\[\mathbf{A} \mathbf{x} \ge \mathbf{b} ~~\Leftrightarrow~~ \mathbf{B} \mathbf{x}_{B} + \mathbf{N} \mathbf{x}_{N} \ge \mathbf{b} ~~\Leftrightarrow~~ \mathbf{x}_{B} \ge \mathbf{B}^{-1} \mathbf{b} - \mathbf{B}^{-1} \mathbf{N} \mathbf{x}_{N}\]</span></p><p>将上式代入目标函数 <span class="math display">\[\mathbf{c}^{T} \mathbf{x} ~~=~~ \mathbf{c}^{T}_{B} \mathbf{x}_{B} + \mathbf{c}^{T}_{N} \mathbf{x}_{N} ~~\ge~~ \mathbf{c}^{T}_{B} (\mathbf{B}^{-1} \mathbf{b} - \mathbf{B}^{-1} \mathbf{N} \mathbf{x}_{N}) + \mathbf{c}^{T}_{N} \mathbf{x}_{N} ~~=~~ \mathbf{c}^{T}_{B} \mathbf{B}^{-1} \mathbf{b} + (\mathbf{c}^{T}_{N} - \mathbf{c}^{T}_{B} \mathbf{B}^{-1} \mathbf{N}) \mathbf{x}_{N}\]</span></p><p>定义目标函数中非基变量的系数 Reduced Cost 为 <span class="math display">\[\mathbf{r} = \mathbf{c}^{T}_{N} - \mathbf{c}^{T}_{B} \mathbf{B}^{-1} \mathbf{N}\]</span></p><p>若 <span class="math inline">\(\exist \mathbf{N}_{i} \in \mathbf{N}\)</span> 满足 <span class="math inline">\(\mathbf{r}_{i} &lt; 0\)</span>, 则可通过增加非基变量 <span class="math inline">\(\mathbf{x}_{i}\)</span> 的值实现降低目标函数值. 若不存在这样的项, 即 <span class="math inline">\(\forall \mathbf{N}_{i} \in \mathbf{N}, \mathbf{c}^{T}_{i} - \mathbf{c}^{T}_{B} \mathbf{B}^{-1} \mathbf{N}_{i} \ge 0\)</span>, 则 <span class="math inline">\([\mathbf{x}_{B}, \mathbf{0}]\)</span> 为最优解.</p><p>由 Complementary Slackness 定理可知 <span class="math inline">\(\mathbf{y}^{T} = \mathbf{c}^{T}_{B} \mathbf{B}^{-1}\)</span>, 由此可得 <span class="math inline">\(\mathbf{r} = \mathbf{c}^{T}_{N} - \mathbf{y}^{T} \mathbf{N}\)</span>. 则寻找可最大程度改进当前解的非基变量的子问题目标函数为 <span class="math inline">\(\min \mathbf{c}^{T}_{N} - \mathbf{y}^{T} \mathbf{N}\)</span>.</p><p><span class="math inline">\(~~~~\)</span></p><p><em>(本节内容基于 https://zhuanlan.zhihu.com/p/55424545 整理)</em></p><blockquote><p>附: Complementary Slackness 定理证明过程 (可能有问题): 令 <span class="math inline">\(\mathbf{y}^{T} = \mathbf{c}^{T}_{B} \mathbf{B}^{-1}\)</span>, 对于限制主问题的最优解 <span class="math inline">\(\mathbf{x}\)</span>, 有 <span class="math inline">\(\mathbf{x}_{N} = \mathbf{0}\)</span>, 以及 <span class="math inline">\(\mathbf{c}^{T}_{B} \mathbf{B}^{-1} \mathbf{N} \le \mathbf{c}^{T}_{N}\)</span>, 可得 <span class="math display">\[\mathbf{y}^{T} \mathbf{A} ~~=~~ \mathbf{c}^{T}_{B} \mathbf{B}^{-1} \mathbf{A} ~~=~~ \mathbf{c}^{T}_{B} \mathbf{B}^{-1} [\mathbf{B}, \mathbf{N}] ~~=~~ [\mathbf{c}^{T}_{B}, \mathbf{c}^{T}_{B} \mathbf{B}^{-1} \mathbf{N}] ~~\le~~ [\mathbf{c}^{T}_{B}, \mathbf{c}^{T}_{N}] ~~=~~ \mathbf{c}^{T}\]</span> <span class="math display">\[\mathbf{y}^{T} \mathbf{b} ~~=~~ \mathbf{c}^{T}_{B} \mathbf{B}^{-1} \mathbf{b} ~~=~~ \mathbf{c}^{T}_{B} \mathbf{x}_{B} ~~=~~ \mathbf{c}^{T} \mathbf{x}\]</span> 即 <span class="math inline">\(\mathbf{y}^{T}\)</span> 为限制对偶问题的最优解.</p></blockquote><h2 id="线性分数规划-linear-fractional-programming">线性分数规划 (Linear-Fractional Programming)</h2><p>目标函数为分数形式. 可以转换成线性规划.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;虽然目前最顶尖的商业求解器已经非常高效, 直接求解完整的问题模型往往比普通人自己实现算法性能更好, 但是面对特定的问题, 仍然有改进空间. 另一方面, 先贤们告诉我们要站在巨人的肩膀上, 要重用前人的优秀成果. 于是, 我们可以得到一个在完全自行设计算法和完全使用通用求解器
      
    
    </summary>
    
      <category term="技术" scheme="http://suzhouxing.github.io/techive/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="技术" scheme="http://suzhouxing.github.io/techive/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="建模" scheme="http://suzhouxing.github.io/techive/tags/%E5%BB%BA%E6%A8%A1/"/>
    
      <category term="优化" scheme="http://suzhouxing.github.io/techive/tags/%E4%BC%98%E5%8C%96/"/>
    
      <category term="数学" scheme="http://suzhouxing.github.io/techive/tags/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>组合优化 (四) 算法工程</title>
    <link href="http://suzhouxing.github.io/techive/2019/01/13/Opt-SoftwareEngineering/"/>
    <id>http://suzhouxing.github.io/techive/2019/01/13/Opt-SoftwareEngineering/</id>
    <published>2019-01-13T03:14:16.000Z</published>
    <updated>2019-10-22T06:07:46.645Z</updated>
    
    <content type="html"><![CDATA[<p>算法研发和常规软件开发十分相似, 但也有很多区别. 大多数工程项目往往更注重正确性, 为了提升代码的健壮性与可维护性, 可以适当牺牲性能. 而设计精妙的高效而复杂算法代码往往具有极高的耦合度, 难以进行系统的单元测试. 此外, 算法面临的需求往往不那么简单直接, 不是梳理清楚了业务逻辑就能欢快地敲代码了的. 算法研发真的这么任性吗?</p><h1 id="软件工程">软件工程</h1><h2 id="文档">文档</h2><ul><li>需求分析<ul><li>相关技术调研</li><li>自然语言描述</li><li>基本概念定义</li><li>建模四要素</li><li>输入输出数据约定</li></ul></li><li>用户手册<ul><li>概要设计</li><li>接口定义</li><li>功能覆盖</li></ul></li><li>算法设计<ul><li>技术规范</li><li>模块划分</li><li>处理流程</li></ul></li><li>测试分析<ul><li>测试环境</li><li>测试用例</li><li>测试结果</li><li>正确性分析</li><li>优度分析</li><li>速度分析</li></ul></li></ul><h2 id="算例设计">算例设计</h2><ul><li>格式要求<ul><li>自文档</li><li>跨平台</li><li>推荐格式: protobuf, json</li></ul></li><li>结构和规模可控<ul><li>拓扑设计<ul><li>特殊结构: 树形, 窄总线型, 宽总线型, 关键节点, 局部密度高整体密度低, 有向无环图</li><li>部分边权重特别大 (出现整数上溢)</li></ul></li></ul></li></ul><h1 id="算法工程">算法工程</h1><h2 id="相关工具">相关工具</h2><h3 id="版本控制工具">版本控制工具</h3><ul><li>git (主流)</li><li>svn</li><li>mercurial</li></ul><h3 id="适合与版本控制工具配合使用的文档撰写工具">适合与版本控制工具配合使用的文档撰写工具</h3><ul><li>Markdown<ul><li>一种功能非常精简的标记语言</li><li>https://guides.github.com/features/mastering-markdown/</li></ul></li><li>LaTeX<ul><li>功能强大的标记语言</li><li>同样适用于科技论文写作</li></ul></li></ul><h3 id="数学规划求解器----完成需求分析即完成项目">数学规划求解器 -- 完成需求分析即完成项目!</h3><ul><li><a href="http://www.gurobi.com/" target="_blank" rel="noopener">Gurobi</a><ul><li>目前最高效的求解器</li><li>支持免费学术许可证申请</li></ul></li><li><a href="https://www.ibm.com/software/commerce/optimization/cplex-optimizer/" target="_blank" rel="noopener">CPLEX</a><ul><li>IBM旗下的"行业标准"</li></ul></li><li><a href="http://scip.zib.de/" target="_blank" rel="noopener">SCIP</a><ul><li>号称最快的开源求解器</li></ul></li><li><a href="https://projects.coin-or.org/Cbc" target="_blank" rel="noopener">Coin-OR</a><ul><li>功能繁多的开源运筹学工具包</li></ul></li></ul><h2 id="开发">开发</h2><h3 id="代码可读性">代码可读性</h3><ul><li>使用版本控制减少被注释掉的代码 (文档性注释不受该要求影响)</li><li>使用有具体意义的单词作为标识符以减少臃肿的注释</li><li>使用自动排版工具调整代码格式</li><li>合理的功能模块划分和封装以避免过长的函数 (但是有时真的无法避免)</li></ul><h3 id="自动化测试">自动化测试</h3><ul><li>使用配置文件<ul><li>方案选择 (使用配置文件将导致代码过于臃肿时可以考虑预处理语句)</li><li>参数设置</li><li>算例选择</li><li>建议使用json文件格式</li></ul></li><li>自动批量测试<ul><li>计算结果合法性检验</li><li>计算结果目标函数值正确性检验</li><li>独立重复运行</li><li>多个算例</li><li>多个配置</li><li>多线程 (注意写同一个日志文件时应加入互斥机制)</li></ul></li><li>运行日志<ul><li>原始日志<ul><li>能够评价每次运行的时空开销与解的质量</li><li>能够还原求解过程和结果 (随机种子, 运行时间, 迭代次数, 宏开关状态, 参数设置...)</li><li>建议使用csv文件进行组织</li></ul></li><li>初步加工<ul><li>多阶段问题整合各阶段的数据得到整个周期的结果</li></ul></li><li>举例 <img src="RawLog.png" alt="Log"></li></ul></li><li>结果分析<ul><li>初步统计<ul><li>极值, 均值, 方差, 耗时...</li><li>ClosedXML编辑xlsx文件</li></ul></li><li>对比分析<ul><li>在所有算例上的综合评价方案/参数好坏的策略</li><li>Excel条件格式, 排序, Excel录制宏</li></ul></li><li>举例 <img src="Statistics.png" alt="Analysis"></li></ul></li></ul><h3 id="算法工程模块清单">算法工程模块清单</h3><ul><li>通用<ul><li>验证程序<ul><li>合法性</li><li>目标函数值计算正确</li></ul></li><li>日志记录</li><li>统计分析</li></ul></li><li>求解器<ul><li>数学模型</li><li>编程实现</li></ul></li><li>启发式<ul><li>初始解<ul><li>随机</li><li>贪心</li></ul></li><li>局部搜索<ul><li>邻域评估<ul><li>增量评估</li><li>邻域动作目标函数增量缓存</li><li>邻域动作优先队列</li></ul></li><li>邻域动作选择</li><li>邻域动作执行</li></ul></li><li>禁忌策略<ul><li>禁忌表</li><li>解禁策略</li></ul></li><li>扰动策略</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;算法研发和常规软件开发十分相似, 但也有很多区别. 大多数工程项目往往更注重正确性, 为了提升代码的健壮性与可维护性, 可以适当牺牲性能. 而设计精妙的高效而复杂算法代码往往具有极高的耦合度, 难以进行系统的单元测试. 此外, 算法面临的需求往往不那么简单直接, 不是梳理清
      
    
    </summary>
    
      <category term="技术" scheme="http://suzhouxing.github.io/techive/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="技术" scheme="http://suzhouxing.github.io/techive/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="软件工程" scheme="http://suzhouxing.github.io/techive/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>组合优化 (三) 算法简介</title>
    <link href="http://suzhouxing.github.io/techive/2019/01/13/Opt-AlgorithmDesign/"/>
    <id>http://suzhouxing.github.io/techive/2019/01/13/Opt-AlgorithmDesign/</id>
    <published>2019-01-13T03:13:02.000Z</published>
    <updated>2021-09-14T09:21:17.554Z</updated>
    
    <content type="html"><![CDATA[<p>由于生产实践中面临的绝大多数具有实际意义的组合优化问题都已经在理论上被证明属于难以使用可接受的计算资源在可接受的时间内求解的 NP-Hard 问题, 其求解算法不像 P 问题一样存在标准答案. 此外, 在实际的工业应用中, 由于未来的不确定性以及评价指标常常无法完美量化等问题, 耗费大量计算资源和时间精确求出最优解几乎没有实际意义. 所以, 组合优化算法的设计往往是在优度与速度之间寻找平衡点.</p><h1 id="算法设计">算法设计</h1><h2 id="预处理-preprocess">预处理 (Preprocess)</h2><ul><li>缩减问题规模 (Reduction)<ul><li>参考文献: <a href="https://doi.org/10.1145/990308.990309" target="_blank" rel="noopener">Polynomial-time data reduction for dominating set</a></li></ul></li><li>加载用户参数与算法默认参数</li><li>初始化辅助数据结构</li></ul><h2 id="精确算法-exact-algorithms">精确算法 (Exact Algorithms)</h2><ul><li>分支限界 (Branch and Bound)<ul><li>分支策略 (Branching)<ul><li>深度优先 (Depth-First Search)</li><li>广度优先 (Breadth-First Search)</li><li>优度优先 (Best-First Search)</li></ul></li><li>剪枝策略 (Pruning)<ul><li>可行性剪枝 (Feasibility Pruning)</li><li>上下界剪枝 (Bound Pruning)<ul><li>(最小化问题) 当前目标函数值 + 剩余部分下界 &lt; 上界</li><li>A* 算法实质上是该策略在特定问题上的一种高效实现</li></ul></li><li>支配性剪枝 (Dominance Pruning)<ul><li>动态规划实质上是将该策略发挥到了极致</li></ul></li><li>参考文献: <a href="https://doi.org/10.1016/j.cor.2012.07.008" target="_blank" rel="noopener">On an exact method for the constrained shortest path problem</a></li></ul></li></ul></li><li>线性规划与混合整数规划求解算法 (Mathematical Programming)<ul><li>单纯形法 (Simplex Method)</li><li>内点法 (Interior Point Method, Barrier Method)</li><li>分支切割/割平面法 (Branch and Cut, Cutting Plane Method)</li><li>分支定价/列生成 (Branch and Price, Column Generation)</li></ul></li><li>动态规划 (Dynamic Programming)<ul><li>递推函数 (Recursive Formulation)</li><li>重叠子问题/最优子结构 (Overlapping Subproblem, Optimal Substructure)</li></ul></li><li>其他经典算法<ul><li>最大流 (Maximum Flow)</li><li>最小费用流 (Minimum-Cost Flow)</li><li>完美匹配/最大匹配 (Perfect Matching, Maximum Matching, Assignment Problem)</li></ul></li><li>参考文献<ul><li>http://theory.stanford.edu/~amitp/GameProgramming/</li><li>https://www.redblobgames.com/pathfinding/a-star/introduction.html</li><li>https://www.redblobgames.com/pathfinding/a-star/implementation.html</li></ul></li></ul><h2 id="元启发式算法-metaheuristics">元启发式算法 (Metaheuristics)</h2><h3 id="概述">概述</h3><ul><li>分类<br><img src="MetaheuristicsClassification.png" alt="Classification"></li><li>基本思想<ul><li>在 系统地探索整个解空间 和 盲目地探索邻近的解空间 之间寻找平衡点</li><li>集中性 (Intensification) 与 疏散性 (Diversification) 的平衡<ul><li>也称为 探索 (Exploration) 与 利用 (Exploitation) 的平衡</li></ul></li><li>时空开销 (Complexity) 与 求解质量 (Quality) 的平衡</li></ul></li><li>邻域动作 (Neighborhood Move): 尝试对解向量做微小的改变<ul><li>在一次迭代中每一个决策变量都可以改变: 精确算法</li><li>在一次迭代中仅改变一个决策变量: 原子邻域动作</li><li>寻找两者的平衡点: 集中性与疏散性的平衡</li></ul></li><li>迭代禁忌搜索过程<br><img src="TS.png" alt="TS"><ul><li>使用贪心算法或随机生成一个初始解</li><li>每次从当前解移动到某个邻居解 (Neighboring Solution), 直至一定步数不能改进</li><li>然后进行扰动, 贪心或随机地对更改部分解向量, 重复上述过程</li></ul></li><li>元启发式算法框架<br><img src="Framework.png" alt="Framework"><ul><li>算法层为整个程序的框架, 比如迭代局部搜索, 遗传算法, 混合进化算法等. 算法层决定了使用那些搜索策略, 搜索策略之间以什么次序出现, 各搜索策略的初始解, 各搜索策略的停止策略参数控制 (停止条件), 整个算法的停止条件等.</li><li>搜索层是具体的搜索算法, 执行一次搜索会产生一条搜索路径 (Trajectory). 随机游走, 模拟退火, 局部搜索, 禁忌搜索等都是搜索层的组件. 从广义上来说, 构造初始解, 迭代局部搜索中的扰动过程, 遗传算法中的交叉算子都是搜索层的组件. 在搜索过程中, 要考虑的主要问题是每次迭代选择什么邻域结构进行探索, 以及决定停止搜索的策略. 比如TS的停止策略是一定步数未改进就停止, 而停止条件是一个特定的最大未改进步数具体取值.</li><li>邻域动作选择一般是搜索过程中对算法性能影响最大的模块. 它通过循环调用邻域动作评估层的组件对考虑范围之内的邻域动作对目标函数值的改变情况进行评估, 然后按照某种策略挑选其中的一个动作. 最常见的挑选策略有 首次改进 (First Improvement) 和 最优改进 (Best Improvement). 此外, 还可以有导向性地或者随机地在整个邻域中挑选一部分邻域动作进行评估.</li><li>邻域动作评估可以是结合特殊的数据结构进行增量评估或者全部重算. 在绝大多数情况下增量评估的速度会远快于全部重算.</li><li>邻域动作的执行比较简单, 主要有更新解向量, 更新辅助数据结构, 更新禁忌表, 更新缓存和更新历史最优解等操作. 其中更新历史最优主要是处理目标函数值相同的情况, 可以随机选择, 也可以设计辅助目标函数进行处理.</li></ul></li><li>邻域动作举例<ul><li>Boolean Satisfiability Problem (SAT)</li><li>Graph Coloring Problem</li><li>P-Center Problem</li><li>Personnel Scheduling Prblem</li><li>Traveling Salesman Problem</li></ul></li><li>常用算法<ul><li>提升算法 (Trajectory-Based Methods)<ul><li>迭代禁忌搜索</li><li>模拟退火 (类似 Epsilon-Greedy 策略)</li><li>拍卖算法/地貌调整/格局检测 (Auction Algorithm, Landscape Adjustment, Configuration Checking)<ul><li>提升反复出现的惩罚项在目标函数中的权重实现 "软" 禁忌<ul><li>例如图着色中令 反复出现的 或者 局部最优解中的 冲突边的计 1.01 条冲突边</li></ul></li></ul></li></ul></li><li>种群算法 (Population-Based Methods)<ul><li>混合进化算法/模因算法 (Hybrid Evolutionary Algorithm, Memetic Algorithm), 遗传算法 (Genetic Algorithm)</li><li>蚁群, 蜂群, 粒子群 (与强化学习十分相似)</li></ul></li></ul></li></ul><h3 id="初始解-initial-solution-generation">初始解 (Initial Solution Generation)</h3><ul><li>贪心 (Greedy)<ul><li>有利于快速收敛 (Fast Convergence)</li><li>不利于初始解的多样性</li></ul></li><li>随机 (Random)</li></ul><h3 id="禁忌搜索-tabu-search">禁忌搜索 (Tabu Search)</h3><ul><li>邻域结构 (Neighborhood Structure) 设计<ul><li>原子邻域动作<ul><li>添加, 删除, 更换, 交换, 移动, ...</li></ul></li><li>复合邻域动作<ul><li>块交换, 块移动</li><li>大邻域搜索 (Large Neighborhood Search)</li><li>弹射链 (Ejection Chain)</li></ul></li></ul></li><li>邻域评估 (Neighborhood Evaluation): 目标函数值改进量计算<ul><li>增量评估 (Incremental Evaluation): 因为仅对解向量做了微小的改变, 所以目标函数中大多数项目并未改变</li><li>邻域缓存 (Cache): 在邻域动作执行后, 大多数邻域动作与被改变的决策变量并不相关, 其增量无需重新计算, 故可以将其缓存起来<ul><li>主动更新 (Active Update): 每次执行邻域动作后更新所有相关动作的增量</li><li>惰性更新 (Lazy Update): 使用标记位记录缓存是否失效, 需要比较相关动作的增量时再更新<ul><li>启用了邻域精简或抽样策略时才有惰性更新的必要</li></ul></li></ul></li></ul></li><li>邻域动作选择策略<ul><li>单个邻域 (直接选择邻域动作)<ul><li>首次改进 (First Improvement)<ul><li>记录上一轮的评估进度直接从下一个动作开始, 循环评估所有动作</li><li>每次从随机位置开始依次评估所有邻域动作</li></ul></li><li>最大改进 (Best Improvement)<ul><li>多个目标函数增量相同的最优动作随机选择一个<ul><li>在线选择 (Online Selection): <a href="https://en.wikipedia.org/wiki/Reservoir_sampling" target="_blank" rel="noopener">水塘抽样 (Reservoir Sampling)</a></li></ul></li></ul></li><li>邻域精简/候选动作集 (Neiborhood Reduction, Candidate Set)<ul><li>根据特定策略筛选排除显然没有改进潜力的动作</li></ul></li><li>邻域近似评估 (Neihborhood Estimation, Approximate Evaluation)<ul><li>根据其他辅助指标快速对所有动作排序, 仅对排名靠前的若干动作进行精确评估</li></ul></li><li>邻域抽样 (Neighborhood Sampling)</li></ul></li><li>多邻域 (先选出邻域结构再选择动作)<ul><li>评估所有邻域的所有动作<ul><li>可以结合邻域抽样随机挑选部分动作</li></ul></li><li>变邻域搜索 (Variable Neighborhood Search)</li><li>根据适应性选择最合适的邻域<ul><li>根据历史改进情况调整各邻域权重, 然后采用轮盘赌 (Roulette Wheel) 选择其中一个</li></ul></li><li>等概率随机选择</li></ul></li><li>优先队列优化: 避免遍历整个邻域, 直接在 O(1) 时间内挑选最优动作<ul><li>一般使用桶队列 (Bucket Queue) 等基于基数排序 (Radix Sort) 的优先队列实现 (而非基于比较的树状优先队列)</li><li>往往与邻域缓存结合使用, 实现惰性更新优先队列中的键值对</li></ul></li></ul></li><li>禁忌策略<ul><li>禁忌表<ul><li>如果一个邻域动作被执行则禁止其<strong>逆操作</strong>在短时间内被选中<ul><li>刚增加则禁止马上被删除</li><li>刚交换防止马上被换回来</li></ul></li></ul></li><li>禁忌步长 (Tabu Tenure)<ul><li>可能与问题规模, 禁忌表大小, 目标函数值, 邻域动作出现次数相关</li><li>一般需要加上随机成分</li><li>具体实现时将禁忌多久转换为什么时候解禁</li></ul></li><li>解禁策略/特赦准则 (Aspiration Criteria)<ul><li>如果被禁忌的邻域动作是当前邻域的最优动作且能够改进历史最优解则允许其被执行</li></ul></li></ul></li></ul><h3 id="扰动-perturbation">扰动 (Perturbation)</h3><ul><li>重新构造初始解 (Random Restart)<ul><li>需要初始解生成程序具有一定的随机性</li><li>与之前的搜索完全无关, 无法利用已有的搜索结果</li></ul></li><li>贪心或随机地更改解向量中的部分元素</li><li>随机执行邻域动作 (Random Walk)</li><li>交叉算符 (Crossover Operator)<ul><li>将多个解向量中较优的子结构进行组合</li></ul></li></ul><h3 id="图着色禁忌搜索算法总结">图着色禁忌搜索算法总结</h3><ul><li>重新统计每个邻域动作的改进量代价太大<ul><li>改变一个节点的颜色在稀疏图上对整体格局影响很小 =&gt; 记录个节点各种颜色的相邻节点的数量 (即变成各种颜色引入的冲突数量)</li><li>使用新颜色相邻节点数减去旧颜色相邻节点数快速计算改进量</li></ul></li><li>每次遍历所有动作中挑选最优动作代价太大<ul><li>大多数动作显然不可能产生改进 =&gt; 仅评估有冲突的节点</li><li>使用优先队列每次直接取出最优动作<ul><li>非禁忌优先队列 + 禁忌优先队列 + 待解禁循环队列</li><li>使用相邻颜色表校验出队动作实现惰性更新优先队列</li></ul></li></ul></li></ul><h2 id="混合整数规划-mixed-integer-programming">混合整数规划 (Mixed-Integer Programming)</h2><ul><li>概述<ul><li>对于一组给定的自变量, 确定其取值, 使其在满足给定不等式组的前提下, 给定的函数取到最小值</li><li>决策变量的定义域可以是实数 (连续变量) 也可以是整数 (离散变量)</li></ul></li><li>编程范式与原理简介<ul><li>http://www.gurobi.com/resources/getting-started/lp-basics</li><li>http://www.gurobi.com/resources/getting-started/mip-basics</li></ul></li><li>不同的表现形式<ul><li>线形规划模型的标准形式<br><img src="LP1.png" alt="StdForm"></li><li>图形表示<br><img src="LP2.png" alt="GraphRep"></li><li>矩阵表示<br><img src="LP3.png" alt="MatrixRep"></li><li>使用方法<ul><li>使用专门的建模语言<ul><li>https://www.gurobi.com/documentation/6.5/refman/model_file_formats.html</li><li>举例: <a href="coins.lp">coin</a> &amp; <a href="qafiro.lp">qafiro</a></li></ul></li><li>使用命令行接口</li><li>使用应用程序接口<ul><li>添加决策变量</li><li>添加目标函数</li><li>添加约束</li><li>求解</li><li>获取决策变量取值</li></ul></li></ul></li></ul></li></ul><h2 id="贪心算法与近似算法-approximate-algorithm">贪心算法与近似算法 (Approximate Algorithm)</h2><ul><li>贪心算法可视为不回溯的优度优先搜索</li><li>近似算法是一类特殊的贪心算法<ul><li>近似比 (Approximation Ratio): 最坏情况下贪心解离最优解的差距</li></ul></li></ul><h2 id="算法运行模式对比">算法运行模式对比</h2><ul><li>树搜索<br><img src="TreeSearch.png" alt="TreeSearch"></li><li>动态规划<br><img src="DynamicProgramming.png" alt="DynamicProgramming"></li><li>局部搜索<br><img src="LocalSearch.png" alt="LocalSearch"></li></ul><h3 id="树搜索与局部搜索">树搜索与局部搜索</h3><p>局部搜索虽然名字里有 "局部", 但是从某种意义上来说反而很全局——可以对解向量的任意位置进行修改.</p><ul><li>以最小化问题为例,<ul><li>局部搜索关注上界, 是真实可行的解的目标函数值, 更适合实际应用.</li><li>树搜索关注下界, 是理论上最优的解的目标函数值, 更适合理论分析.</li></ul></li></ul><h2 id="更宏观的算法设计">更宏观的算法设计</h2><ul><li>简化问题模型, 将其转换为可高效 (精确) 求解的经典问题, 获得较好格局后再修复细节.<ul><li>固定部分决策.<ul><li>类比: 导师提出求解思路, 学生只需顺着思路实现, 比自己从头设计算法更容易出成果.</li></ul></li><li>松弛部分约束.<ul><li>类比: 两个城市之间的通勤时间与直线距离除以交通工具的速度差别不大.</li></ul></li><li>忽略部分目标函数成份.<ul><li>类比: 地表附近计算重力无需考虑万有引力甚至相对论效应.</li></ul></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;由于生产实践中面临的绝大多数具有实际意义的组合优化问题都已经在理论上被证明属于难以使用可接受的计算资源在可接受的时间内求解的 NP-Hard 问题, 其求解算法不像 P 问题一样存在标准答案. 此外, 在实际的工业应用中, 由于未来的不确定性以及评价指标常常无法完美量化等问
      
    
    </summary>
    
      <category term="技术" scheme="http://suzhouxing.github.io/techive/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="技术" scheme="http://suzhouxing.github.io/techive/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="建模" scheme="http://suzhouxing.github.io/techive/tags/%E5%BB%BA%E6%A8%A1/"/>
    
      <category term="优化" scheme="http://suzhouxing.github.io/techive/tags/%E4%BC%98%E5%8C%96/"/>
    
      <category term="数学" scheme="http://suzhouxing.github.io/techive/tags/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>组合优化 (二) 数学建模基础</title>
    <link href="http://suzhouxing.github.io/techive/2019/01/13/Opt-MathematicalProgramming/"/>
    <id>http://suzhouxing.github.io/techive/2019/01/13/Opt-MathematicalProgramming/</id>
    <published>2019-01-13T03:10:16.000Z</published>
    <updated>2019-10-22T06:05:55.264Z</updated>
    
    <content type="html"><![CDATA[<p>面对一个复杂的组合优化问题, 把它描述清楚本身就不是一个简单的问题. 常规开发往往允许模棱两可的描述, 需求修修补补虽然很烦, 但往往只是工作量的问题. 而算法研发由于其专用性, 细微的需求变化可能导致一个算法完全失效, 除非重新设计整个框架不然无法解决新的问题. 所以, 严谨的需求分析或问题描述对于算法研发格外重要. 对于一个组合优化问题, 我们一般使用数学规划的形式化语言对其进行无二义性的定义, 作为算法工程中的需求分析文档.</p><h1 id="需求分析">需求分析</h1><ul><li>为什么要做需求分析<ul><li>研究一个课题的目的: 实现一个好的系统</li><li>什么样的系统是好系统: 按事先制定的标准进行评价</li><li>标准从哪里来: 需求分析</li></ul></li><li>如何评价一个系统的好坏<ul><li>任务完成质量 (又快又好)<ul><li>完成速度</li><li>完成效果</li></ul></li><li>建设成本</li><li>运营成本</li><li>安全性<ul><li>不受外部因素干扰</li><li>从错误中恢复</li></ul></li><li>稳定性 (今天好, 明天也好; 这组数据好, 那组也好)<ul><li>代码逻辑正确性</li><li>算法对各种场景的兼容性<ul><li>静态多样性</li><li>动态随机性</li></ul></li></ul></li></ul></li><li>简化问题<ul><li>优度和速度的平衡不仅可以在问题求解的过程中, 还可以在问题定义时</li><li>简化问题会影响结果的正确性和优度</li><li>举例<ul><li>宏观低速时使用经典力学而不是相对论</li><li>同时处理多个业务简化为分多次每次处理一个业务</li><li>减小负载和提升安全性转换为不重复经过节点</li></ul></li></ul></li><li>组合优化问题的需求分析<ul><li>按形式化描述语言分类<ul><li>数学规划 (Mathematical Programming)<ul><li>线性规划 (Linear Programming)</li><li>混合整数规划 (Mixed-Integer Programming)</li><li>QP, QCP, SOCP, LFP</li></ul></li><li>约束编程 (Constraint Programming)</li><li>布尔表达式可满足性问题 (Boolean Satisfiability Problem)<ul><li>SAT Encoding</li><li>MAX-SAT Encoding</li></ul></li><li>规约 (Reduction)<ul><li>Karp's 21 NP-complete problems</li></ul></li><li>动态规划</li></ul></li><li>按应用场景分类<ul><li>静态模型</li><li>随机规划 (Stochastic Programming)</li><li>鲁棒优化 (Robust Optimization)</li></ul></li></ul></li></ul><h1 id="线性规划与混合整数规划">线性规划与混合整数规划</h1><h2 id="思维方式">思维方式</h2><h3 id="已知">已知</h3><ul><li>约束和目标中的系数</li></ul><h3 id="决策">决策</h3><ul><li>确定哪些可控因素需要做决策<ul><li>定义域<ul><li>布尔 / 整数 / 实数</li><li>上界 / 下界</li></ul></li></ul></li><li>从最根本的需求开始<ul><li>显示决策 (根本需求)</li><li>隐式决策 (客户不关心但十分重要)</li><li>辅助决策 (将非线性约束转化为线性约束)</li></ul></li><li>不够用再返回来补充</li><li>思考问题的角度影响决策变量的设置<ul><li>图着色问题<ul><li>每个节点染什么颜色</li><li>每种颜色的节点集合包含了哪些节点</li><li>每两个节点是否染了相同的颜色</li></ul></li><li>旅行销售员问题<ul><li>每个节点的第几个被访问</li><li>第几个被访问的节点是哪个节点</li><li>路径包含哪些边</li></ul></li><li>布尔表达式可满足性问题<ul><li>保证每个布尔变量在所有子句中取值一致，最大化为真的子句数量</li><li>保证每个子句均为真，最大化布尔变量的一致性</li></ul></li></ul></li></ul><h3 id="约束">约束</h3><ul><li>决策变量组成的表达式满足的关系<ul><li>等式或不等式 <span class="math inline">\(f(x) ? g(x)\)</span></li><li>下标的取值范围 <span class="math inline">\(\forall i \in V\)</span></li></ul></li><li>可以和目标对调顺序, 谁简单先考虑谁</li><li>如何验证约束是否完备?<ul><li>经验?</li><li>详尽的测试?</li><li>...</li></ul></li></ul><h3 id="目标">目标</h3><ul><li>不同决策变量取值组合产生的后果的优劣度量</li></ul><h2 id="冗余约束-redundant-constraints">冗余约束 (Redundant Constraints)</h2><h3 id="图着色问题的对称性消除-symmetric-breaking">图着色问题的对称性消除 (Symmetric Breaking)</h3><ul><li>参考文献: <a href="https://doi.org/10.1016/j.dam.2006.07.010" target="_blank" rel="noopener">A cutting plane algorithm for graph coloring</a></li><li>优化版本<ul><li>O1 一个颜色至少被一个节点使用时才会被选中 <span class="math display">\[y_{c} \le \sum_{n \in N} x_{nc}, \quad \forall c \in C\]</span></li><li>O2 编号更小的颜色未被选中时禁止选中编号更大的颜色 <span class="math display">\[y_{c&#39;} \ge y_{c}, \quad \forall c, c&#39; \in C, c&#39; = c - 1\]</span></li></ul></li><li>判定版本<ul><li>D1 使用编号更小的颜色的节点数不小于使用编号更大的颜色的节点数 (使用某种颜色的节点数随颜色编号的增长单调变化) <span class="math display">\[\sum_{n \in N} x_{nc&#39;} \ge \sum_{n \in N} x_{nc}, \quad \forall c, c&#39; \in C, c&#39; = c - 1\]</span><ul><li>D1 包含 O2</li></ul></li><li>D2 节点不允许使用比其编号更大的颜色 <span class="math display">\[x_{nc} = 0, \quad \forall n \in N, c \in C, n &lt; c\]</span></li><li>D3 编号更小的颜色未被编号更小的节点使用时禁止使用编号更大的颜色 (使用某种颜色的节点集中最小的节点编号随颜色编号的增长单调变化) <span class="math display">\[\sum_{n&#39; \in [0, n)} x_{n&#39;c&#39;} \ge x_{nc}, \quad \forall n \in N, \forall c, c&#39; \in C, c&#39; = c - 1\]</span> 与 D2 配合使用时, 将固定为 0 的项代入可化简为 <span class="math display">\[\sum_{n&#39; \in [c&#39;, n)} x_{n&#39;c&#39;} \ge x_{nc}, \quad \forall n \in N, \forall c, c&#39; \in C, c&#39; = c - 1, n \ge c\]</span><ul><li>D3 与 D1 冲突</li></ul></li></ul></li></ul><h2 id="编程实现">编程实现</h2><h3 id="求解器选择">求解器选择</h3><ul><li><a href="http://www.gurobi.com/" target="_blank" rel="noopener">Gurobi</a><ul><li>目前最高效的线性规划/混合整数规划求解器</li><li>支持免费学术许可证申请</li></ul></li><li><a href="https://www.ibm.com/software/commerce/optimization/cplex-optimizer/" target="_blank" rel="noopener">CPLEX</a><ul><li>IBM旗下的 "行业标准"</li></ul></li><li><a href="http://scip.zib.de/" target="_blank" rel="noopener">SCIP</a><ul><li>号称最快的开源求解器</li></ul></li><li><a href="https://projects.coin-or.org/Cbc" target="_blank" rel="noopener">COIN-OR</a><ul><li>功能繁多的开源运筹学工具包</li></ul></li><li><a href="https://github.com/google/or-tools" target="_blank" rel="noopener">OR-Tools</a><ul><li>开源经典组合优化算法库</li><li>提供统一的接口调用各大常见求解器</li></ul></li></ul><h3 id="接口选择">接口选择</h3><ul><li>编程语言接口<ul><li>开发中最常用的接口</li><li>提供更高层次的抽象</li><li>更快的模型构建速度</li><li>C / C++ / Java / C# / Python / Matlab / R</li></ul></li><li>模型文件接口<ul><li>需要自己将模型展开为线性规划的标准型</li><li>文件 I/O 速度较慢</li></ul></li><li>交互式命令行接口 (Gurobi)<ul><li>类似于解释型的脚本语言</li></ul></li><li>OPLIDE (CPLEX)<ul><li>介于命令式语言与建模语言之间</li></ul></li><li>Excel 插件</li><li>...</li></ul><h3 id="使用编程语言接口的求解过程-gurobi">使用编程语言接口的求解过程 (Gurobi)</h3><p>参考自带的示例工程 diet, facility, mip1. 基本流程如下.</p><ul><li>初始化环境 GRBEnv()<ul><li>许可证检测</li><li>其他全局参数与数据初始化</li></ul></li><li>初始化模型 GRBModel()</li><li>添加决策变量 GRBModel::addVar()<ul><li>按照一定规律组织决策变量</li><li>使用额外的数据结构将决策变量与用户变量绑定</li></ul></li><li>更新模型 GRBModel::update()<ul><li>惰性更新提升效率 (最新版已无需手动调用该函数)</li><li>CPLEX 不需要此步骤</li></ul></li><li>设置目标 GRBModel::setObjective()</li><li>添加约束 GRBModel::addConstr()</li><li>设置其他参数 GRBModel::set(), GRBEnv::set()<ul><li>运行时间</li><li>输出日志</li></ul></li><li>求解 GRBModel::optimize()</li><li>检查求解状态 GRBModel::get(GRB_IntAttr_Status)</li><li>获取目标函数值 GRBModel::get(GRB_DoubleAttr_ObjVal)</li><li>获取解向量 GRBVar::get()</li></ul><h3 id="使用模型文件接口的求解过程-gurobi">使用模型文件接口的求解过程 (Gurobi)</h3><p>参考自带的示例工程 lp. 基本流程如下.</p><ul><li>准备好 .mps 或 .lp 等模型文件 GRBModel::write()<ul><li>一般由另外的程序输出</li></ul></li><li>读取模型文件 GRBModel(), GRBModel::read()</li><li>求解并输出</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;面对一个复杂的组合优化问题, 把它描述清楚本身就不是一个简单的问题. 常规开发往往允许模棱两可的描述, 需求修修补补虽然很烦, 但往往只是工作量的问题. 而算法研发由于其专用性, 细微的需求变化可能导致一个算法完全失效, 除非重新设计整个框架不然无法解决新的问题. 所以, 
      
    
    </summary>
    
      <category term="技术" scheme="http://suzhouxing.github.io/techive/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="技术" scheme="http://suzhouxing.github.io/techive/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="建模" scheme="http://suzhouxing.github.io/techive/tags/%E5%BB%BA%E6%A8%A1/"/>
    
      <category term="优化" scheme="http://suzhouxing.github.io/techive/tags/%E4%BC%98%E5%8C%96/"/>
    
      <category term="数学" scheme="http://suzhouxing.github.io/techive/tags/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>组合优化 (一) 简介</title>
    <link href="http://suzhouxing.github.io/techive/2019/01/13/Opt-CombinatorialOptimization/"/>
    <id>http://suzhouxing.github.io/techive/2019/01/13/Opt-CombinatorialOptimization/</id>
    <published>2019-01-13T03:07:22.000Z</published>
    <updated>2019-10-22T06:05:14.191Z</updated>
    
    <content type="html"><![CDATA[<p>组合优化也叫离散优化, 是运筹优化的重要组成部分, 其中 "组合" 是排列组合的组合. 从字面上理解这个名词, 组合优化是要从呈组合数复杂度爆炸式增长的解空间中, 寻找最优的解向量, 即制定最优决策方案. 组合优化问题涉及了分配, 调度, 指挥, 路由等众多类型的问题. 作为人工智能的重要分支, 组合优化与时下大热的统计学习存在着千丝万缕的联系. 统计学习更侧重于预测和单步决策, 比如预测出了某件商品的销量, 就可以知道需要进多少货; 预测出了某个区域的人流量, 就可以知道需要分配多少保安巡逻; 检测出患者有某种疾病, 就可以知道要开什么药. 相比之下, 组合优化更注重涉及多方的, 全局的, 系统性的序列决策. 与此同时, 部分统计学习种的模型训练算法与求解组合优化问题的方法往往有异曲同工之妙, 因为离散优化与连续优化在思想上有很多相通之处.</p><h1 id="组合优化基础">组合优化基础</h1><h2 id="组合优化包含哪些问题">组合优化包含哪些问题</h2><ul><li>路由问题: 用开销最小的路径覆盖所有目的地<ul><li>车辆路由</li><li>数据流量路由</li></ul></li><li>指派问题: 在有限的时间和空间中合理使用软硬件资源创造更多的收益<ul><li>时间指派<ul><li>先后序调度<ul><li>单机作业调度</li><li>车间流水线调度</li></ul></li><li>时间槽分配<ul><li>航班与列车时刻表</li><li>人员排班表</li><li>选修课表</li></ul></li></ul></li><li>空间指派<ul><li>哪个背包装哪些物品: 背包问题</li><li>哪个处理器处理作业: 多机作业调度</li><li>哪个中心服务哪些客户: 中心选址</li></ul></li></ul></li><li>...</li><li>NP 完全 (NP-Complete) 问题可以在多项式时间内相互规约</li></ul><h2 id="如何定义一个问题">如何定义一个问题</h2><ul><li>基本要素<ul><li>已知: 输入数据</li><li>决策: 输出结果</li><li>约束: 输出结果可行还是不可行</li><li>目标: 输出结果好还是坏</li></ul></li><li>观察问题的不同角度举例<ul><li>图着色问题<ul><li>每个节点染什么颜色</li><li>每种颜色的节点集合包含了哪些节点</li></ul></li><li>布尔表达式可满足性问题<ul><li>保证每个布尔变量在所有子句中取值一致, 最大化为真的子句数量</li><li>保证每个子句均为真, 最大化布尔变量的一致性</li></ul></li></ul></li></ul><h2 id="基本求解方法分类">基本求解方法分类</h2><ul><li>贪心算法: 在保证求解速度的前提下提升优度<ul><li>部分可以保证最优性的贪心算法往往也可以归类为动态规划 (例如 Dijkstra 最短路算法)</li></ul></li><li>近似算法: 离最优解的差距有保障的贪心算法</li><li>精确算法: 在确保最优性的前提下降低复杂度<ul><li>深度/广度/优度优先树搜索</li><li>动态规划</li><li>混合整数规划的求解算法</li></ul></li><li>启发式算法: 在优度和复杂度之间寻找平衡点<ul><li>基于邻域动作: 元启发式算法<ul><li>单个解 (Trajectory): 局部搜索</li><li>多个解 (Population): 种群算法</li></ul></li><li>基于树搜索<ul><li>A*<ul><li>启发函数可接受 (Admissible) 时为精确算法</li></ul></li><li>向前看树搜索 (Lookahead Tree Search)</li><li>线搜索 (Beam Search)</li><li>蒙特卡洛树搜索 (Monte-Carlo Tree Search)</li></ul></li></ul></li></ul><h1 id="问题归约与转换">问题归约与转换</h1><h2 id="经典问题到现实问题">经典问题到现实问题</h2><ul><li>图着色<ul><li>寄存器分配<ul><li>寄存器 =&gt; 颜色</li><li>变量 =&gt; 节点</li><li>两个变量生命周期有交集 =&gt; 不能使用同一个寄存器 =&gt; 不能染同一种颜色 =&gt; 两个节点间有一条边</li></ul></li><li>多业务波长分配<ul><li>波长 =&gt; 颜色</li><li>路径 =&gt; 节点</li><li>两条路径有交集 =&gt; 不能使用同一个波长 =&gt; 不能染同一种颜色 =&gt; 两个节点间有一条边</li></ul></li><li>停机位分配<ul><li>停机位 =&gt; 颜色</li><li>飞机 =&gt; 节点</li><li>两架飞机过站时间有交集 =&gt; 不能停在同一停机位 =&gt; 不能染同一种颜色 =&gt; 两个节点间有一条边</li></ul></li><li>宿舍分配<ul><li>宿舍 =&gt; 颜色</li><li>学生 =&gt; 节点</li><li>两个学生作息规律差异很大 =&gt; 不能住同一间宿舍 =&gt; 不能然同一种颜色 =&gt; 两个节点间有一条边</li></ul></li></ul></li><li>旅行销售员<ul><li>快递与外卖配送</li><li>物资采购</li><li>人类基因组计划</li></ul></li></ul><h2 id="经典问题相互转换">经典问题相互转换</h2><h3 id="独立集-最大团-顶点覆盖-支配集-集合覆盖-中心选址">独立集 &lt;=&gt; 最大团 &lt;=&gt; 顶点覆盖 =&gt; 支配集 &lt;=&gt; 集合覆盖 &lt;= 中心选址</h3><p>.</p><h3 id="非对称旅行商-对称旅行商">非对称旅行商 &lt;=&gt; 对称旅行商</h3><p>.</p><h3 id="必经点最短简单路-非对称旅行商-最短简单路-最长简单路">必经点最短简单路 =&gt; 非对称旅行商 &lt;=&gt; 最短简单路 &lt;=&gt; 最长简单路</h3><ul><li>必经点最短路 =&gt; 非对称旅行商<ul><li>基本思路<ul><li>增加一条无代价的旁路让所有非必经点能够通过该旁路被访问</li><li>从起点出发, 经过最短路上的实际节点序列, 到达终点, 到达旁路起点, 通过旁路依次经过不在最短路上的实际节点</li></ul></li><li>具体实现<ul><li>假设起点为 <span class="math inline">\(s\)</span>, 终点为 <span class="math inline">\(t\)</span>, 共有 <span class="math inline">\(k\)</span> 个非必经节点 <span class="math inline">\(n_{1}, n_{2}, ..., n_{k}\)</span></li><li>增加 <span class="math inline">\(k + 1\)</span> 个虚拟节点 <span class="math inline">\(v_{0}, v_{1}, ..., v_{k}\)</span></li><li>增加以下有向边<ul><li><span class="math inline">\(t \rightarrow v_{k}\)</span></li><li><span class="math inline">\(v_{i} \rightarrow v_{i-1}, \quad \forall i \in [1, k]\)</span></li><li><span class="math inline">\(v_{i} \rightarrow n_{i}, \quad \forall i \in [1, k]\)</span></li><li><span class="math inline">\(n_{i} \rightarrow v_{i-1}, \quad \forall i \in [1, k]\)</span></li><li><span class="math inline">\(v_{0} \rightarrow s\)</span></li></ul></li><li>上述有向边应满足<ul><li><span class="math inline">\(cost(v_{i} \rightarrow v_{i-1}) = cost(v_{i} \rightarrow n_{i}) + cost(n_{i} \rightarrow v_{i-1})\)</span></li><li><span class="math inline">\(cost(t \rightarrow v_{k}) = cost(v_{0} \rightarrow s) = 0\)</span></li></ul></li></ul></li></ul></li></ul><h2 id="经典问题分解">经典问题分解</h2><h3 id="图着色-集合覆盖-独立集">图着色 = 集合覆盖 + 独立集</h3><p>.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;组合优化也叫离散优化, 是运筹优化的重要组成部分, 其中 &quot;组合&quot; 是排列组合的组合. 从字面上理解这个名词, 组合优化是要从呈组合数复杂度爆炸式增长的解空间中, 寻找最优的解向量, 即制定最优决策方案. 组合优化问题涉及了分配, 调度, 指挥, 路由等众多类型的问题. 作
      
    
    </summary>
    
      <category term="技术" scheme="http://suzhouxing.github.io/techive/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="技术" scheme="http://suzhouxing.github.io/techive/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="建模" scheme="http://suzhouxing.github.io/techive/tags/%E5%BB%BA%E6%A8%A1/"/>
    
      <category term="优化" scheme="http://suzhouxing.github.io/techive/tags/%E4%BC%98%E5%8C%96/"/>
    
      <category term="数学" scheme="http://suzhouxing.github.io/techive/tags/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>理想的编程测试</title>
    <link href="http://suzhouxing.github.io/techive/2018/06/09/IdealCodingTest/"/>
    <id>http://suzhouxing.github.io/techive/2018/06/09/IdealCodingTest/</id>
    <published>2018-06-09T02:41:02.000Z</published>
    <updated>2018-07-01T03:11:17.815Z</updated>
    
    <content type="html"><![CDATA[<p>以下观点仅针对博士招聘或者高级职位的招聘, 如果只是想招个码农一丝不苟地完成编码任务, 可以忽略此文...</p><p>最近参加某公司的博士特招, 收到了的一封邮件说让我做个编程测试. 与普通校招不同, 这封邮件并没有让我去 OJ 平台做题, 而是直接在邮件正文中给了 3 道题让我几天内做完并回复邮件. 这种新颖的形式让我眼前一亮, 虽然最后招聘人员的回复让我发现我想多了, 但是还是想分享一下自己的思考.</p><p>这种编程测试有以下几个特点:</p><ul><li>问题描述模糊</li><li>有常规求解方法 (有可能在 ACM 比赛中短时间内实现)</li><li>有高级求解方法</li><li>线下完成且时间宽裕</li></ul><p>这种开放性的命题其实可以考察很多内容.</p><p>首先, 因为问题描述存在不严谨的地方, 沟通会非常重要, 换句话说, 这是一种需求分析的意识和能力. 其次, 因为没有限制输入输出数据格式, 需要自己定义接口, 自己确定代码框架. 写出来的代码要足够模块化以适应需求的变更, 包括问题定义的改变和性能要求的提升, 同时接口定义合理方便在其他地方复用. 然后, 没有给定输入输出数据格式肯定更不会给测试用例, 需要自己编写测试用例并且有测试相关的代码, 同时也是使用接口的示例代码. 最后, 编码风格也是可以需要注意的因素之一, 比如命名统一规范且足够自文档, 对功能复杂的模块有适当的注释等等.</p><p>举个例子, 这样一道题目 "对一个字符串进行词频统计, 按词频降序排序输出 (word, count)", 你在 OJ 上刷题时会怎么做? 在工作中遇到会怎么做? 这个问题其实给得非常模糊, 如果是我至少会想到以下几个问题:</p><ul><li>字符串长度是否超过内存容量限制?</li><li>文件是否只包含 ASCII 码且按照拉丁语系的书写习惯组织词法语法?</li><li>文件是否包含空白字符以外的非字母字符 (如数字和标点)? 如果包含, 是否仍然严格以空白字符为分隔符分词?</li><li>单词是否区分大小写?</li><li>不同单词数量规模有多大? 是否可能超出 int 最大范围?</li><li>每个单词的出现频率是否超出 int 最大范围?</li><li>两个单词词频相同怎么办?</li></ul><p>对于最复杂的情况, 比如需要做中文分词, 外部排序, 甚至分布式处理, 可能需要用到各种开源库, 代码量甚至可以达到成千上万行...</p><p>也许你会说, 理想很丰满现实很骨感. 上面这些好处大家都懂, 但是只要你是一种考核, 就会有针对性的应试技巧. 在线编程测试时间那么短, 可以在一定程度上杜绝抄袭, 但是弄成离线的测试放宽时间限制, 根本不理解算法的人也可以复制粘贴搞出一份代码提交. 首先能敲出代码的人不一定自己真的理解了算法, 甚至觉得自己理解了算法的人也不一定是真的理解了, 很多人对算法的理解并没有达到能证明其正确性和最优性的地步. 其次这种测试考察的是各方面的综合能力, 而不是某个具体问题的解法. 靠死记硬背做出一道题, 换个问题可能就不会做了 (当然, 我们必须承认反复训练可以提升设计算法的感觉). 但是遇到问题先仔细分析需求, 然后从可复用性和可扩展性考虑规划代码架构, 最后进行系统的测试的能力, 是可以在每个项目中发挥作用的. 至于同时参加编程测试的人互相抄袭的问题, 现在应该已经有自动代码查重的工具了. 而且题库丰富起来之后, 给可能相互认识的求职者 (比如同一个研究所) 分发不同的题目即可.</p><p>当然, 这种模式也有缺点, 就是在现有技术水平下只能人工判卷, 且评判结果主观性太强, 无法适应大规模的招聘.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;以下观点仅针对博士招聘或者高级职位的招聘, 如果只是想招个码农一丝不苟地完成编码任务, 可以忽略此文...&lt;/p&gt;
&lt;p&gt;最近参加某公司的博士特招, 收到了的一封邮件说让我做个编程测试. 与普通校招不同, 这封邮件并没有让我去 OJ 平台做题, 而是直接在邮件正文中给了 
      
    
    </summary>
    
      <category term="技术" scheme="http://suzhouxing.github.io/techive/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="技术" scheme="http://suzhouxing.github.io/techive/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="招聘" scheme="http://suzhouxing.github.io/techive/tags/%E6%8B%9B%E8%81%98/"/>
    
      <category term="求职" scheme="http://suzhouxing.github.io/techive/tags/%E6%B1%82%E8%81%8C/"/>
    
      <category term="编程" scheme="http://suzhouxing.github.io/techive/tags/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>数据库中的搜索, 组合优化问题的搜索, 统一建模语言与通用求解器</title>
    <link href="http://suzhouxing.github.io/techive/2018/06/07/SearchingInDatabaseOrOptimization/"/>
    <id>http://suzhouxing.github.io/techive/2018/06/07/SearchingInDatabaseOrOptimization/</id>
    <published>2018-06-07T02:50:41.000Z</published>
    <updated>2021-09-04T06:46:28.971Z</updated>
    
    <content type="html"><![CDATA[<p>最近遇到了一个小问题, 大致是已知一块玻璃上有些瑕疵, 如何切割出一块给定大小的矩形区域, 让它的位置尽量靠近左下角, 但是不与任何瑕疵重合.</p><p>虽然原始问题要求的是不与任何瑕疵重合, 但是对于一个给定的格局, 比如已知一些瑕疵会同时被覆盖, 有些瑕疵显然是不需要考虑的, 我们称其为 "被支配" 的瑕疵. 所以其实我们只需要避开没有 "被支配" 的瑕疵, 如下图中红色的点, 而绿色的点显然是不需要考虑的.</p><figure><img src="Packing.png" alt="矩形装配"><figcaption aria-hidden="true">矩形装配</figcaption></figure><p>这个问题给我的第一反应是它和多目标优化的一种实现方式很像, 即帕累托最优性 (Pareto Optimality). 对于在帕累托前沿 (Pareto Frontier) 上的点, 找不到这样一个点, 在各个维度 (目标) 上都比他们数值更大 (目标函数值更优). 反之, 通俗地说, 就是存在一个点在各个维度上都能碾压某个不在 Pareto Frontier 上的点.</p><p>在搜索引擎里搜了下, 想找找有没有高效的求解方案, 找到了下面几个网页:<br>https://en.wikipedia.org/wiki/Pareto_efficiency#Computation<br>https://en.wikipedia.org/wiki/Multi-objective_optimization<br>https://en.wikipedia.org/wiki/Skyline_operator</p><p>其中令人惊讶的是, 这个问题居然跟数据库有关, 甚至 SQL 里面还有个专门的算子用来实现这个功能!</p><p>突然想起前段时间一位在国内某 500 强企业数据库部门的师叔来实验室交流时, 对通用求解器的讨论. 数据库和组合优化都是在一个有限的解空间内搜索满足条件的数据. 而数据库有个很大的优点, 就是有一个统一的描述语言, SQL, 来定义一切对数据的查询和修改操作. 在多年的不断改进和优化之下, 使用数据管理系统已经能比绝大多数人自行编写代码完成数据管理更加高效了. 但是对于组合优化问题, 无论是学术界还是工业界, 都还在以手工打造为主的阶段. 以 Gurobi 和 CPLEX 为首的基于线性规划的通用求解器存在各种各样的限制, 比如只支持混合整数规划和特殊形式的二次规划, 而且求解速度往往慢于针对性的启发式算法或精确算法. 其他的基于约束编程 (Constraint Programming) 的求解器, 或者基于启发式的 LocalSolver 等求解器提供了更丰富而强大的建模语言, 但表达能力仍然有限, 且求解效果尚不如 Gurobi. 更进一步, 将问题编码成布尔表达式可满足性问题 (SAT 或 MAX-SAT) 也是一个很有意思的方案, 但是如果说前两种得到了广泛应用的方案是用 C++ 编程, 这个方案简直就是在用汇编甚至设计电路.</p><p>这样看来, 打造一个更加通用更加高效的求解器似乎是一个很有吸引力的研究方向.</p><p>然而, 即使在 "大数据" 时代, PB 甚至 EB 级的数据量仍然是十分有限的, 跟几乎无穷无尽的组合优化问题的解空间相比, 实在是太渺小了. 简单机械地将问题拆分成多个子问题逐层求解的方式听起来前途十分渺茫. 因此, 要实现这个设想的难度也是十分巨大的.</p><h1 id="附-开篇问题的严谨定义">附: 开篇问题的严谨定义</h1><p>令 A(d) 表示矩形区域的左侧边缘与瑕疵 d 的右侧边缘存在重合的部分; B(d) 表示矩形区域的下侧边缘与瑕疵 d 的上侧边缘存在重合的部分; C(x) 和 C(y) 分别表示矩形区域的下侧边缘和左侧边缘与 x 轴和 y 轴重合. 其中边缘均为不包括矩形区域顶点的线段.</p><p>则矩形区域的放置位置需要满足以下约束:</p><p>存在 d != d', 使 (A(d) &amp;&amp; C(x)) || (B(d) &amp;&amp; C(y) || (A(d) &amp;&amp; B(d')) 为真, 同时矩形区域内不存在任何瑕疵.</p><p>求矩形区域所有可能的放置位置.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近遇到了一个小问题, 大致是已知一块玻璃上有些瑕疵, 如何切割出一块给定大小的矩形区域, 让它的位置尽量靠近左下角, 但是不与任何瑕疵重合.&lt;/p&gt;
&lt;p&gt;虽然原始问题要求的是不与任何瑕疵重合, 但是对于一个给定的格局, 比如已知一些瑕疵会同时被覆盖, 有些瑕疵显然是不
      
    
    </summary>
    
      <category term="技术" scheme="http://suzhouxing.github.io/techive/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="运筹优化" scheme="http://suzhouxing.github.io/techive/tags/%E8%BF%90%E7%AD%B9%E4%BC%98%E5%8C%96/"/>
    
      <category term="技术" scheme="http://suzhouxing.github.io/techive/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="通用求解器" scheme="http://suzhouxing.github.io/techive/tags/%E9%80%9A%E7%94%A8%E6%B1%82%E8%A7%A3%E5%99%A8/"/>
    
      <category term="建模" scheme="http://suzhouxing.github.io/techive/tags/%E5%BB%BA%E6%A8%A1/"/>
    
      <category term="数据库" scheme="http://suzhouxing.github.io/techive/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="多目标" scheme="http://suzhouxing.github.io/techive/tags/%E5%A4%9A%E7%9B%AE%E6%A0%87/"/>
    
  </entry>
  
  <entry>
    <title>组合优化问题的数学建模资料整理</title>
    <link href="http://suzhouxing.github.io/techive/2018/04/01/ModelingInCombinatorialOptimization/"/>
    <id>http://suzhouxing.github.io/techive/2018/04/01/ModelingInCombinatorialOptimization/</id>
    <published>2018-04-01T02:31:21.000Z</published>
    <updated>2018-07-01T03:11:17.816Z</updated>
    
    <content type="html"><![CDATA[<p>给实验室的新生和实习生培训用的资料.</p><p><a href="http://suzhouxing.github.io/assets/articles/Modeling%20in%20Combinatorial%20Optimization.pptx">组合优化问题的数学建模.pptx</a></p><p><a href="http://suzhouxing.github.io/assets/articles/Converting%20Non-linear%20Objectives%20into%20Linear%20Ones.pdf">线性化非线性表达式.pdf</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;给实验室的新生和实习生培训用的资料.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://suzhouxing.github.io/assets/articles/Modeling%20in%20Combinatorial%20Optimization.pptx&quot;&gt;组合优化问题
      
    
    </summary>
    
      <category term="技术" scheme="http://suzhouxing.github.io/techive/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="技术" scheme="http://suzhouxing.github.io/techive/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="建模" scheme="http://suzhouxing.github.io/techive/tags/%E5%BB%BA%E6%A8%A1/"/>
    
      <category term="优化" scheme="http://suzhouxing.github.io/techive/tags/%E4%BC%98%E5%8C%96/"/>
    
      <category term="数学" scheme="http://suzhouxing.github.io/techive/tags/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>欧美的优化算法公司在中国的水土不服</title>
    <link href="http://suzhouxing.github.io/techive/2018/01/31/DifferentWayOfThinking/"/>
    <id>http://suzhouxing.github.io/techive/2018/01/31/DifferentWayOfThinking/</id>
    <published>2018-01-31T13:45:46.000Z</published>
    <updated>2021-09-16T05:40:29.993Z</updated>
    
    <content type="html"><![CDATA[<p>最近做项目的过程中发现, 甲方使用的系统里据说调用了 Quintiq 的优化算法, 但是甲方表示这个算法求出来的结果完全不能用, 于是这个功能长期处于闲置状态. 突然想起之前听说中石油中石化都买了 Aspen 的系统, 但是成品油配送基本上也没用系统自带的算法, 还是在由调度员人工调度. 此外, 还听说上海交大的某教授二十年前刚从国外回来的时候, 去找东航说要帮他们做航线规划的算法, 结果东航说就那么点飞机, 人调度就够了, 不需要什么算法.</p><p>如果上面的几个故事是普遍现象的话, 那么欧美工业界的成功案例在国内确实是水土不服. 但是受限于个人眼界的狭窄, 以及获取信息的渠道有限, 上面的见闻既不可靠, 也不能反映整体情况. 工业界到底有怎样的内幕是不得而知了, 不过也许从学术界的研究中可以看出些端倪. 下面将以几个经典的问题为例, 对比一下学术论文中研究的问题和在国内遇到的实际情况.</p><h1 id="停机位分配">停机位分配</h1><ul><li>机位初始分配<ul><li>欧美一般是在近机位上下客, 如果过站时间较长可能会中途把飞机拖到远机位起飞前又拖回近机位</li><li>国内一般是不调整停机位, 近机位停满了就停到远机位, 用摆渡车把乘客拉到远机位登机</li></ul></li><li>发生延误时的机位调整<ul><li>欧美一般不变更停机位, 后继航班在空中或滑行道上等待</li><li>国内一般是直接将后继航班分配至同区域的近机位或远机位, 并通知乘客变更登机门</li></ul></li></ul><p>国内似乎是人跟着飞机跑, 而欧美似乎是飞机围着人转.</p><p>当然, 欧美也是个很大的概念, 包含了太多国家和地区, 不能一概而论. 而且论文作者也不见得和机场有深入的沟通, 研究的问题也许只是假想的应用场景.</p><h1 id="排课表">排课表</h1><ul><li>选修课<ul><li>欧美一般是学生先根据自己的兴趣选课, 由选课系统来确定课程的时间地点以最小化学生不同课程之间的时间冲突</li><li>国内一般是选课系统提前把每门课的时间地点确定好, 由学生选择想上哪些课程时自行解决时间冲突</li></ul></li><li>必修课<ul><li>欧美一般是根据课时需求统一规划上课时间和教室分配</li><li>国内一般是先排好校级公共课时间, 然后各学院分别确定专业课时间, 最后汇总协调教室分配</li></ul></li></ul><p>在选修课方面, 国内是非常具有中国特色的超大规模人肉并行计算, 而欧美则相对自由一点 (当然, 每个课堂还是有的容量限制, 不可能完全做到根据兴趣选课). 而必修课方面, 国内采用的是分而治之的方案, 后期需要花费较多精力在各学院之间协调, 而欧美直接从全局的角度考虑, 对算法性能要求很高.</p><h1 id="护士排班">护士排班</h1><ul><li>欧美一般是提前提出上班时间的偏好, 然后排班系统在考虑特殊需求的情况下均衡总工作量和工作强度等指标</li><li>国内一般是按照简单的规则排出很规整的排班表, 如果有特殊情况需要调整上班时间自行跟其他人协商调班</li></ul><p>国内的医护人员往往十分紧缺, 相对来说都是全职全能型的, 不像欧美有那么多余地可以选择不同的合同. 正因为大家的职能差别不大, 所以复杂的排班算法确实没有用武之地, 调度来调度去并没有太大差别. 而有特殊情况时私下跟他人协商临时调班也是一种人肉并行计算, 既然统一规划众口难调, 那就大家各管各饱.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近做项目的过程中发现, 甲方使用的系统里据说调用了 Quintiq 的优化算法, 但是甲方表示这个算法求出来的结果完全不能用, 于是这个功能长期处于闲置状态. 突然想起之前听说中石油中石化都买了 Aspen 的系统, 但是成品油配送基本上也没用系统自带的算法, 还是在由调
      
    
    </summary>
    
      <category term="技术" scheme="http://suzhouxing.github.io/techive/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="运筹优化" scheme="http://suzhouxing.github.io/techive/tags/%E8%BF%90%E7%AD%B9%E4%BC%98%E5%8C%96/"/>
    
      <category term="技术" scheme="http://suzhouxing.github.io/techive/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="建模" scheme="http://suzhouxing.github.io/techive/tags/%E5%BB%BA%E6%A8%A1/"/>
    
      <category term="需求分析" scheme="http://suzhouxing.github.io/techive/tags/%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>二分法与黄金分割法的区别</title>
    <link href="http://suzhouxing.github.io/techive/2018/01/14/IntervalEliminationMethod/"/>
    <id>http://suzhouxing.github.io/techive/2018/01/14/IntervalEliminationMethod/</id>
    <published>2018-01-14T01:19:00.000Z</published>
    <updated>2018-07-01T03:11:17.815Z</updated>
    
    <content type="html"><![CDATA[<p>高中数学选修课学过区间消去法, 用于求解简单的单变量无约束的优化问题. 其中的典型有二分法和黄金分割法 (0.618法), 后来还知道黄金分割法其实是斐波那契法的简化. 而很多人似乎并不清楚这两种方法的区别和适用场景.</p><p>读研之后一直在做运筹学相关的问题, 遇到的优化问题都是上百万维的多约束多目标的组合优化问题. 偶然间遇到了一个简单的一维的情况, 突然来了一种莫名的自信觉得自己可以比当时的高中数学老师讲得更清楚...</p><p>二分法主要用于寻找阶跃函数的突变点.</p><figure><img src="BisectionMethod.png" alt="阶跃函数"><figcaption aria-hidden="true">阶跃函数</figcaption></figure><p>例如二分查找, 定义比待查找元素小的元素目标函数值为 0, 比待查找元素大的元素目标函数值为 1, 则待查找元素为目标函数的突变点.</p><p>黄金分割法和斐波那契法用于寻找单峰函数的极值点.</p><figure><img src="FibonacciMethod.png" alt="单峰函数"><figcaption aria-hidden="true">单峰函数</figcaption></figure><p>例如确定药物的最佳剂量, 定义治疗效果和副作用为目标函数, 则用量比最佳剂量大或者小时综合效果都更差.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;高中数学选修课学过区间消去法, 用于求解简单的单变量无约束的优化问题. 其中的典型有二分法和黄金分割法 (0.618法), 后来还知道黄金分割法其实是斐波那契法的简化. 而很多人似乎并不清楚这两种方法的区别和适用场景.&lt;/p&gt;
&lt;p&gt;读研之后一直在做运筹学相关的问题, 遇
      
    
    </summary>
    
      <category term="数学" scheme="http://suzhouxing.github.io/techive/categories/%E6%95%B0%E5%AD%A6/"/>
    
    
      <category term="优化" scheme="http://suzhouxing.github.io/techive/tags/%E4%BC%98%E5%8C%96/"/>
    
      <category term="数学" scheme="http://suzhouxing.github.io/techive/tags/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="高中" scheme="http://suzhouxing.github.io/techive/tags/%E9%AB%98%E4%B8%AD/"/>
    
  </entry>
  
</feed>
