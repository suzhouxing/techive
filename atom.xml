<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Techive</title>
  
  <subtitle>An Archive for Technologies</subtitle>
  <link href="/techive/atom.xml" rel="self"/>
  
  <link href="http://suzhouxing.github.io/techive/"/>
  <updated>2020-12-22T06:55:27.731Z</updated>
  <id>http://suzhouxing.github.io/techive/</id>
  
  <author>
    <name>Zhouxing Su</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>SmartLab Challenge 2020 - p-Center and Unicost Set Covering</title>
    <link href="http://suzhouxing.github.io/techive/2020/12/22/Contest-2020pCenter/"/>
    <id>http://suzhouxing.github.io/techive/2020/12/22/Contest-2020pCenter/</id>
    <published>2020-12-22T02:19:15.000Z</published>
    <updated>2020-12-22T06:55:27.731Z</updated>
    
    <content type="html"><![CDATA[<p>中心选址问题是通信与物流等领域中的重要问题, 其背后的单一成本集合覆盖问题更是用途广泛. 中心选址问题和单一成本集合覆盖问题主要研究如何使用有限的资源提供尽可能高质量的服务的问题. 例如, 移动基站, 消防站, 物流仓库, 数据中心等众多设施的选址都可以建模为中心选址问题. 高效的中心选址或单一成本集合覆盖问题的求解算法具有及其重要的理论与应用价值.</p><h1 id="中心选址与单一成本集合覆盖算法训练">中心选址与单一成本集合覆盖算法训练</h1><h2 id="命令行参数">命令行参数</h2><p>请大家编写程序时支持四个命令行参数, 依次为算例文件路径, 输出解文件路径, 运行时间上限 (单位为秒) 和随机种子 (0-65535). 例如, 在控制台运行以下命令表示调用可执行文件 <code>uscp.exe</code> 求解路径为 <code>../data/pmed1.n100p5.txt</code> 的算例, 解文件输出至 <code>pmed1.n100p5.txt</code>, 限时 1000 秒, 随机种子为 12345: <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uscp.exe ../data/pmed1.n100p5.txt pmed1.n100p5.txt 1000 12345</span><br></pre></td></tr></table></figure></p><ul><li>运行时间上限.<ul><li>超出运行时间上限后测试程序会强行终止算法, 请确保在此之前已保存解文件 (最好还能自行正常退出).</li></ul></li><li>随机种子设置.<ul><li>使用 C 语言随机数生成器请用 <code>srand</code>.</li><li>使用 C++ 随机数生成器 (如 <code>mt19937</code>) 请在构造时传参或调用 <code>seed()</code> 方法设置.</li></ul></li><li>测试时可能会修改算例文件名，请勿针对文件名做特殊处理.</li></ul><h2 id="输入的算例文件格式">输入的算例文件格式</h2><p>所有算例均已根据给定覆盖半径转换为判定问题, 处理为一系列固定集合数的单一成本集合覆盖算例. 转换后每个节点都可以覆盖若干节点, 同时也对称地被若干节点覆盖, 故转换后的单一成本集合覆盖算例中集合数等于元素数.</p><p>所有算例的元素和集合分别从 0 开始连续编号.</p><p>第一行给出两个由空格分隔的整数 N 和 P, 分别表示节点数和中心数 (从集合覆盖的角度来看, N 既是集合数又是元素数, P 为可挑选出的集合数).</p><p>接下来每两行一组, 连续 N 组给出每个集合的覆盖范围. 每组中第一行为该集合能覆盖的元素数量 C, 第二行为空格分隔的 C 个数字, 分别表示该集合能覆盖的元素的编号.</p><p>例如, 以下算例文件表示有集合和元素的数量均为 4, 要求挑选出 2 个集合覆盖所有元素; 其中,<br>集合 0 可以覆盖 2 个元素, 分别为元素 0 和 3;<br>集合 1 可以覆盖 2 个元素, 分别为元素 1 和 2;<br>集合 2 可以覆盖 3 个元素, 分别为元素 1, 2 和 3;<br>集合 3 可以覆盖 2 个元素, 分别为元素 0 和 2: <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">4 2</span><br><span class="line">2</span><br><span class="line">0 3</span><br><span class="line">2</span><br><span class="line">1 2</span><br><span class="line">3</span><br><span class="line">1 2 3</span><br><span class="line">2</span><br><span class="line">0 2</span><br></pre></td></tr></table></figure></p><h2 id="输出的解文件格式">输出的解文件格式</h2><p>输出一行用空格分隔的 P 个数字, 分别表示挑选出的 P 个中心 (集合).</p><p>例如, 以下解文件表示选择节点 0 和 2 作为中心 (集合): <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 2</span><br></pre></td></tr></table></figure></p><h2 id="提交要求">提交要求</h2><ul><li>发送至邮箱 <a href="mailto:su.zhouxing@qq.com" target="_blank" rel="noopener">su.zhouxing@qq.com</a>.</li><li>邮件标题格式为 &quot;Challenge2020USCP-姓名-班级-学号&quot;.</li><li>邮件附件为单个压缩包, 文件名为 &quot;姓名-班级&quot;, 其内包含下列文件.<ul><li>算法的可执行文件.</li><li>算法源码.</li><li>算法在各算例上的运行情况概要, 至少包括以下几项信息.<ul><li>算例名.</li><li>剩余未覆盖元素数.</li><li>计算耗时.</li></ul></li><li>算法在各算例上求得的完全覆盖的解文件.</li></ul></li></ul><h2 id="检查程序">检查程序</h2><p>我们可能会使用以下 c# 程序检查大家提交的算法和结果 (仅供参考).</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> System.IO;</span><br><span class="line"><span class="keyword">using</span> System.Linq;</span><br><span class="line"><span class="keyword">using</span> System.Text;</span><br><span class="line"><span class="keyword">using</span> System.Diagnostics;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">UscpBenchmark</span> &#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span> &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">string</span> inputFilePath = args[<span class="number">0</span>]; <span class="comment">// instance file.</span></span><br><span class="line">            <span class="keyword">string</span> outputFilePath = args[<span class="number">1</span>]; <span class="comment">// solution file.</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (args.Length &gt; <span class="number">3</span>) &#123;</span><br><span class="line">                <span class="keyword">string</span> exeFilePath = args[<span class="number">2</span>]; <span class="comment">// algorithm executable file.</span></span><br><span class="line">                <span class="keyword">string</span> secTimeout = args[<span class="number">3</span>]; <span class="comment">// timeout in second.</span></span><br><span class="line">                benchmark(inputFilePath, outputFilePath, exeFilePath, secTimeout);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                check(inputFilePath, outputFilePath);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">check</span>(<span class="params"><span class="keyword">string</span> inputFilePath, <span class="keyword">string</span> outputFilePath</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> nodeNum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> centerNum = <span class="number">0</span>;</span><br><span class="line">            List&lt;List&lt;<span class="keyword">int</span>&gt;&gt; sets = <span class="keyword">new</span> List&lt;List&lt;<span class="keyword">int</span>&gt;&gt;();</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">string</span>[] lines = File.ReadAllLines(inputFilePath);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">string</span>[] cells = lines[<span class="number">0</span>].Split(<span class="string">' '</span>);</span><br><span class="line">                nodeNum = <span class="keyword">int</span>.Parse(cells[<span class="number">0</span>]);</span><br><span class="line">                centerNum = <span class="keyword">int</span>.Parse(cells[<span class="number">1</span>]);</span><br><span class="line">                sets.Capacity = nodeNum;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">1</span>; l &lt; lines.Length; ++l) &#123;</span><br><span class="line">                    <span class="keyword">int</span> coveredItemNum = <span class="keyword">int</span>.Parse(lines[l]);</span><br><span class="line">                    cells = lines[++l].Split(<span class="string">' '</span>);</span><br><span class="line">                    List&lt;<span class="keyword">int</span>&gt; <span class="keyword">set</span> = <span class="keyword">new</span> List&lt;<span class="keyword">int</span>&gt;(coveredItemNum);</span><br><span class="line">                    <span class="keyword">foreach</span> (<span class="keyword">var</span> cell <span class="keyword">in</span> cells) &#123; <span class="keyword">set</span>.Add(<span class="keyword">int</span>.Parse(cell)); &#125;</span><br><span class="line">                    sets.Add(<span class="keyword">set</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            List&lt;<span class="keyword">int</span>&gt; pickedSets = <span class="keyword">new</span> List&lt;<span class="keyword">int</span>&gt;(centerNum);</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">string</span>[] cells = File.ReadAllText(outputFilePath).Split(<span class="string">' '</span>);</span><br><span class="line">                <span class="keyword">foreach</span> (<span class="keyword">string</span> cell <span class="keyword">in</span> cells) &#123; pickedSets.Add(<span class="keyword">int</span>.Parse(cell)); &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> uncoveredItemNum = nodeNum;</span><br><span class="line">            List&lt;<span class="keyword">bool</span>&gt; isItemCovered = <span class="keyword">new</span> List&lt;<span class="keyword">bool</span>&gt;(Enumerable.Repeat(<span class="literal">false</span>, nodeNum));</span><br><span class="line">            <span class="keyword">foreach</span> (<span class="keyword">var</span> s <span class="keyword">in</span> pickedSets) &#123;</span><br><span class="line">                <span class="keyword">foreach</span> (<span class="keyword">var</span> item <span class="keyword">in</span> sets[s]) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (isItemCovered[item]) &#123; <span class="keyword">continue</span>; &#125;</span><br><span class="line">                    isItemCovered[item] = <span class="literal">true</span>;</span><br><span class="line">                    --uncoveredItemNum;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Console.Write(<span class="string">"instance="</span>);</span><br><span class="line">            Console.Write(Path.GetFileName(inputFilePath));</span><br><span class="line"></span><br><span class="line">            Console.Write(<span class="string">" center="</span>);</span><br><span class="line">            Console.Write(pickedSets.Count);</span><br><span class="line"></span><br><span class="line">            Console.Write(<span class="string">" uncovered="</span>);</span><br><span class="line">            Console.WriteLine(uncoveredItemNum);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">benchmark</span>(<span class="params"><span class="keyword">string</span> inputFilePath, <span class="keyword">string</span> outputFilePath, <span class="keyword">string</span> exeFilePath, <span class="keyword">string</span> secTimeout</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">int</span> Repeat = <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">int</span> MillisecondTimeLimit = <span class="number">10</span> * <span class="number">60</span> * <span class="number">1000</span>;</span><br><span class="line">            IntPtr ByteMemoryLimit = <span class="keyword">new</span> IntPtr(<span class="number">1024</span> * <span class="number">1024</span> * <span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Repeat; ++i) &#123;</span><br><span class="line">                <span class="keyword">int</span> seed = genSeed();</span><br><span class="line">                StringBuilder cmdArgs = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">                cmdArgs.Append(inputFilePath).Append(<span class="string">" "</span>).Append(outputFilePath)</span><br><span class="line">                    .Append(<span class="string">" "</span>).Append(secTimeout).Append(<span class="string">" "</span>).Append(seed);</span><br><span class="line"></span><br><span class="line">                Stopwatch sw = <span class="keyword">new</span> Stopwatch();</span><br><span class="line">                sw.Start();</span><br><span class="line">                ProcessStartInfo psi = <span class="keyword">new</span> ProcessStartInfo();</span><br><span class="line">                psi.FileName = exeFilePath;</span><br><span class="line">                psi.WorkingDirectory = Environment.CurrentDirectory;</span><br><span class="line">                psi.Arguments = cmdArgs.ToString();</span><br><span class="line">                Process p = Process.Start(psi);</span><br><span class="line">                p.MaxWorkingSet = ByteMemoryLimit;</span><br><span class="line">                <span class="keyword">if</span> (!p.WaitForExit(MillisecondTimeLimit)) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123; p.Kill(); &#125; <span class="keyword">catch</span> (Exception) &#123; &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                sw.Stop();</span><br><span class="line"></span><br><span class="line">                Console.Write(<span class="string">"time="</span>);</span><br><span class="line">                Console.Write(sw.ElapsedMilliseconds / <span class="number">1000.0</span>);</span><br><span class="line">                Console.Write(<span class="string">"s seed="</span>);</span><br><span class="line">                Console.Write(seed);</span><br><span class="line">                Console.Write(<span class="string">" "</span>);</span><br><span class="line"></span><br><span class="line">                check(inputFilePath, outputFilePath);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">genSeed</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (<span class="keyword">int</span>)(DateTime.Now.Ticks &amp; <span class="number">0xffff</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="算例清单">算例清单</h2><p>算例规模从小到大依次为 (求解难度不一定随规模增加, 但除 pcb3038* 以外的算例应该都很容易求解):</p><p>pmed1.n100p5<br>pmed2.n100p10<br>pmed3.n100p10<br>pmed4.n100p20<br>pmed5.n100p33<br>pmed6.n200p5<br>pmed7.n200p10<br>pmed8.n200p20<br>pmed9.n200p40<br>pmed10.n200p67<br>pmed11.n300p5<br>pmed12.n300p10<br>pmed13.n300p30<br>pmed14.n300p60<br>pmed15.n300p100<br>pmed16.n400p5<br>pmed17.n400p10<br>pmed18.n400p40<br>pmed19.n400p80<br>pmed20.n400p133<br>pmed21.n500p5<br>pmed22.n500p10<br>pmed23.n500p50<br>pmed24.n500p100<br>pmed25.n500p167<br>pmed26.n600p5<br>pmed27.n600p10<br>pmed28.n600p60<br>pmed29.n600p120<br>pmed30.n600p200<br>pmed31.n700p5<br>pmed32.n700p10<br>pmed33.n700p70<br>pmed34.n700p140<br>pmed35.n800p5<br>pmed36.n800p10<br>pmed37.n800p80<br>pmed38.n900p5<br>pmed39.n900p10<br>pmed40.n900p90<br>u1060p10r2273.08<br>u1060p20r1580.80<br>u1060p30r1207.77<br>u1060p40r1020.56<br>u1060p50r904.92<br>u1060p60r781.17<br>u1060p70r710.75<br>u1060p80r652.16<br>u1060p90r607.87<br>u1060p100r570.01<br>u1060p110r538.84<br>u1060p120r510.27<br>u1060p130r499.65<br>u1060p140r452.46<br>u1060p150r447.01<br>rl1323p10r3077.30<br>rl1323p20r2016.40<br>rl1323p30r1631.50<br>rl1323p40r1352.36<br>rl1323p50r1187.27<br>rl1323p60r1063.01<br>rl1323p70r971.93<br>rl1323p80r895.06<br>rl1323p90r832.00<br>rl1323p100r789.70<br>u1817p10r457.91<br>u1817p20r309.01<br>u1817p30r240.99<br>u1817p40r209.45<br>u1817p50r184.91<br>u1817p60r162.64<br>u1817p70r148.11<br>u1817p80r136.77<br>u1817p90r129.51<br>u1817p100r126.99<br>u1817p110r109.25<br>u1817p120r107.76<br>u1817p130r104.73<br>u1817p140r101.60<br>u1817p150r91.60<br>pcb3038p10r728.54<br>pcb3038p20r493.04<br>pcb3038p30r393.50<br>pcb3038p40r336.42<br>pcb3038p50r297.83<br>pcb3038p50r298.04<br>pcb3038p50r298.10<br>pcb3038p100r206.6<br>pcb3038p100r206.31<br>pcb3038p100r206.63<br>pcb3038p150r164.40<br>pcb3038p150r164.55<br>pcb3038p150r164.77<br>pcb3038p200r140.06<br>pcb3038p200r140.09<br>pcb3038p200r140.90<br>pcb3038p250r122.25<br>pcb3038p300r115.00<br>pcb3038p350r104.68<br>pcb3038p400r96.88<br>pcb3038p450r88.55<br>pcb3038p500r84.58</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;中心选址问题是通信与物流等领域中的重要问题, 其背后的单一成本集合覆盖问题更是用途广泛. 中心选址问题和单一成本集合覆盖问题主要研究如何使用有限的资源提供尽可能高质量的服务的问题. 例如, 移动基站, 消防站, 物流仓库, 数据中心等众多设施的选址都可以建模为中心选址问题.
      
    
    </summary>
    
      <category term="算法挑战" scheme="http://suzhouxing.github.io/techive/categories/%E7%AE%97%E6%B3%95%E6%8C%91%E6%88%98/"/>
    
    
      <category term="算法挑战" scheme="http://suzhouxing.github.io/techive/tags/%E7%AE%97%E6%B3%95%E6%8C%91%E6%88%98/"/>
    
      <category term="组合优化" scheme="http://suzhouxing.github.io/techive/tags/%E7%BB%84%E5%90%88%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>SmartLab Challenge 2020 - Graph Coloring</title>
    <link href="http://suzhouxing.github.io/techive/2020/12/09/Contest-2020GraphColoring/"/>
    <id>http://suzhouxing.github.io/techive/2020/12/09/Contest-2020GraphColoring/</id>
    <published>2020-12-09T02:28:35.000Z</published>
    <updated>2020-12-22T04:42:17.025Z</updated>
    
    <content type="html"><![CDATA[<p>图着色问题在众多领域中有广泛的应用, 可以用来对各种各样的组合优化问题进行建模. 图着色问题主要研究独占资源的分配问题. 比如在编译器给变量分配寄存器分配时, 如果两个变量的生命周期有交集, 则不能分配至同一寄存器. 比如在机场分配停机位时, 如果两架飞机的过站时间有交集, 则不能分配至同一停机位. 比如在光纤网络中进行波长分配时, 如果两条光路经过同一条链路, 则不能使用同一波长传输. 比如移动基站进行通讯频率分配时, 如果两个终端设备位于同一组天线的覆盖范围内, 则不能使用同一通讯频率. 比如在学校排课表时, 如果两个班级要上同一位教师的课, 则其上课时间不能相同. 高效的图着色问题求解算法具有及其重要的理论与应用价值.</p><h1 id="图着色算法训练">图着色算法训练</h1><h2 id="命令行参数">命令行参数</h2><p>请大家编写程序时支持四个命令行参数, 分别为算例文件路径, 输出解文件路径, 颜色数和随机种子. 后续我们可能会通过在控制台运行 <code>你的算法.exe 输入算例路径 输出解文件路径 颜色数 随机种子</code> 测试大家提交的算法, 例如: <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcp.exe ../DSJC500.5.col dsjc500.5.txt 48 123456</span><br></pre></td></tr></table></figure></p><ul><li>随机种子设置.<ul><li>使用 C 语言随机数生成器请用 <code>srand</code>.</li><li>使用 C++ 随机数生成器 (如 <code>mt19937</code>) 请在构造时传参或调用 <code>seed()</code> 方法设置.</li></ul></li><li>测试时可能会修改算例文件名，请勿针对文件名做特殊处理.</li></ul><h2 id="输入的算例文件格式">输入的算例文件格式</h2><p>DIMACS 图着色算例格式. 建议读取算例时不要根据开头给出的边数进行相关数据的初始化, 而是根据是否已经读到文件末尾自动判断.</p><h2 id="输出的解文件格式">输出的解文件格式</h2><p>对于 N 个节点的算例, 输出 N 行. 每一行输出用空格分隔的两个数字, 分别表示算例中的节点编号以及为该节点分配的颜色.</p><p>颜色可以取 <code>int</code> 范围内任意整数, 检查程序自动统计不同的整数的数量.</p><p>例如, 以下解文件表示 1 号节点染颜色 0, 2 号节点染颜色 2, 3 号节点染颜色 1: <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1 0 </span><br><span class="line">2 2 </span><br><span class="line">3 1</span><br></pre></td></tr></table></figure></p><h2 id="提交要求">提交要求</h2><ul><li>发送至邮箱 <a href="mailto:su.zhouxing@qq.com" target="_blank" rel="noopener">su.zhouxing@qq.com</a>.</li><li>邮件标题格式为 &quot;Challenge2020GCP-姓名-班级&quot;.</li><li>邮件附件为单个压缩包, 文件名为 &quot;姓名-班级&quot;, 其内包含下列文件.<ul><li>算法的可执行文件.</li><li>算法源码.</li><li>算法在各算例上的运行情况概要, 至少包括以下几项信息.<ul><li>算例名.</li><li>颜色数.</li><li>计算耗时.</li></ul></li><li>算法在各算例上求得的颜色数最少的解文件.</li></ul></li></ul><h2 id="检查程序">检查程序</h2><p>我们可能会使用以下 c# 程序检查大家提交的算法和结果 (仅供参考).</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> System.IO;</span><br><span class="line"><span class="keyword">using</span> System.Linq;</span><br><span class="line"><span class="keyword">using</span> System.Text;</span><br><span class="line"><span class="keyword">using</span> System.Diagnostics;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">GcpBenchmark</span> &#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span> &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">string</span> inputFilePath = args[<span class="number">0</span>]; <span class="comment">// instance file.</span></span><br><span class="line">            <span class="keyword">string</span> outputFilePath = args[<span class="number">1</span>]; <span class="comment">// solution file.</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (args.Length &gt; <span class="number">3</span>) &#123;</span><br><span class="line">                <span class="keyword">string</span> exeFilePath = args[<span class="number">2</span>]; <span class="comment">// algorithm executable file.</span></span><br><span class="line">                <span class="keyword">string</span> colorNum = args[<span class="number">3</span>];</span><br><span class="line">                benchmark(inputFilePath, outputFilePath, exeFilePath, colorNum);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                check(inputFilePath, outputFilePath);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">struct</span> Edge &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">string</span> src;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">string</span> dst;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">check</span>(<span class="params"><span class="keyword">string</span> inputFilePath, <span class="keyword">string</span> outputFilePath</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> nodeNum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> edgeNum = <span class="number">0</span>;</span><br><span class="line">            List&lt;Edge&gt; edges = <span class="keyword">new</span> List&lt;Edge&gt;();</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">string</span>[] lines = File.ReadAllLines(inputFilePath);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">foreach</span> (<span class="keyword">string</span> line <span class="keyword">in</span> lines) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (line.Length &lt;= <span class="number">0</span>) &#123; <span class="keyword">continue</span>; &#125;</span><br><span class="line">                    <span class="keyword">if</span> (line[<span class="number">0</span>] == <span class="string">'c'</span>) &#123; <span class="keyword">continue</span>; &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">string</span>[] cells = line.Split(<span class="string">' '</span>);</span><br><span class="line">                    <span class="keyword">if</span> (line[<span class="number">0</span>] == <span class="string">'p'</span>) &#123;</span><br><span class="line">                        nodeNum = <span class="keyword">int</span>.Parse(cells[<span class="number">2</span>]);</span><br><span class="line">                        edgeNum = <span class="keyword">int</span>.Parse(cells[<span class="number">3</span>]);</span><br><span class="line">                        edges.Capacity = edgeNum;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (line[<span class="number">0</span>] == <span class="string">'e'</span>) &#123;</span><br><span class="line">                        edges.Add(<span class="keyword">new</span> Edge &#123; src = cells[<span class="number">1</span>], dst = cells[<span class="number">2</span>] &#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            HashSet&lt;<span class="keyword">string</span>&gt; colors = <span class="keyword">new</span> HashSet&lt;<span class="keyword">string</span>&gt;();</span><br><span class="line">            Dictionary&lt;<span class="keyword">string</span>, <span class="keyword">string</span>&gt; nodeColors = <span class="keyword">new</span> Dictionary&lt;<span class="keyword">string</span>, <span class="keyword">string</span>&gt;();</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">string</span>[] lines = File.ReadAllLines(outputFilePath);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">foreach</span> (<span class="keyword">string</span> line <span class="keyword">in</span> lines) &#123;</span><br><span class="line">                    <span class="keyword">string</span>[] cells = line.Split(<span class="string">' '</span>);</span><br><span class="line">                    nodeColors[cells[<span class="number">0</span>]] = cells[<span class="number">1</span>];</span><br><span class="line">                    colors.Add(cells[<span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> conflictNum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">foreach</span> (Edge edge <span class="keyword">in</span> edges) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nodeColors[edge.src] == nodeColors[edge.dst]) &#123; ++conflictNum; &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Console.Write(<span class="string">"instance="</span>);</span><br><span class="line">            Console.Write(Path.GetFileName(inputFilePath));</span><br><span class="line"></span><br><span class="line">            Console.Write(<span class="string">" color="</span>);</span><br><span class="line">            Console.Write(colors.Count);</span><br><span class="line"></span><br><span class="line">            Console.Write(<span class="string">" conflict="</span>);</span><br><span class="line">            Console.WriteLine(conflictNum);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">benchmark</span>(<span class="params"><span class="keyword">string</span> inputFilePath, <span class="keyword">string</span> outputFilePath, <span class="keyword">string</span> exeFilePath, <span class="keyword">string</span> colorNum</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">int</span> Repeat = <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">int</span> MillisecondTimeLimit = <span class="number">10</span> * <span class="number">60</span> * <span class="number">1000</span>;</span><br><span class="line">            IntPtr ByteMemoryLimit = <span class="keyword">new</span> IntPtr(<span class="number">1024</span> * <span class="number">1024</span> * <span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Repeat; ++i) &#123;</span><br><span class="line">                <span class="keyword">int</span> seed = genSeed();</span><br><span class="line">                StringBuilder cmdArgs = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">                cmdArgs.Append(inputFilePath).Append(<span class="string">" "</span>).Append(outputFilePath)</span><br><span class="line">                    .Append(<span class="string">" "</span>).Append(colorNum).Append(<span class="string">" "</span>).Append(seed);</span><br><span class="line"></span><br><span class="line">                Stopwatch sw = <span class="keyword">new</span> Stopwatch();</span><br><span class="line">                sw.Start();</span><br><span class="line">                ProcessStartInfo psi = <span class="keyword">new</span> ProcessStartInfo();</span><br><span class="line">                psi.FileName = exeFilePath;</span><br><span class="line">                psi.WorkingDirectory = Environment.CurrentDirectory;</span><br><span class="line">                psi.Arguments = cmdArgs.ToString();</span><br><span class="line">                Process p = Process.Start(psi);</span><br><span class="line">                p.MaxWorkingSet = ByteMemoryLimit;</span><br><span class="line">                <span class="keyword">if</span> (!p.WaitForExit(MillisecondTimeLimit)) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123; p.Kill(); &#125; <span class="keyword">catch</span> (Exception) &#123; &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                sw.Stop();</span><br><span class="line"></span><br><span class="line">                Console.Write(<span class="string">"time="</span>);</span><br><span class="line">                Console.Write(sw.ElapsedMilliseconds / <span class="number">1000.0</span>);</span><br><span class="line">                Console.Write(<span class="string">"s seed="</span>);</span><br><span class="line">                Console.Write(seed);</span><br><span class="line">                Console.Write(<span class="string">" "</span>);</span><br><span class="line"></span><br><span class="line">                check(inputFilePath, outputFilePath);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">genSeed</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (<span class="keyword">int</span>)(DateTime.Now.Ticks &amp; <span class="number">0xffff</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;图着色问题在众多领域中有广泛的应用, 可以用来对各种各样的组合优化问题进行建模. 图着色问题主要研究独占资源的分配问题. 比如在编译器给变量分配寄存器分配时, 如果两个变量的生命周期有交集, 则不能分配至同一寄存器. 比如在机场分配停机位时, 如果两架飞机的过站时间有交集,
      
    
    </summary>
    
      <category term="算法挑战" scheme="http://suzhouxing.github.io/techive/categories/%E7%AE%97%E6%B3%95%E6%8C%91%E6%88%98/"/>
    
    
      <category term="算法挑战" scheme="http://suzhouxing.github.io/techive/tags/%E7%AE%97%E6%B3%95%E6%8C%91%E6%88%98/"/>
    
      <category term="组合优化" scheme="http://suzhouxing.github.io/techive/tags/%E7%BB%84%E5%90%88%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>用 Gitea 搭建自己的 Git 服务器</title>
    <link href="http://suzhouxing.github.io/techive/2019/10/17/SetupGitServerWithGitea/"/>
    <id>http://suzhouxing.github.io/techive/2019/10/17/SetupGitServerWithGitea/</id>
    <published>2019-10-17T06:18:36.000Z</published>
    <updated>2019-10-17T09:06:06.683Z</updated>
    
    <content type="html"><![CDATA[<p>在永恒之蓝等通过网络文件共享传播的病毒肆虐之后, 很多网络供应商都封禁了文件共享相关端口, 以至于无法简单地通过映射网络驱动器来搭建 Git 的远端仓库, 然后使用 &quot;哑协议&quot; 执行 clone, push, pull 等操作. 因此, 我们可能需要使用支持 http 或者 ssh 的 Git 服务器. 目前功能最强大的免费 Git 服务器为 <a href="https://about.gitlab.com/install/" target="_blank" rel="noopener">Gitlab</a>, 它可以让用户自己搭建与 https://github.com 或者 https://gitlab.com 一样的网站. 但 Gitlab 不支持免费用于商业用途. 此外, 同类开源或免费软件还有 <a href="https://bonobogitserver.com/" target="_blank" rel="noopener">Bonobo</a>, <a href="https://gogs.io/" target="_blank" rel="noopener">Gogs</a>, <a href="https://www.scm-manager.org/" target="_blank" rel="noopener">SCM-Manager</a>, <a href="http://gitblit.com/" target="_blank" rel="noopener">Gitblit</a> 等.</p><h1 id="windows-环境下操作步骤">Windows 环境下操作步骤</h1><h2 id="第三方库依赖">第三方库依赖</h2><ol type="1"><li>安装 Git<ol type="1"><li>在<a href="https://git-scm.com/" target="_blank" rel="noopener">官方网站</a>下载最新版安装包</li><li>双击运行安装包按照安装向导的提示点下一步即可</li></ol></li></ol><h2 id="基本流程">基本流程</h2><ol type="1"><li>在<a href="https://gitea.io" target="_blank" rel="noopener">官方网站</a>或者 <a href="https://github.com/go-gitea/gitea/releases" target="_blank" rel="noopener">Github 的 release 页面</a>下载最新版本<ul><li>截至本文发布时最新版本为 <code>gitea-1.9.4-windows-4.0-amd64.exe</code></li></ul></li><li><p>将下载的文件重命名为 <code>gitea.exe</code> 并移动至任意目录下 (本文后续将使用 <code>C:\YOUR\INSTALL\PATH</code> 作为安装目录, 读者请根据自己的情况将其替换为实际的路径)</p></li><li>以管理员身份打开命令行, 执行以下命令添加 Gitea 为 Windows 服务 <code>sc create gitea start= auto binPath= &quot;&quot;C:\YOUR\INSTALL\PATH\gitea.exe&quot; web --config &quot;C:\YOUR\INSTALL\PATH\custom\conf\app.ini&quot;&quot;</code><ul><li>详情请见 https://docs.gitea.io/zh-cn/windows-service/</li><li>在 PowerShell 中执行上述命令可能会失败, 需要使用经典的 cmd</li><li>假设使用的管理员账号为 <code>admin</code>, 密码为 <code>123</code>, 后面其他地方要用时最好保持一致</li></ul></li><li>如果该服务未自动启动, 在 Windows 的服务列表中找到 <code>gitea</code> 并启动<ol type="1"><li>以管理员身份打开服务列表<ul><li>开始按钮上点右键 -&gt; 计算机管理 -&gt; 服务和应用程序 -&gt; 服务</li><li>Ctrl+Shift+Esc 打开任务管理器 -&gt; 服务 -&gt; 打开服务</li><li>控制面板 -&gt; 系统和安全 -&gt; 管理工具 -&gt; 服务</li></ul></li><li>建议在 <code>gitea</code> 服务上点右键 -&gt; 属性 -&gt; 登陆 -&gt; 此账户, 设置账户为之前使用的管理员账户 <code>admin</code>, 然后重启服务</li></ol></li><li>在浏览器中访问默认的地址 <code>http://localhost:3000</code> 打开网页端, 点击注册按钮<ol type="1"><li>第一次点击注册时将进入初始配置页面<ol type="1"><li>数据库推荐选择 SQLite3, 数据库路径建议使用默认的安装目录下的子目录</li><li><code>站点名称</code> 随便填</li><li><code>仓库根目录</code> 建议更改至安装目录下, 例如 <code>C:\YOUR\INSTALL\PATH\data\repo</code></li><li><code>以用户名运行</code> 建议使用上面用过的管理员账号 <code>admin</code></li><li>把 <code>SSH 服务域名</code> 和 <code>Gitea 基本 URL</code> 中的 <code>localhost</code> 替换为服务器的 IP 地址或域名</li><li>端口根据个人偏好设置, 设为 80 的话以后的仓库链接可以省略端口号, 但是有和其他 web 服务冲突的可能性, 建议使用默认端口</li><li>可选设置中的 <code>管理员账号设置</code> 为 Gitea 网页端的管理员, 不是操作系统的管理员, 如果此时不设置则第一个注册的用户将自动成为管理员</li></ol></li><li>再次点击注册, 完成用户注册</li></ol></li></ol><h2 id="疑难解答">疑难解答</h2><ol type="1"><li>更改配置<ol type="1"><li>在 <code>C:\YOUR\INSTALL\PATH\custom\conf\app.ini</code> 文件中修改相关项目<ul><li>网页端地址或者代码仓库地址前缀: <code>ROOT_URL</code>, <code>DOMAIN</code>, <code>SSH_DOMAIN</code></li><li>端口: <code>HTTP_PORT</code>, <code>SSH_PORT</code></li></ul></li><li>参考资料<ul><li>https://docs.gitea.io/zh-cn/customizing-gitea/</li><li>https://docs.gitea.io/zh-cn/config-cheat-sheet/</li><li>https://github.com/go-gitea/gitea/blob/master/custom/conf/app.ini.sample</li></ul></li></ol></li><li>局域网或者互联网上其他机器无法访问网页端<ol type="1"><li>添加防火墙放行规则<ol type="1"><li>控制面板 -&gt; 系统和安全 -&gt; Windows Defender 防火墙 -&gt; 允许应用或功能通过 Windows Defender 防火墙 -&gt; 更改设置 -&gt; 允许其他应用 -&gt; 浏览 -&gt; 选中 <code>C:\YOUR\INSTALL\PATH\gitea.exe</code> -&gt; 网络类型 -&gt; 确保公用和专用均被勾选</li></ol></li><li>更换端口</li><li>咨询单位网管或互联网服务提供商</li></ol></li><li>初始化设置时无法创建数据库<ol type="1"><li>设置 <code>gitea</code> 服务以管理员账号启动</li><li>安装 SQLite3<ol type="1"><li>从<a href="https://sqlite.org" target="_blank" rel="noopener">官方网站</a>下载 SQLite3<ul><li>截至本文发布时最新版本为 <code>sqlite-dll-win64-x64-3300100.zip</code></li></ul></li><li>将压缩包内的文件解压至任意目录下<ul><li>本文后续将使用 <code>C:\SQLITE3\INSTALL\PATH</code> 作为安装目录, 读者请根据自己的情况将其替换为实际的路径</li></ul></li></ol></li><li>在环境变量 <code>Path</code> 中添加安装目录<ol type="1"><li>控制面板 -&gt; 系统和安全 -&gt; 系统 -&gt; 高级系统设置 -&gt; 环境变量 -&gt; 系统变量 -&gt; 双击变量 <code>Path</code></li><li>新建一行 <code>C:\SQLITE3\INSTALL\PATH</code> 或者在变量值字符串开头添加 <code>C:\SQLITE3\INSTALL\PATH;</code></li></ol></li></ol></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在永恒之蓝等通过网络文件共享传播的病毒肆虐之后, 很多网络供应商都封禁了文件共享相关端口, 以至于无法简单地通过映射网络驱动器来搭建 Git 的远端仓库, 然后使用 &amp;quot;哑协议&amp;quot; 执行 clone, push, pull 等操作. 因此, 我们可能需要使用
      
    
    </summary>
    
      <category term="技术" scheme="http://suzhouxing.github.io/techive/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="技术" scheme="http://suzhouxing.github.io/techive/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="Git" scheme="http://suzhouxing.github.io/techive/tags/Git/"/>
    
      <category term="Gitea" scheme="http://suzhouxing.github.io/techive/tags/Gitea/"/>
    
  </entry>
  
  <entry>
    <title>组合优化 (五) 数学规划进阶</title>
    <link href="http://suzhouxing.github.io/techive/2019/01/13/Opt-AdvancedMathematicalProgramming/"/>
    <id>http://suzhouxing.github.io/techive/2019/01/13/Opt-AdvancedMathematicalProgramming/</id>
    <published>2019-01-13T03:14:59.000Z</published>
    <updated>2019-10-22T06:06:32.205Z</updated>
    
    <content type="html"><![CDATA[<p>虽然目前最顶尖的商业求解器已经非常高效, 直接求解完整的问题模型往往比普通人自己实现算法性能更好, 但是面对特定的问题, 仍然有改进空间. 另一方面, 先贤们告诉我们要站在巨人的肩膀上, 要重用前人的优秀成果. 于是, 我们可以得到一个在完全自行设计算法和完全使用通用求解器之间的折中的方案, 发挥多种方法各自的优势, 更好地解决问题.</p><h1 id="线性规划与混合整数规划-进阶技巧">线性规划与混合整数规划 (进阶技巧)</h1><h2 id="非线性表达式">非线性表达式</h2><ul><li>可以转化为线性表达式的非线性表达式<ul><li>最大值最小值</li><li>绝对值</li><li>分段线性函数</li><li>...</li></ul></li><li>可以较高效求解的非线性表达式<ul><li>Quadratic Program (QP)</li><li>Special Ordered Set (SOS)</li><li>Mixed Integer Program (MIP)</li><li>...</li></ul></li></ul><p>详见 <a href="https://github.com/HUST-Smart/Training/blob/master/%5B1.5%5D%20%E7%BA%BF%E6%80%A7%E5%8C%96%E9%9D%9E%E7%BA%BF%E6%80%A7%E8%A1%A8%E8%BE%BE%E5%BC%8F.docx" target="_blank" rel="noopener">[1.5] 线性化非线性表达式.docx</a>.</p><h3 id="最小化最大值">最小化最大值</h3><ul><li>使用一个辅助变量限制决策变量的界</li><li>约束的可行区域应与优化方向 &quot;相反&quot;<ul><li>最小化一个表达式 <span class="math inline">\(l = f(x)\)</span>, 应该确定 <span class="math inline">\(l\)</span> 的下界, 即 <span class="math inline">\(g(x) \le l \le +\infty\)</span></li><li>最大化一个表达式 <span class="math inline">\(u = f(x)\)</span>, 如果只约束其下界, 将导致目标无限增大</li></ul></li></ul><h3 id="最小化最小值">最小化最小值</h3><ul><li>最小值的下界? 让较大的值都可以忽略</li><li>Big-M (充分大的 M)</li></ul><h3 id="课堂练习">课堂练习</h3><ul><li>最大化最大值?</li><li>最大化绝对值?</li></ul><h2 id="多目标">多目标</h2><ul><li>线性加权模式<ul><li>简单, 本质上就是单目标</li><li>各目标量纲不同时难以确定权重系数</li></ul></li><li>优先级模式<ul><li>高优先级对低优先级有压倒性优势</li><li>高优先级目标有一定的绝对/相对容差范围</li></ul></li></ul><h3 id="实现优先级模式">实现优先级模式</h3><ul><li>使用线性加权模式模拟<ul><li>难以确定各目标的取值范围以形成隔离</li><li>目标过多容易溢出或者产生巨大的数值误差</li></ul></li><li>迭代求解<ul><li>按优先级逐个优化</li><li>每个目标算到最优解后根据容差范围添加约束限制目标函数的取值</li><li>求解性能依赖热启动 (warm start) 效果</li></ul></li></ul><h2 id="约束类型">约束类型</h2><table><thead><tr class="header"><th>类型</th><th>特征</th><th>最优性</th><th>完整性</th><th>检查时间</th><th>被忽略</th></tr></thead><tbody><tr class="odd"><td>user cut</td><td>排除显然不可能最优的解向量</td><td>不改变最优解</td><td>不影响模型的完整性</td><td>可能在任意时刻被检查</td><td>可能</td></tr><tr class="even"><td>lazy constraint</td><td>最优解不太可能违反的约束</td><td>会改变最优解</td><td>影响模型的完整性</td><td>仅在找到解时才被检查</td><td>不会</td></tr><tr class="odd"><td>constraint</td><td>容易与优化目标产生冲突的约束</td><td>会改变最优解</td><td>影响模型的完整性</td><td>在任意时刻都会被检查</td><td>不会</td></tr></tbody></table><p>注: 在 MIP 中, 整数解才是原始问题的解, 故在找到松弛的实数解时不会触发惰性约束.</p><p>以下为 CPLEX 对惰性约束和用户割平面的介绍:</p><blockquote><p>In contrast to the cuts that IBM ILOG CPLEX may automatically add while solving a problem, user cuts are those cuts that a user defines based on information already implied about the problem by the constraints; user cuts may not be strictly necessary to the problem, but they tighten the model. Lazy constraints are constraints that the user knows are unlikely to be violated, and in consequence, the user wants them applied lazily, that is, only as necessary or not before needed. User cuts can be grouped together in a pool of user cuts. Likewise, lazy constraints can also be grouped into a pool of lazy constraints.</p><p>Cuts may resemble ordinary constraints, but are conventionally defined to mean those which can change the feasible space of the continuous relaxation but do not rule out any feasible integer solution that the rest of the model permits. A collection of cuts, therefore, involves an element of freedom: whether or not to apply them, individually or collectively, during the optimization of a MIP model; the formulation of the model remains correct whether or not the cuts are included. This degree of freedom means that if valid and necessary constraints are mis-identified by the user and passed to CPLEX as user cuts, unpredictable and possibly incorrect results could occur.</p><p>By contrast, lazy constraints represent simply one portion of the constraint set, and the model would be incomplete (and possibly would deliver incorrect answers) in their absence. CPLEX always makes sure that lazy constraints are satisfied before producing any solution to a MIP model. Needed lazy constraints are also kept in effect after the MIP optimization terminates, for example, when you change the problem type to fixed-integer and re-optimize with a continuous optimizer.</p><p>Another important difference between pools of user cuts and pools of lazy constraints lies in the timing by which these pools are applied. CPLEX may check user cuts for violation and apply them at any stage of the optimization. Conversely, it does not guarantee to check them at the time an integer-feasible solution candidate has been identified. Lazy constraints are only (and always) checked when an integer-feasible solution candidate has been identified, and of course, any of these constraints that turn out to be violated will then be applied to the full model.</p><p>Cuts that are based on <strong>optimality</strong> and that <strong>remove</strong> integer feasible solutions without removing all optimal solutions are known as <strong>optimality-based cuts</strong>. Optimality-based cuts do not fit the definition of either a user cut nor a lazy constraint. For example, <strong>symmetry-breaking constraints</strong> are sometimes known as optimality-based cuts because symmetry-breaking constraints can remove integer feasible solutions without removing all optimal solutions. Symmetry-breaking constraints are <strong>not</strong> user cuts in the sense addressed here. Symmetry-breaking constraints are not necessarily lazy constraints either. However, CPLEX can support optimality-based cuts as lazy constraints. If you add an optimality-based cut as a lazy constraint in your model, you can also add it to the user cut pool. This practice of adding an optimality-based cut as a lazy constraint and simultaneously adding it to the user cut pool makes sure that CPLEX checks the optimality-based cut at each node relaxation as well as when CPLEX finds an integer feasible solution.</p><p>Another way of comparing these two types of pools is to note that the user designates constraints as lazy in the strong hope and expectation that they will not need to be applied, thus saving computation time by their absence from the working problem. In practice, it is relatively costly (for a variety of reasons) to apply a lazy constraint after a violation is identified, and so the user should err on the side of caution when deciding whether a constraint should be marked as lazy. In contrast, user cuts may be more liberally added to a model because CPLEX is not obligated to use any of them and can apply its own rules to govern their efficient use.</p></blockquote><p>user cut 与约束编程 (Constraint Programming) 中的 surrogate constraints 功能类似:</p><blockquote><p>Since constraint propagation decreases the size of the search space by reducing the domains of variables, it is obviously important to express all necessary constraints. In some cases, it is even a good idea to introduce implicit constraints to reduce the size of the search space by supplementary propagation. Processing supplementary constraints inevitably slows down execution. However, this slowing down may be negligible in certain problems when it is compared with the efficiency gained from reducing the size of the search space.</p><p>A surrogate constraint makes explicit a property that satisfies a solution implicitly. Such a constraint should not change the nature of the solution, but its propagation should delimit the general shape of the solution more quickly. Of course, there is no need to express grossly obvious redundant constraints since the highly optimized algorithms that CP Optimizer uses to insure arc consistency already work well enough. For example, given this system of equations: <span class="math inline">\(x = y + z\)</span> <span class="math inline">\(z = a + b\)</span> no efficiency whatsoever is gained by adding this constraint: <span class="math inline">\(x = y + a + b\)</span> However, in any case where an implicit property makes good sense, or derives from experience, or satisfies formal computations, its explicit implementation as a surrogate constraint can be beneficial.</p><p>Consider the problem of the magic sequence. Assume that there are n+1 unknowns, namely, <span class="math inline">\(x_0, x_1, . . . , x_n\)</span>. These <span class="math inline">\(x_i\)</span> must respect the following constraints: 0 appears <span class="math inline">\(x_0\)</span> times in the solution. 1 appears <span class="math inline">\(x_1\)</span> times. In general, <span class="math inline">\(i\)</span> appears <span class="math inline">\(x_i\)</span> times. <span class="math inline">\(n\)</span> appears <span class="math inline">\(x_n\)</span> times. The constraint of this problem can easily be written, using the specialized distribute constraint. However, the search for a solution can be greatly accelerated by introducing the following surrogate constraint that expresses the fact that <span class="math inline">\(n+1\)</span> numbers are counted. <span class="math inline">\(1*x_1 + 2*x_2 + . . . + n*x_n = n+1\)</span>.</p></blockquote><h2 id="列生成-column-generation">列生成 (Column Generation)</h2><p>如果说 TSP 中经典的子回路消除 (割平面法) 是一种逐步添加惰性约束的 &quot;行生成&quot; 算法, 那么其对偶算法就是逐步添加决策变量的 &quot;列生成&quot; 算法. 前者适用于原始问题约束非常多, 但是真正对限制最优解的取值发挥作用的重要约束很少的情况; 后者则恰好相反, 适用于决策变量非常多, 但大多数决策变量的子集的取值组合不可能出现在最优解中的情况.</p><h3 id="原理">原理</h3><p>给定主问题及其对偶问题的线性规划模型 <span class="math display">\[\begin{align}\min &amp;  &amp; \mathbf{c}^{T} \mathbf{x}            &amp; &amp;                 &amp; &amp; \max &amp;  &amp; \mathbf{y}^{T} \mathbf{b}\\s.t. &amp;  &amp; \mathbf{A} \mathbf{x} \ge \mathbf{b} &amp; &amp; \Leftrightarrow &amp; &amp; s.t. &amp;  &amp; \mathbf{y}^{T} \mathbf{A} \le \mathbf{c}^{T}\\     &amp;  &amp; \mathbf{x} \ge \mathbf{0}            &amp; &amp;                 &amp; &amp;      &amp;  &amp; \mathbf{y} \ge \mathbf{0}\end{align}\]</span></p><p>令 <span class="math inline">\(\mathbf{x}^{T} = [\mathbf{x}^{T}_{B}, \mathbf{x}^{T}_{N}]\)</span>, 其中 <span class="math inline">\(\mathbf{x}_{B}\)</span> 表示基向量, <span class="math inline">\(\mathbf{x}_{N}\)</span> 表示非基变量. 对应地, <span class="math inline">\(\mathbf{A} = [\mathbf{B}, \mathbf{N}]\)</span>, <span class="math inline">\(\mathbf{c} = [\mathbf{c}_{B}, \mathbf{c}_{N}]\)</span>.</p><p>对约束进行如下等价变换 <span class="math display">\[\mathbf{A} \mathbf{x} \ge \mathbf{b} ~~\Leftrightarrow~~ \mathbf{B} \mathbf{x}_{B} + \mathbf{N} \mathbf{x}_{N} \ge \mathbf{b} ~~\Leftrightarrow~~ \mathbf{x}_{B} \ge \mathbf{B}^{-1} \mathbf{b} - \mathbf{B}^{-1} \mathbf{N} \mathbf{x}_{N}\]</span></p><p>将上式代入目标函数 <span class="math display">\[\mathbf{c}^{T} \mathbf{x} ~~=~~ \mathbf{c}^{T}_{B} \mathbf{x}_{B} + \mathbf{c}^{T}_{N} \mathbf{x}_{N} ~~\ge~~ \mathbf{c}^{T}_{B} (\mathbf{B}^{-1} \mathbf{b} - \mathbf{B}^{-1} \mathbf{N} \mathbf{x}_{N}) + \mathbf{c}^{T}_{N} \mathbf{x}_{N} ~~=~~ \mathbf{c}^{T}_{B} \mathbf{B}^{-1} \mathbf{b} + (\mathbf{c}^{T}_{N} - \mathbf{c}^{T}_{B} \mathbf{B}^{-1} \mathbf{N}) \mathbf{x}_{N}\]</span></p><p>定义目标函数中非基变量的系数 Reduced Cost 为 <span class="math display">\[\mathbf{r} = \mathbf{c}^{T}_{N} - \mathbf{c}^{T}_{B} \mathbf{B}^{-1} \mathbf{N}\]</span></p><p>若 <span class="math inline">\(\exist \mathbf{N}_{i} \in \mathbf{N}\)</span> 满足 <span class="math inline">\(\mathbf{r}_{i} &lt; 0\)</span>, 则可通过增加非基变量 <span class="math inline">\(\mathbf{x}_{i}\)</span> 的值实现降低目标函数值. 若不存在这样的项, 即 <span class="math inline">\(\forall \mathbf{N}_{i} \in \mathbf{N}, \mathbf{c}^{T}_{i} - \mathbf{c}^{T}_{B} \mathbf{B}^{-1} \mathbf{N}_{i} \ge 0\)</span>, 则 <span class="math inline">\([\mathbf{x}_{B}, \mathbf{0}]\)</span> 为最优解.</p><p>由 Complementary Slackness 定理可知 <span class="math inline">\(\mathbf{y}^{T} = \mathbf{c}^{T}_{B} \mathbf{B}^{-1}\)</span>, 由此可得 <span class="math inline">\(\mathbf{r} = \mathbf{c}^{T}_{N} - \mathbf{y}^{T} \mathbf{N}\)</span>. 则寻找可最大程度改进当前解的非基变量的子问题目标函数为 <span class="math inline">\(\min \mathbf{c}^{T}_{N} - \mathbf{y}^{T} \mathbf{N}\)</span>.</p><p><span class="math inline">\(~~~~\)</span></p><p><em>(本节内容基于 https://zhuanlan.zhihu.com/p/55424545 整理)</em></p><blockquote><p>附: Complementary Slackness 定理证明过程 (可能有问题): 令 <span class="math inline">\(\mathbf{y}^{T} = \mathbf{c}^{T}_{B} \mathbf{B}^{-1}\)</span>, 对于限制主问题的最优解 <span class="math inline">\(\mathbf{x}\)</span>, 有 <span class="math inline">\(\mathbf{x}_{N} = \mathbf{0}\)</span>, 以及 <span class="math inline">\(\mathbf{c}^{T}_{B} \mathbf{B}^{-1} \mathbf{N} \le \mathbf{c}^{T}_{N}\)</span>, 可得 <span class="math display">\[\mathbf{y}^{T} \mathbf{A} ~~=~~ \mathbf{c}^{T}_{B} \mathbf{B}^{-1} \mathbf{A} ~~=~~ \mathbf{c}^{T}_{B} \mathbf{B}^{-1} [\mathbf{B}, \mathbf{N}] ~~=~~ [\mathbf{c}^{T}_{B}, \mathbf{c}^{T}_{B} \mathbf{B}^{-1} \mathbf{N}] ~~\le~~ [\mathbf{c}^{T}_{B}, \mathbf{c}^{T}_{N}] ~~=~~ \mathbf{c}^{T}\]</span> <span class="math display">\[\mathbf{y}^{T} \mathbf{b} ~~=~~ \mathbf{c}^{T}_{B} \mathbf{B}^{-1} \mathbf{b} ~~=~~ \mathbf{c}^{T}_{B} \mathbf{x}_{B} ~~=~~ \mathbf{c}^{T} \mathbf{x}\]</span> 即 <span class="math inline">\(\mathbf{y}^{T}\)</span> 为限制对偶问题的最优解.</p></blockquote><h2 id="线性分数规划-linear-fractional-programming">线性分数规划 (Linear-Fractional Programming)</h2><p>目标函数为分数形式. 可以转换成线性规划.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;虽然目前最顶尖的商业求解器已经非常高效, 直接求解完整的问题模型往往比普通人自己实现算法性能更好, 但是面对特定的问题, 仍然有改进空间. 另一方面, 先贤们告诉我们要站在巨人的肩膀上, 要重用前人的优秀成果. 于是, 我们可以得到一个在完全自行设计算法和完全使用通用求解器
      
    
    </summary>
    
      <category term="技术" scheme="http://suzhouxing.github.io/techive/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="技术" scheme="http://suzhouxing.github.io/techive/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="建模" scheme="http://suzhouxing.github.io/techive/tags/%E5%BB%BA%E6%A8%A1/"/>
    
      <category term="优化" scheme="http://suzhouxing.github.io/techive/tags/%E4%BC%98%E5%8C%96/"/>
    
      <category term="数学" scheme="http://suzhouxing.github.io/techive/tags/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>组合优化 (四) 算法工程</title>
    <link href="http://suzhouxing.github.io/techive/2019/01/13/Opt-SoftwareEngineering/"/>
    <id>http://suzhouxing.github.io/techive/2019/01/13/Opt-SoftwareEngineering/</id>
    <published>2019-01-13T03:14:16.000Z</published>
    <updated>2019-10-22T06:07:46.645Z</updated>
    
    <content type="html"><![CDATA[<p>算法研发和常规软件开发十分相似, 但也有很多区别. 大多数工程项目往往更注重正确性, 为了提升代码的健壮性与可维护性, 可以适当牺牲性能. 而设计精妙的高效而复杂算法代码往往具有极高的耦合度, 难以进行系统的单元测试. 此外, 算法面临的需求往往不那么简单直接, 不是梳理清楚了业务逻辑就能欢快地敲代码了的. 算法研发真的这么任性吗?</p><h1 id="软件工程">软件工程</h1><h2 id="文档">文档</h2><ul><li>需求分析<ul><li>相关技术调研</li><li>自然语言描述</li><li>基本概念定义</li><li>建模四要素</li><li>输入输出数据约定</li></ul></li><li>用户手册<ul><li>概要设计</li><li>接口定义</li><li>功能覆盖</li></ul></li><li>算法设计<ul><li>技术规范</li><li>模块划分</li><li>处理流程</li></ul></li><li>测试分析<ul><li>测试环境</li><li>测试用例</li><li>测试结果</li><li>正确性分析</li><li>优度分析</li><li>速度分析</li></ul></li></ul><h2 id="算例设计">算例设计</h2><ul><li>格式要求<ul><li>自文档</li><li>跨平台</li><li>推荐格式: protobuf, json</li></ul></li><li>结构和规模可控<ul><li>拓扑设计<ul><li>特殊结构: 树形, 窄总线型, 宽总线型, 关键节点, 局部密度高整体密度低, 有向无环图</li><li>部分边权重特别大 (出现整数上溢)</li></ul></li></ul></li></ul><h1 id="算法工程">算法工程</h1><h2 id="相关工具">相关工具</h2><h3 id="版本控制工具">版本控制工具</h3><ul><li>git (主流)</li><li>svn</li><li>mercurial</li></ul><h3 id="适合与版本控制工具配合使用的文档撰写工具">适合与版本控制工具配合使用的文档撰写工具</h3><ul><li>Markdown<ul><li>一种功能非常精简的标记语言</li><li>https://guides.github.com/features/mastering-markdown/</li></ul></li><li>LaTeX<ul><li>功能强大的标记语言</li><li>同样适用于科技论文写作</li></ul></li></ul><h3 id="数学规划求解器----完成需求分析即完成项目">数学规划求解器 -- 完成需求分析即完成项目!</h3><ul><li><a href="http://www.gurobi.com/" target="_blank" rel="noopener">Gurobi</a><ul><li>目前最高效的求解器</li><li>支持免费学术许可证申请</li></ul></li><li><a href="https://www.ibm.com/software/commerce/optimization/cplex-optimizer/" target="_blank" rel="noopener">CPLEX</a><ul><li>IBM旗下的&quot;行业标准&quot;</li></ul></li><li><a href="http://scip.zib.de/" target="_blank" rel="noopener">SCIP</a><ul><li>号称最快的开源求解器</li></ul></li><li><a href="https://projects.coin-or.org/Cbc" target="_blank" rel="noopener">Coin-OR</a><ul><li>功能繁多的开源运筹学工具包</li></ul></li></ul><h2 id="开发">开发</h2><h3 id="代码可读性">代码可读性</h3><ul><li>使用版本控制减少被注释掉的代码 (文档性注释不受该要求影响)</li><li>使用有具体意义的单词作为标识符以减少臃肿的注释</li><li>使用自动排版工具调整代码格式</li><li>合理的功能模块划分和封装以避免过长的函数 (但是有时真的无法避免)</li></ul><h3 id="自动化测试">自动化测试</h3><ul><li>使用配置文件<ul><li>方案选择 (使用配置文件将导致代码过于臃肿时可以考虑预处理语句)</li><li>参数设置</li><li>算例选择</li><li>建议使用json文件格式</li></ul></li><li>自动批量测试<ul><li>计算结果合法性检验</li><li>计算结果目标函数值正确性检验</li><li>独立重复运行</li><li>多个算例</li><li>多个配置</li><li>多线程 (注意写同一个日志文件时应加入互斥机制)</li></ul></li><li>运行日志<ul><li>原始日志<ul><li>能够评价每次运行的时空开销与解的质量</li><li>能够还原求解过程和结果 (随机种子, 运行时间, 迭代次数, 宏开关状态, 参数设置...)</li><li>建议使用csv文件进行组织</li></ul></li><li>初步加工<ul><li>多阶段问题整合各阶段的数据得到整个周期的结果</li></ul></li><li>举例 <img src="RawLog.png" alt="Log"></li></ul></li><li>结果分析<ul><li>初步统计<ul><li>极值, 均值, 方差, 耗时...</li><li>ClosedXML编辑xlsx文件</li></ul></li><li>对比分析<ul><li>在所有算例上的综合评价方案/参数好坏的策略</li><li>Excel条件格式, 排序, Excel录制宏</li></ul></li><li>举例 <img src="Statistics.png" alt="Analysis"></li></ul></li></ul><h3 id="算法工程模块清单">算法工程模块清单</h3><ul><li>通用<ul><li>验证程序<ul><li>合法性</li><li>目标函数值计算正确</li></ul></li><li>日志记录</li><li>统计分析</li></ul></li><li>求解器<ul><li>数学模型</li><li>编程实现</li></ul></li><li>启发式<ul><li>初始解<ul><li>随机</li><li>贪心</li></ul></li><li>局部搜索<ul><li>邻域评估<ul><li>增量评估</li><li>邻域动作目标函数增量缓存</li><li>邻域动作优先队列</li></ul></li><li>邻域动作选择</li><li>邻域动作执行</li></ul></li><li>禁忌策略<ul><li>禁忌表</li><li>解禁策略</li></ul></li><li>扰动策略</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;算法研发和常规软件开发十分相似, 但也有很多区别. 大多数工程项目往往更注重正确性, 为了提升代码的健壮性与可维护性, 可以适当牺牲性能. 而设计精妙的高效而复杂算法代码往往具有极高的耦合度, 难以进行系统的单元测试. 此外, 算法面临的需求往往不那么简单直接, 不是梳理清
      
    
    </summary>
    
      <category term="技术" scheme="http://suzhouxing.github.io/techive/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="技术" scheme="http://suzhouxing.github.io/techive/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="软件工程" scheme="http://suzhouxing.github.io/techive/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>组合优化 (三) 算法简介</title>
    <link href="http://suzhouxing.github.io/techive/2019/01/13/Opt-AlgorithmDesign/"/>
    <id>http://suzhouxing.github.io/techive/2019/01/13/Opt-AlgorithmDesign/</id>
    <published>2019-01-13T03:13:02.000Z</published>
    <updated>2019-10-22T06:07:48.366Z</updated>
    
    <content type="html"><![CDATA[<p>由于生产实践中面临的绝大多数具有实际意义的组合优化问题都已经在理论上被证明属于难以使用可接受的计算资源在可接受的时间内求解的 NP-Hard 问题, 其求解算法不像 P 问题一样存在标准答案. 此外, 在实际的工业应用中, 由于未来的不确定性以及评价指标常常无法完美量化等问题, 耗费大量计算资源和时间精确求出最优解几乎没有实际意义. 所以, 组合优化算法的设计往往是在优度与速度之间寻找平衡点.</p><h1 id="算法设计">算法设计</h1><h2 id="预处理-preprocess">预处理 (Preprocess)</h2><ul><li>缩减问题规模 (Reduction)<ul><li>参考文献: <a href="https://doi.org/10.1145/990308.990309" target="_blank" rel="noopener">Polynomial-time data reduction for dominating set</a></li></ul></li><li>加载用户参数与算法默认参数</li><li>初始化辅助数据结构</li></ul><h2 id="精确算法-exact-algorithms">精确算法 (Exact Algorithms)</h2><ul><li>分支限界 (Branch and Bound)<ul><li>分支策略 (Branching)<ul><li>深度优先 (Depth-First Search)</li><li>广度优先 (Breadth-First Search)</li><li>优度优先 (Best-First Search)</li></ul></li><li>剪枝策略 (Pruning)<ul><li>可行性剪枝 (Feasibility Pruning)</li><li>上下界剪枝 (Bound Pruning)<ul><li>(最小化问题) 当前目标函数值 + 剩余部分下界 &lt; 上界</li><li>A* 算法实质上是该策略在特定问题上的一种高效实现</li></ul></li><li>支配性剪枝 (Dominance Pruning)<ul><li>动态规划实质上是将该策略发挥到了极致</li></ul></li><li>参考文献: <a href="https://doi.org/10.1016/j.cor.2012.07.008" target="_blank" rel="noopener">On an exact method for the constrained shortest path problem</a></li></ul></li></ul></li><li>线性规划与混合整数规划求解算法 (Mathematical Programming)<ul><li>单纯形法 (Simplex Method)</li><li>内点法 (Interior Point Method, Barrier Method)</li><li>分支切割/割平面法 (Branch and Cut, Cutting Plane Method)</li><li>分支定价/列生成 (Branch and Price, Column Generation)</li></ul></li><li>动态规划 (Dynamic Programming)<ul><li>递推函数 (Recursive Formulation)</li><li>重叠子问题/最优子结构 (Overlapping Subproblem, Optimal Substructure)</li></ul></li><li>其他经典算法<ul><li>最大流 (Maximum Flow)</li><li>最小费用流 (Minimum-Cost Flow)</li><li>完美匹配/最大匹配 (Perfect Matching, Maximum Matching, Assignment Problem)</li></ul></li><li>参考文献<ul><li>http://theory.stanford.edu/~amitp/GameProgramming/</li><li>https://www.redblobgames.com/pathfinding/a-star/introduction.html</li><li>https://www.redblobgames.com/pathfinding/a-star/implementation.html</li></ul></li></ul><h2 id="元启发式算法-metaheuristics">元启发式算法 (Metaheuristics)</h2><h3 id="概述">概述</h3><ul><li>分类<br><img src="MetaheuristicsClassification.png" alt="Classification"></li><li>基本思想<ul><li>在 系统地探索整个解空间 和 盲目地探索邻近的解空间 之间寻找平衡点</li><li>集中性 (Intensification) 与 疏散性 (Diversification) 的平衡<ul><li>也称为 探索 (Exploration) 与 利用 (Exploitation) 的平衡</li></ul></li><li>时空开销 (Complexity) 与 求解质量 (Quality) 的平衡</li></ul></li><li>邻域动作 (Neighborhood Move): 尝试对解向量做微小的改变<ul><li>在一次迭代中每一个决策变量都可以改变: 精确算法</li><li>在一次迭代中仅改变一个决策变量: 原子邻域动作</li><li>寻找两者的平衡点: 集中性与疏散性的平衡</li></ul></li><li>迭代禁忌搜索过程<br><img src="TS.png" alt="TS"><ul><li>使用贪心算法或随机生成一个初始解</li><li>每次从当前解移动到某个邻居解 (Neighboring Solution), 直至一定步数不能改进</li><li>然后进行扰动, 贪心或随机地对更改部分解向量, 重复上述过程</li></ul></li><li>元启发式算法框架<br><img src="Framework.png" alt="Framework"><ul><li>算法层为整个程序的框架, 比如迭代局部搜索, 遗传算法, 混合进化算法等. 算法层决定了使用那些搜索策略, 搜索策略之间以什么次序出现, 各搜索策略的初始解, 各搜索策略的停止策略参数控制 (停止条件), 整个算法的停止条件等.</li><li>搜索层是具体的搜索算法, 执行一次搜索会产生一条搜索路径 (Trajectory). 随机游走, 模拟退火, 局部搜索, 禁忌搜索等都是搜索层的组件. 从广义上来说, 构造初始解, 迭代局部搜索中的扰动过程, 遗传算法中的交叉算子都是搜索层的组件. 在搜索过程中, 要考虑的主要问题是每次迭代选择什么邻域结构进行探索, 以及决定停止搜索的策略. 比如TS的停止策略是一定步数未改进就停止, 而停止条件是一个特定的最大未改进步数具体取值.</li><li>邻域动作选择一般是搜索过程中对算法性能影响最大的模块. 它通过循环调用邻域动作评估层的组件对考虑范围之内的邻域动作对目标函数值的改变情况进行评估, 然后按照某种策略挑选其中的一个动作. 最常见的挑选策略有 首次改进 (First Improvement) 和 最优改进 (Best Improvement). 此外, 还可以有导向性地或者随机地在整个邻域中挑选一部分邻域动作进行评估.</li><li>邻域动作评估可以是结合特殊的数据结构进行增量评估或者全部重算. 在绝大多数情况下增量评估的速度会远快于全部重算.</li><li>邻域动作的执行比较简单, 主要有更新解向量, 更新辅助数据结构, 更新禁忌表, 更新缓存和更新历史最优解等操作. 其中更新历史最优主要是处理目标函数值相同的情况, 可以随机选择, 也可以设计辅助目标函数进行处理.</li></ul></li><li>邻域动作举例<ul><li>Boolean Satisfiability Problem (SAT)</li><li>Graph Coloring Problem</li><li>P-Center Problem</li><li>Personnel Scheduling Prblem</li><li>Traveling Salesman Problem</li></ul></li><li>常用算法<ul><li>提升算法 (Trajectory-Based Methods)<ul><li>迭代禁忌搜索</li><li>模拟退火 (类似 Epsilon-Greedy 策略)</li><li>拍卖算法/地貌调整/格局检测 (Auction Algorithm, Landscape Adjustment, Configuration Checking)<ul><li>提升反复出现的惩罚项在目标函数中的权重实现 &quot;软&quot; 禁忌<ul><li>例如图着色中令 反复出现的 或者 局部最优解中的 冲突边的计 1.01 条冲突边</li></ul></li></ul></li></ul></li><li>种群算法 (Population-Based Methods)<ul><li>混合进化算法/模因算法 (Hybrid Evolutionary Algorithm, Memetic Algorithm), 遗传算法 (Genetic Algorithm)</li><li>蚁群, 蜂群, 粒子群 (与强化学习十分相似)</li></ul></li></ul></li></ul><h3 id="初始解-initial-solution-generation">初始解 (Initial Solution Generation)</h3><ul><li>贪心 (Greedy)<ul><li>有利于快速收敛 (Fast Convergence)</li><li>不利于初始解的多样性</li></ul></li><li>随机 (Random)</li></ul><h3 id="禁忌搜索-tabu-search">禁忌搜索 (Tabu Search)</h3><ul><li>邻域结构 (Neighborhood Structure) 设计<ul><li>原子邻域动作<ul><li>添加, 删除, 更换, 交换, 移动, ...</li></ul></li><li>复合邻域动作<ul><li>块交换, 块移动</li><li>大邻域搜索 (Large Neighborhood Search)</li><li>弹射链 (Ejection Chain)</li></ul></li></ul></li><li>邻域评估 (Neighborhood Evaluation): 目标函数值改进量计算<ul><li>增量评估 (Incremental Evaluation): 因为仅对解向量做了微小的改变, 所以目标函数中大多数项目并未改变</li><li>邻域缓存 (Cache): 在邻域动作执行后, 大多数邻域动作与被改变的决策变量并不相关, 其增量无需重新计算, 故可以将其缓存起来<ul><li>主动更新 (Active Update): 每次执行邻域动作后更新所有相关动作的增量</li><li>惰性更新 (Lazy Update): 使用标记位记录缓存是否失效, 需要比较相关动作的增量时再更新<ul><li>启用了邻域精简或抽样策略时才有惰性更新的必要</li></ul></li></ul></li></ul></li><li>邻域动作选择策略<ul><li>单个邻域 (直接选择邻域动作)<ul><li>首次改进 (First Improvement)<ul><li>记录上一轮的评估进度直接从下一个动作开始, 循环评估所有动作</li><li>每次从随机位置开始依次评估所有邻域动作</li></ul></li><li>最大改进 (Best Improvement)<ul><li>多个目标函数增量相同的最优动作随机选择一个<ul><li>在线选择 (Online Selection): <a href="https://en.wikipedia.org/wiki/Reservoir_sampling" target="_blank" rel="noopener">水塘抽样 (Reservoir Sampling)</a></li></ul></li></ul></li><li>邻域精简/候选动作集 (Neiborhood Reduction, Candidate Set)<ul><li>根据特定策略筛选排除显然没有改进潜力的动作</li></ul></li><li>邻域近似评估 (Neihborhood Estimation, Approximate Evaluation)<ul><li>根据其他辅助指标快速对所有动作排序, 仅对排名靠前的若干动作进行精确评估</li></ul></li><li>邻域抽样 (Neighborhood Sampling)</li></ul></li><li>多邻域 (先选出邻域结构再选择动作)<ul><li>评估所有邻域的所有动作<ul><li>可以结合邻域抽样随机挑选部分动作</li></ul></li><li>变邻域搜索 (Variable Neighborhood Search)</li><li>根据适应性选择最合适的邻域<ul><li>根据历史改进情况调整各邻域权重, 然后采用轮盘赌 (Roulette Wheel) 选择其中一个</li></ul></li><li>等概率随机选择</li></ul></li><li>优先队列优化: 避免遍历整个邻域, 直接在 O(1) 时间内挑选最优动作<ul><li>一般使用桶队列 (Bucket Queue) 等基于基数排序 (Radix Sort) 的优先队列实现 (而非基于比较的树状优先队列)</li><li>往往与邻域缓存结合使用, 实现惰性更新优先队列中的键值对</li></ul></li></ul></li><li>禁忌策略<ul><li>禁忌表<ul><li>如果一个邻域动作被执行则禁止其<strong>逆操作</strong>在短时间内被选中<ul><li>刚增加则禁止马上被删除</li><li>刚交换防止马上被换回来</li></ul></li></ul></li><li>禁忌步长 (Tabu Tenure)<ul><li>可能与问题规模, 禁忌表大小, 目标函数值, 邻域动作出现次数相关</li><li>一般需要加上随机成分</li><li>具体实现时将禁忌多久转换为什么时候解禁</li></ul></li><li>解禁策略/特赦准则 (Aspiration Criteria)<ul><li>如果被禁忌的邻域动作是当前邻域的最优动作且能够改进历史最优解则允许其被执行</li></ul></li></ul></li></ul><h3 id="扰动-perturbation">扰动 (Perturbation)</h3><ul><li>重新构造初始解 (Random Restart)<ul><li>需要初始解生成程序具有一定的随机性</li><li>与之前的搜索完全无关, 无法利用已有的搜索结果</li></ul></li><li>贪心或随机地更改解向量中的部分元素</li><li>随机执行邻域动作 (Random Walk)</li><li>交叉算符 (Crossover Operator)<ul><li>将多个解向量中较优的子结构进行组合</li></ul></li></ul><h3 id="图着色禁忌搜索算法总结">图着色禁忌搜索算法总结</h3><ul><li>重新统计每个邻域动作的改进量代价太大<ul><li>改变一个节点的颜色在稀疏图上对整体格局影响很小 =&gt; 记录个节点各种颜色的相邻节点的数量 (即变成各种颜色引入的冲突数量)</li><li>使用新颜色相邻节点数减去旧颜色相邻节点数快速计算改进量</li></ul></li><li>每次遍历所有动作中挑选最优动作代价太大<ul><li>大多数动作显然不可能产生改进 =&gt; 仅评估有冲突的节点</li><li>使用优先队列每次直接取出最优动作<ul><li>非禁忌优先队列 + 禁忌优先队列 + 待解禁循环队列</li><li>使用相邻颜色表校验出队动作实现惰性更新优先队列</li></ul></li></ul></li></ul><h2 id="混合整数规划-mixed-integer-programming">混合整数规划 (Mixed-Integer Programming)</h2><ul><li>概述<ul><li>对于一组给定的自变量, 确定其取值, 使其在满足给定不等式组的前提下, 给定的函数取到最小值</li><li>决策变量的定义域可以是实数 (连续变量) 也可以是整数 (离散变量)</li></ul></li><li>编程范式与原理简介<ul><li>http://www.gurobi.com/resources/getting-started/lp-basics</li><li>http://www.gurobi.com/resources/getting-started/mip-basics</li></ul></li><li>不同的表现形式<ul><li>线形规划模型的标准形式<br><img src="LP1.png" alt="StdForm"></li><li>图形表示<br><img src="LP2.png" alt="GraphRep"></li><li>矩阵表示<br><img src="LP3.png" alt="MatrixRep"></li><li>使用方法<ul><li>使用专门的建模语言<ul><li>https://www.gurobi.com/documentation/6.5/refman/model_file_formats.html</li><li>举例: <a href="coins.lp">coin</a> &amp; <a href="qafiro.lp">qafiro</a></li></ul></li><li>使用命令行接口</li><li>使用应用程序接口<ul><li>添加决策变量</li><li>添加目标函数</li><li>添加约束</li><li>求解</li><li>获取决策变量取值</li></ul></li></ul></li></ul></li></ul><h2 id="贪心算法与近似算法-approximate-algorithm">贪心算法与近似算法 (Approximate Algorithm)</h2><ul><li>贪心算法可视为不回溯的优度优先搜索</li><li>近似算法是一类特殊的贪心算法<ul><li>近似比 (Approximation Ratio): 最坏情况下贪心解离最优解的差距</li></ul></li></ul><h2 id="算法运行模式对比">算法运行模式对比</h2><ul><li>树搜索<br><img src="TreeSearch.png" alt="TreeSearch"></li><li>动态规划<br><img src="DynamicProgramming.png" alt="DynamicProgramming"></li><li>局部搜索<br><img src="LocalSearch.png" alt="LocalSearch"></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;由于生产实践中面临的绝大多数具有实际意义的组合优化问题都已经在理论上被证明属于难以使用可接受的计算资源在可接受的时间内求解的 NP-Hard 问题, 其求解算法不像 P 问题一样存在标准答案. 此外, 在实际的工业应用中, 由于未来的不确定性以及评价指标常常无法完美量化等问
      
    
    </summary>
    
      <category term="技术" scheme="http://suzhouxing.github.io/techive/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="技术" scheme="http://suzhouxing.github.io/techive/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="建模" scheme="http://suzhouxing.github.io/techive/tags/%E5%BB%BA%E6%A8%A1/"/>
    
      <category term="优化" scheme="http://suzhouxing.github.io/techive/tags/%E4%BC%98%E5%8C%96/"/>
    
      <category term="数学" scheme="http://suzhouxing.github.io/techive/tags/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>组合优化 (二) 数学建模基础</title>
    <link href="http://suzhouxing.github.io/techive/2019/01/13/Opt-MathematicalProgramming/"/>
    <id>http://suzhouxing.github.io/techive/2019/01/13/Opt-MathematicalProgramming/</id>
    <published>2019-01-13T03:10:16.000Z</published>
    <updated>2019-10-22T06:05:55.264Z</updated>
    
    <content type="html"><![CDATA[<p>面对一个复杂的组合优化问题, 把它描述清楚本身就不是一个简单的问题. 常规开发往往允许模棱两可的描述, 需求修修补补虽然很烦, 但往往只是工作量的问题. 而算法研发由于其专用性, 细微的需求变化可能导致一个算法完全失效, 除非重新设计整个框架不然无法解决新的问题. 所以, 严谨的需求分析或问题描述对于算法研发格外重要. 对于一个组合优化问题, 我们一般使用数学规划的形式化语言对其进行无二义性的定义, 作为算法工程中的需求分析文档.</p><h1 id="需求分析">需求分析</h1><ul><li>为什么要做需求分析<ul><li>研究一个课题的目的: 实现一个好的系统</li><li>什么样的系统是好系统: 按事先制定的标准进行评价</li><li>标准从哪里来: 需求分析</li></ul></li><li>如何评价一个系统的好坏<ul><li>任务完成质量 (又快又好)<ul><li>完成速度</li><li>完成效果</li></ul></li><li>建设成本</li><li>运营成本</li><li>安全性<ul><li>不受外部因素干扰</li><li>从错误中恢复</li></ul></li><li>稳定性 (今天好, 明天也好; 这组数据好, 那组也好)<ul><li>代码逻辑正确性</li><li>算法对各种场景的兼容性<ul><li>静态多样性</li><li>动态随机性</li></ul></li></ul></li></ul></li><li>简化问题<ul><li>优度和速度的平衡不仅可以在问题求解的过程中, 还可以在问题定义时</li><li>简化问题会影响结果的正确性和优度</li><li>举例<ul><li>宏观低速时使用经典力学而不是相对论</li><li>同时处理多个业务简化为分多次每次处理一个业务</li><li>减小负载和提升安全性转换为不重复经过节点</li></ul></li></ul></li><li>组合优化问题的需求分析<ul><li>按形式化描述语言分类<ul><li>数学规划 (Mathematical Programming)<ul><li>线性规划 (Linear Programming)</li><li>混合整数规划 (Mixed-Integer Programming)</li><li>QP, QCP, SOCP, LFP</li></ul></li><li>约束编程 (Constraint Programming)</li><li>布尔表达式可满足性问题 (Boolean Satisfiability Problem)<ul><li>SAT Encoding</li><li>MAX-SAT Encoding</li></ul></li><li>规约 (Reduction)<ul><li>Karp's 21 NP-complete problems</li></ul></li><li>动态规划</li></ul></li><li>按应用场景分类<ul><li>静态模型</li><li>随机规划 (Stochastic Programming)</li><li>鲁棒优化 (Robust Optimization)</li></ul></li></ul></li></ul><h1 id="线性规划与混合整数规划">线性规划与混合整数规划</h1><h2 id="思维方式">思维方式</h2><h3 id="已知">已知</h3><ul><li>约束和目标中的系数</li></ul><h3 id="决策">决策</h3><ul><li>确定哪些可控因素需要做决策<ul><li>定义域<ul><li>布尔 / 整数 / 实数</li><li>上界 / 下界</li></ul></li></ul></li><li>从最根本的需求开始<ul><li>显示决策 (根本需求)</li><li>隐式决策 (客户不关心但十分重要)</li><li>辅助决策 (将非线性约束转化为线性约束)</li></ul></li><li>不够用再返回来补充</li><li>思考问题的角度影响决策变量的设置<ul><li>图着色问题<ul><li>每个节点染什么颜色</li><li>每种颜色的节点集合包含了哪些节点</li><li>每两个节点是否染了相同的颜色</li></ul></li><li>旅行销售员问题<ul><li>每个节点的第几个被访问</li><li>第几个被访问的节点是哪个节点</li><li>路径包含哪些边</li></ul></li><li>布尔表达式可满足性问题<ul><li>保证每个布尔变量在所有子句中取值一致，最大化为真的子句数量</li><li>保证每个子句均为真，最大化布尔变量的一致性</li></ul></li></ul></li></ul><h3 id="约束">约束</h3><ul><li>决策变量组成的表达式满足的关系<ul><li>等式或不等式 <span class="math inline">\(f(x) ? g(x)\)</span></li><li>下标的取值范围 <span class="math inline">\(\forall i \in V\)</span></li></ul></li><li>可以和目标对调顺序, 谁简单先考虑谁</li><li>如何验证约束是否完备?<ul><li>经验?</li><li>详尽的测试?</li><li>...</li></ul></li></ul><h3 id="目标">目标</h3><ul><li>不同决策变量取值组合产生的后果的优劣度量</li></ul><h2 id="冗余约束-redundant-constraints">冗余约束 (Redundant Constraints)</h2><h3 id="图着色问题的对称性消除-symmetric-breaking">图着色问题的对称性消除 (Symmetric Breaking)</h3><ul><li>参考文献: <a href="https://doi.org/10.1016/j.dam.2006.07.010" target="_blank" rel="noopener">A cutting plane algorithm for graph coloring</a></li><li>优化版本<ul><li>O1 一个颜色至少被一个节点使用时才会被选中 <span class="math display">\[y_{c} \le \sum_{n \in N} x_{nc}, \quad \forall c \in C\]</span></li><li>O2 编号更小的颜色未被选中时禁止选中编号更大的颜色 <span class="math display">\[y_{c&#39;} \ge y_{c}, \quad \forall c, c&#39; \in C, c&#39; = c - 1\]</span></li></ul></li><li>判定版本<ul><li>D1 使用编号更小的颜色的节点数不小于使用编号更大的颜色的节点数 (使用某种颜色的节点数随颜色编号的增长单调变化) <span class="math display">\[\sum_{n \in N} x_{nc&#39;} \ge \sum_{n \in N} x_{nc}, \quad \forall c, c&#39; \in C, c&#39; = c - 1\]</span><ul><li>D1 包含 O2</li></ul></li><li>D2 节点不允许使用比其编号更大的颜色 <span class="math display">\[x_{nc} = 0, \quad \forall n \in N, c \in C, n &lt; c\]</span></li><li>D3 编号更小的颜色未被编号更小的节点使用时禁止使用编号更大的颜色 (使用某种颜色的节点集中最小的节点编号随颜色编号的增长单调变化) <span class="math display">\[\sum_{n&#39; \in [0, n)} x_{n&#39;c&#39;} \ge x_{nc}, \quad \forall n \in N, \forall c, c&#39; \in C, c&#39; = c - 1\]</span> 与 D2 配合使用时, 将固定为 0 的项代入可化简为 <span class="math display">\[\sum_{n&#39; \in [c&#39;, n)} x_{n&#39;c&#39;} \ge x_{nc}, \quad \forall n \in N, \forall c, c&#39; \in C, c&#39; = c - 1, n \ge c\]</span><ul><li>D3 与 D1 冲突</li></ul></li></ul></li></ul><h2 id="编程实现">编程实现</h2><h3 id="求解器选择">求解器选择</h3><ul><li><a href="http://www.gurobi.com/" target="_blank" rel="noopener">Gurobi</a><ul><li>目前最高效的线性规划/混合整数规划求解器</li><li>支持免费学术许可证申请</li></ul></li><li><a href="https://www.ibm.com/software/commerce/optimization/cplex-optimizer/" target="_blank" rel="noopener">CPLEX</a><ul><li>IBM旗下的 &quot;行业标准&quot;</li></ul></li><li><a href="http://scip.zib.de/" target="_blank" rel="noopener">SCIP</a><ul><li>号称最快的开源求解器</li></ul></li><li><a href="https://projects.coin-or.org/Cbc" target="_blank" rel="noopener">COIN-OR</a><ul><li>功能繁多的开源运筹学工具包</li></ul></li><li><a href="https://github.com/google/or-tools" target="_blank" rel="noopener">OR-Tools</a><ul><li>开源经典组合优化算法库</li><li>提供统一的接口调用各大常见求解器</li></ul></li></ul><h3 id="接口选择">接口选择</h3><ul><li>编程语言接口<ul><li>开发中最常用的接口</li><li>提供更高层次的抽象</li><li>更快的模型构建速度</li><li>C / C++ / Java / C# / Python / Matlab / R</li></ul></li><li>模型文件接口<ul><li>需要自己将模型展开为线性规划的标准型</li><li>文件 I/O 速度较慢</li></ul></li><li>交互式命令行接口 (Gurobi)<ul><li>类似于解释型的脚本语言</li></ul></li><li>OPLIDE (CPLEX)<ul><li>介于命令式语言与建模语言之间</li></ul></li><li>Excel 插件</li><li>...</li></ul><h3 id="使用编程语言接口的求解过程-gurobi">使用编程语言接口的求解过程 (Gurobi)</h3><p>参考自带的示例工程 diet, facility, mip1. 基本流程如下.</p><ul><li>初始化环境 GRBEnv()<ul><li>许可证检测</li><li>其他全局参数与数据初始化</li></ul></li><li>初始化模型 GRBModel()</li><li>添加决策变量 GRBModel::addVar()<ul><li>按照一定规律组织决策变量</li><li>使用额外的数据结构将决策变量与用户变量绑定</li></ul></li><li>更新模型 GRBModel::update()<ul><li>惰性更新提升效率 (最新版已无需手动调用该函数)</li><li>CPLEX 不需要此步骤</li></ul></li><li>设置目标 GRBModel::setObjective()</li><li>添加约束 GRBModel::addConstr()</li><li>设置其他参数 GRBModel::set(), GRBEnv::set()<ul><li>运行时间</li><li>输出日志</li></ul></li><li>求解 GRBModel::optimize()</li><li>检查求解状态 GRBModel::get(GRB_IntAttr_Status)</li><li>获取目标函数值 GRBModel::get(GRB_DoubleAttr_ObjVal)</li><li>获取解向量 GRBVar::get()</li></ul><h3 id="使用模型文件接口的求解过程-gurobi">使用模型文件接口的求解过程 (Gurobi)</h3><p>参考自带的示例工程 lp. 基本流程如下.</p><ul><li>准备好 .mps 或 .lp 等模型文件 GRBModel::write()<ul><li>一般由另外的程序输出</li></ul></li><li>读取模型文件 GRBModel(), GRBModel::read()</li><li>求解并输出</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;面对一个复杂的组合优化问题, 把它描述清楚本身就不是一个简单的问题. 常规开发往往允许模棱两可的描述, 需求修修补补虽然很烦, 但往往只是工作量的问题. 而算法研发由于其专用性, 细微的需求变化可能导致一个算法完全失效, 除非重新设计整个框架不然无法解决新的问题. 所以, 
      
    
    </summary>
    
      <category term="技术" scheme="http://suzhouxing.github.io/techive/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="技术" scheme="http://suzhouxing.github.io/techive/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="建模" scheme="http://suzhouxing.github.io/techive/tags/%E5%BB%BA%E6%A8%A1/"/>
    
      <category term="优化" scheme="http://suzhouxing.github.io/techive/tags/%E4%BC%98%E5%8C%96/"/>
    
      <category term="数学" scheme="http://suzhouxing.github.io/techive/tags/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>组合优化 (一) 简介</title>
    <link href="http://suzhouxing.github.io/techive/2019/01/13/Opt-CombinatorialOptimization/"/>
    <id>http://suzhouxing.github.io/techive/2019/01/13/Opt-CombinatorialOptimization/</id>
    <published>2019-01-13T03:07:22.000Z</published>
    <updated>2019-10-22T06:05:14.191Z</updated>
    
    <content type="html"><![CDATA[<p>组合优化也叫离散优化, 是运筹优化的重要组成部分, 其中 &quot;组合&quot; 是排列组合的组合. 从字面上理解这个名词, 组合优化是要从呈组合数复杂度爆炸式增长的解空间中, 寻找最优的解向量, 即制定最优决策方案. 组合优化问题涉及了分配, 调度, 指挥, 路由等众多类型的问题. 作为人工智能的重要分支, 组合优化与时下大热的统计学习存在着千丝万缕的联系. 统计学习更侧重于预测和单步决策, 比如预测出了某件商品的销量, 就可以知道需要进多少货; 预测出了某个区域的人流量, 就可以知道需要分配多少保安巡逻; 检测出患者有某种疾病, 就可以知道要开什么药. 相比之下, 组合优化更注重涉及多方的, 全局的, 系统性的序列决策. 与此同时, 部分统计学习种的模型训练算法与求解组合优化问题的方法往往有异曲同工之妙, 因为离散优化与连续优化在思想上有很多相通之处.</p><h1 id="组合优化基础">组合优化基础</h1><h2 id="组合优化包含哪些问题">组合优化包含哪些问题</h2><ul><li>路由问题: 用开销最小的路径覆盖所有目的地<ul><li>车辆路由</li><li>数据流量路由</li></ul></li><li>指派问题: 在有限的时间和空间中合理使用软硬件资源创造更多的收益<ul><li>时间指派<ul><li>先后序调度<ul><li>单机作业调度</li><li>车间流水线调度</li></ul></li><li>时间槽分配<ul><li>航班与列车时刻表</li><li>人员排班表</li><li>选修课表</li></ul></li></ul></li><li>空间指派<ul><li>哪个背包装哪些物品: 背包问题</li><li>哪个处理器处理作业: 多机作业调度</li><li>哪个中心服务哪些客户: 中心选址</li></ul></li></ul></li><li>...</li><li>NP 完全 (NP-Complete) 问题可以在多项式时间内相互规约</li></ul><h2 id="如何定义一个问题">如何定义一个问题</h2><ul><li>基本要素<ul><li>已知: 输入数据</li><li>决策: 输出结果</li><li>约束: 输出结果可行还是不可行</li><li>目标: 输出结果好还是坏</li></ul></li><li>观察问题的不同角度举例<ul><li>图着色问题<ul><li>每个节点染什么颜色</li><li>每种颜色的节点集合包含了哪些节点</li></ul></li><li>布尔表达式可满足性问题<ul><li>保证每个布尔变量在所有子句中取值一致, 最大化为真的子句数量</li><li>保证每个子句均为真, 最大化布尔变量的一致性</li></ul></li></ul></li></ul><h2 id="基本求解方法分类">基本求解方法分类</h2><ul><li>贪心算法: 在保证求解速度的前提下提升优度<ul><li>部分可以保证最优性的贪心算法往往也可以归类为动态规划 (例如 Dijkstra 最短路算法)</li></ul></li><li>近似算法: 离最优解的差距有保障的贪心算法</li><li>精确算法: 在确保最优性的前提下降低复杂度<ul><li>深度/广度/优度优先树搜索</li><li>动态规划</li><li>混合整数规划的求解算法</li></ul></li><li>启发式算法: 在优度和复杂度之间寻找平衡点<ul><li>基于邻域动作: 元启发式算法<ul><li>单个解 (Trajectory): 局部搜索</li><li>多个解 (Population): 种群算法</li></ul></li><li>基于树搜索<ul><li>A*<ul><li>启发函数可接受 (Admissible) 时为精确算法</li></ul></li><li>向前看树搜索 (Lookahead Tree Search)</li><li>线搜索 (Beam Search)</li><li>蒙特卡洛树搜索 (Monte-Carlo Tree Search)</li></ul></li></ul></li></ul><h1 id="问题归约与转换">问题归约与转换</h1><h2 id="经典问题到现实问题">经典问题到现实问题</h2><ul><li>图着色<ul><li>寄存器分配<ul><li>寄存器 =&gt; 颜色</li><li>变量 =&gt; 节点</li><li>两个变量生命周期有交集 =&gt; 不能使用同一个寄存器 =&gt; 不能染同一种颜色 =&gt; 两个节点间有一条边</li></ul></li><li>多业务波长分配<ul><li>波长 =&gt; 颜色</li><li>路径 =&gt; 节点</li><li>两条路径有交集 =&gt; 不能使用同一个波长 =&gt; 不能染同一种颜色 =&gt; 两个节点间有一条边</li></ul></li><li>停机位分配<ul><li>停机位 =&gt; 颜色</li><li>飞机 =&gt; 节点</li><li>两架飞机过站时间有交集 =&gt; 不能停在同一停机位 =&gt; 不能染同一种颜色 =&gt; 两个节点间有一条边</li></ul></li><li>宿舍分配<ul><li>宿舍 =&gt; 颜色</li><li>学生 =&gt; 节点</li><li>两个学生作息规律差异很大 =&gt; 不能住同一间宿舍 =&gt; 不能然同一种颜色 =&gt; 两个节点间有一条边</li></ul></li></ul></li><li>旅行销售员<ul><li>快递与外卖配送</li><li>物资采购</li><li>人类基因组计划</li></ul></li></ul><h2 id="经典问题相互转换">经典问题相互转换</h2><h3 id="独立集-最大团-顶点覆盖-支配集-集合覆盖-中心选址">独立集 &lt;=&gt; 最大团 &lt;=&gt; 顶点覆盖 =&gt; 支配集 &lt;=&gt; 集合覆盖 &lt;= 中心选址</h3><p>.</p><h3 id="非对称旅行商-对称旅行商">非对称旅行商 &lt;=&gt; 对称旅行商</h3><p>.</p><h3 id="必经点最短简单路-非对称旅行商-最短简单路-最长简单路">必经点最短简单路 =&gt; 非对称旅行商 &lt;=&gt; 最短简单路 &lt;=&gt; 最长简单路</h3><ul><li>必经点最短路 =&gt; 非对称旅行商<ul><li>基本思路<ul><li>增加一条无代价的旁路让所有非必经点能够通过该旁路被访问</li><li>从起点出发, 经过最短路上的实际节点序列, 到达终点, 到达旁路起点, 通过旁路依次经过不在最短路上的实际节点</li></ul></li><li>具体实现<ul><li>假设起点为 <span class="math inline">\(s\)</span>, 终点为 <span class="math inline">\(t\)</span>, 共有 <span class="math inline">\(k\)</span> 个非必经节点 <span class="math inline">\(n_{1}, n_{2}, ..., n_{k}\)</span></li><li>增加 <span class="math inline">\(k + 1\)</span> 个虚拟节点 <span class="math inline">\(v_{0}, v_{1}, ..., v_{k}\)</span></li><li>增加以下有向边<ul><li><span class="math inline">\(t \rightarrow v_{k}\)</span></li><li><span class="math inline">\(v_{i} \rightarrow v_{i-1}, \quad \forall i \in [1, k]\)</span></li><li><span class="math inline">\(v_{i} \rightarrow n_{i}, \quad \forall i \in [1, k]\)</span></li><li><span class="math inline">\(n_{i} \rightarrow v_{i-1}, \quad \forall i \in [1, k]\)</span></li><li><span class="math inline">\(v_{0} \rightarrow s\)</span></li></ul></li><li>上述有向边应满足<ul><li><span class="math inline">\(cost(v_{i} \rightarrow v_{i-1}) = cost(v_{i} \rightarrow n_{i}) + cost(n_{i} \rightarrow v_{i-1})\)</span></li><li><span class="math inline">\(cost(t \rightarrow v_{k}) = cost(v_{0} \rightarrow s) = 0\)</span></li></ul></li></ul></li></ul></li></ul><h2 id="经典问题分解">经典问题分解</h2><h3 id="图着色-集合覆盖-独立集">图着色 = 集合覆盖 + 独立集</h3><p>.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;组合优化也叫离散优化, 是运筹优化的重要组成部分, 其中 &amp;quot;组合&amp;quot; 是排列组合的组合. 从字面上理解这个名词, 组合优化是要从呈组合数复杂度爆炸式增长的解空间中, 寻找最优的解向量, 即制定最优决策方案. 组合优化问题涉及了分配, 调度, 指挥, 路由等
      
    
    </summary>
    
      <category term="技术" scheme="http://suzhouxing.github.io/techive/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="技术" scheme="http://suzhouxing.github.io/techive/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="建模" scheme="http://suzhouxing.github.io/techive/tags/%E5%BB%BA%E6%A8%A1/"/>
    
      <category term="优化" scheme="http://suzhouxing.github.io/techive/tags/%E4%BC%98%E5%8C%96/"/>
    
      <category term="数学" scheme="http://suzhouxing.github.io/techive/tags/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>理想的编程测试</title>
    <link href="http://suzhouxing.github.io/techive/2018/06/09/IdealCodingTest/"/>
    <id>http://suzhouxing.github.io/techive/2018/06/09/IdealCodingTest/</id>
    <published>2018-06-09T02:41:02.000Z</published>
    <updated>2018-07-01T03:11:17.815Z</updated>
    
    <content type="html"><![CDATA[<p>以下观点仅针对博士招聘或者高级职位的招聘, 如果只是想招个码农一丝不苟地完成编码任务, 可以忽略此文...</p><p>最近参加某公司的博士特招, 收到了的一封邮件说让我做个编程测试. 与普通校招不同, 这封邮件并没有让我去 OJ 平台做题, 而是直接在邮件正文中给了 3 道题让我几天内做完并回复邮件. 这种新颖的形式让我眼前一亮, 虽然最后招聘人员的回复让我发现我想多了, 但是还是想分享一下自己的思考.</p><p>这种编程测试有以下几个特点:</p><ul><li>问题描述模糊</li><li>有常规求解方法 (有可能在 ACM 比赛中短时间内实现)</li><li>有高级求解方法</li><li>线下完成且时间宽裕</li></ul><p>这种开放性的命题其实可以考察很多内容.</p><p>首先, 因为问题描述存在不严谨的地方, 沟通会非常重要, 换句话说, 这是一种需求分析的意识和能力. 其次, 因为没有限制输入输出数据格式, 需要自己定义接口, 自己确定代码框架. 写出来的代码要足够模块化以适应需求的变更, 包括问题定义的改变和性能要求的提升, 同时接口定义合理方便在其他地方复用. 然后, 没有给定输入输出数据格式肯定更不会给测试用例, 需要自己编写测试用例并且有测试相关的代码, 同时也是使用接口的示例代码. 最后, 编码风格也是可以需要注意的因素之一, 比如命名统一规范且足够自文档, 对功能复杂的模块有适当的注释等等.</p><p>举个例子, 这样一道题目 &quot;对一个字符串进行词频统计, 按词频降序排序输出 (word, count)&quot;, 你在 OJ 上刷题时会怎么做? 在工作中遇到会怎么做? 这个问题其实给得非常模糊, 如果是我至少会想到以下几个问题:</p><ul><li>字符串长度是否超过内存容量限制?</li><li>文件是否只包含 ASCII 码且按照拉丁语系的书写习惯组织词法语法?</li><li>文件是否包含空白字符以外的非字母字符 (如数字和标点)? 如果包含, 是否仍然严格以空白字符为分隔符分词?</li><li>单词是否区分大小写?</li><li>不同单词数量规模有多大? 是否可能超出 int 最大范围?</li><li>每个单词的出现频率是否超出 int 最大范围?</li><li>两个单词词频相同怎么办?</li></ul><p>对于最复杂的情况, 比如需要做中文分词, 外部排序, 甚至分布式处理, 可能需要用到各种开源库, 代码量甚至可以达到成千上万行...</p><p>也许你会说, 理想很丰满现实很骨感. 上面这些好处大家都懂, 但是只要你是一种考核, 就会有针对性的应试技巧. 在线编程测试时间那么短, 可以在一定程度上杜绝抄袭, 但是弄成离线的测试放宽时间限制, 根本不理解算法的人也可以复制粘贴搞出一份代码提交. 首先能敲出代码的人不一定自己真的理解了算法, 甚至觉得自己理解了算法的人也不一定是真的理解了, 很多人对算法的理解并没有达到能证明其正确性和最优性的地步. 其次这种测试考察的是各方面的综合能力, 而不是某个具体问题的解法. 靠死记硬背做出一道题, 换个问题可能就不会做了 (当然, 我们必须承认反复训练可以提升设计算法的感觉). 但是遇到问题先仔细分析需求, 然后从可复用性和可扩展性考虑规划代码架构, 最后进行系统的测试的能力, 是可以在每个项目中发挥作用的. 至于同时参加编程测试的人互相抄袭的问题, 现在应该已经有自动代码查重的工具了. 而且题库丰富起来之后, 给可能相互认识的求职者 (比如同一个研究所) 分发不同的题目即可.</p><p>当然, 这种模式也有缺点, 就是在现有技术水平下只能人工判卷, 且评判结果主观性太强, 无法适应大规模的招聘.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;以下观点仅针对博士招聘或者高级职位的招聘, 如果只是想招个码农一丝不苟地完成编码任务, 可以忽略此文...&lt;/p&gt;
&lt;p&gt;最近参加某公司的博士特招, 收到了的一封邮件说让我做个编程测试. 与普通校招不同, 这封邮件并没有让我去 OJ 平台做题, 而是直接在邮件正文中给了 
      
    
    </summary>
    
      <category term="技术" scheme="http://suzhouxing.github.io/techive/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="技术" scheme="http://suzhouxing.github.io/techive/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="招聘" scheme="http://suzhouxing.github.io/techive/tags/%E6%8B%9B%E8%81%98/"/>
    
      <category term="求职" scheme="http://suzhouxing.github.io/techive/tags/%E6%B1%82%E8%81%8C/"/>
    
      <category term="编程" scheme="http://suzhouxing.github.io/techive/tags/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>数据库中的搜索, 组合优化问题的搜索, 统一建模语言与通用求解器</title>
    <link href="http://suzhouxing.github.io/techive/2018/06/07/SearchingInDatabaseOrOptimization/"/>
    <id>http://suzhouxing.github.io/techive/2018/06/07/SearchingInDatabaseOrOptimization/</id>
    <published>2018-06-07T02:50:41.000Z</published>
    <updated>2018-07-01T03:11:17.817Z</updated>
    
    <content type="html"><![CDATA[<p>最近遇到了一个小问题, 大致是已知一块玻璃上有些瑕疵, 如何切割出一块给定大小的矩形区域, 让它的位置尽量靠近左下角, 但是不与任何瑕疵重合.</p><p>虽然原始问题要求的是不与任何瑕疵重合, 但是对于一个给定的格局, 比如已知一些瑕疵会同时被覆盖, 有些瑕疵显然是不需要考虑的, 我们称其为 &quot;被支配&quot; 的瑕疵. 所以其实我们只需要避开没有 &quot;被支配&quot; 的瑕疵, 如下图中红色的点, 而绿色的点显然是不需要考虑的.</p><figure><img src="Packing.png" alt="矩形装配"><figcaption>矩形装配</figcaption></figure><p>这个问题给我的第一反应是它和多目标优化的一种实现方式很像, 即帕累托最优性 (Pareto Optimality). 对于在帕累托前沿 (Pareto Frontier) 上的点, 找不到这样一个点, 在各个维度 (目标) 上都比他们数值更大 (目标函数值更优). 反之, 通俗地说, 就是存在一个点在各个维度上都能碾压某个不在 Pareto Frontier 上的点.</p><p>在搜索引擎里搜了下, 想找找有没有高效的求解方案, 找到了下面几个网页: https://en.wikipedia.org/wiki/Pareto_efficiency#Computation https://en.wikipedia.org/wiki/Multi-objective_optimization https://en.wikipedia.org/wiki/Skyline_operator</p><p>其中令人惊讶的是, 这个问题居然跟数据库有关, 甚至 SQL 里面还有个专门的算子用来实现这个功能!</p><p>突然想起前段时间一位在国内某 500 强企业数据库部门的师叔来实验室交流时, 对通用求解器的讨论. 数据库和组合优化都是在一个有限的解空间内搜索满足条件的数据. 而数据库有个很大的优点, 就是有一个统一的描述语言, SQL, 来定义一切对数据的查询和修改操作. 在多年的不断改进和优化之下, 使用数据管理系统已经能比绝大多数人自行编写代码完成数据管理更加高效了. 但是对于组合优化问题, 无论是学术界还是工业界, 都还在以手工打造为主的阶段. 以 Gurobi 和 CPLEX 为首的基于线性规划的通用求解器存在各种各样的限制, 比如只支持混合整数规划和特殊形式的二次规划, 而且求解速度往往慢于针对性的启发式算法或精确算法. 其他的基于约束编程 (Constraint Programming) 的求解器, 或者基于启发式的 LocalSolver 等求解器提供了更丰富而强大的建模语言, 但表达能力仍然有限, 且求解效果尚不如 Gurobi. 更进一步, 将问题编码成布尔表达式可满足性问题 (SAT 或 MAX-SAT) 也是一个很有意思的方案, 但是如果说前两种得到了广泛应用的方案是用 C++ 编程, 这个方案简直就是在用汇编甚至设计电路.</p><p>这样看来, 打造一个更加通用更加高效的求解器似乎是一个很有吸引力的研究方向.</p><p>然而, 即使在 &quot;大数据&quot; 时代, PB 甚至 EB 级的数据量仍然是十分有限的, 跟几乎无穷无尽的组合优化问题的解空间相比, 实在是太渺小了. 简单机械地将问题拆分成多个子问题逐层求解的方式听起来前途十分渺茫. 因此, 要实现这个设想的难度也是十分巨大的.</p><h1 id="附-开篇问题的严谨定义">附: 开篇问题的严谨定义</h1><p>令 A(d) 表示矩形区域的左侧边缘与瑕疵 d 的右侧边缘存在重合的部分; B(d) 表示矩形区域的下侧边缘与瑕疵 d 的上侧边缘存在重合的部分; C(x) 和 C(y) 分别表示矩形区域的下侧边缘和左侧边缘与 x 轴和 y 轴重合. 其中边缘均为不包括矩形区域顶点的线段.</p><p>则矩形区域的放置位置需要满足以下约束:</p><p>存在 d != d', 使 (A(d) &amp;&amp; C(x)) || (B(d) &amp;&amp; C(y) || (A(d) &amp;&amp; B(d')) 为真, 同时矩形区域内不存在任何瑕疵.</p><p>求矩形区域所有可能的放置位置.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近遇到了一个小问题, 大致是已知一块玻璃上有些瑕疵, 如何切割出一块给定大小的矩形区域, 让它的位置尽量靠近左下角, 但是不与任何瑕疵重合.&lt;/p&gt;
&lt;p&gt;虽然原始问题要求的是不与任何瑕疵重合, 但是对于一个给定的格局, 比如已知一些瑕疵会同时被覆盖, 有些瑕疵显然是不
      
    
    </summary>
    
      <category term="技术" scheme="http://suzhouxing.github.io/techive/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="技术" scheme="http://suzhouxing.github.io/techive/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="建模" scheme="http://suzhouxing.github.io/techive/tags/%E5%BB%BA%E6%A8%A1/"/>
    
      <category term="运筹优化" scheme="http://suzhouxing.github.io/techive/tags/%E8%BF%90%E7%AD%B9%E4%BC%98%E5%8C%96/"/>
    
      <category term="数据库" scheme="http://suzhouxing.github.io/techive/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="通用求解器" scheme="http://suzhouxing.github.io/techive/tags/%E9%80%9A%E7%94%A8%E6%B1%82%E8%A7%A3%E5%99%A8/"/>
    
      <category term="多目标" scheme="http://suzhouxing.github.io/techive/tags/%E5%A4%9A%E7%9B%AE%E6%A0%87/"/>
    
  </entry>
  
  <entry>
    <title>组合优化问题的数学建模资料整理</title>
    <link href="http://suzhouxing.github.io/techive/2018/04/01/ModelingInCombinatorialOptimization/"/>
    <id>http://suzhouxing.github.io/techive/2018/04/01/ModelingInCombinatorialOptimization/</id>
    <published>2018-04-01T02:31:21.000Z</published>
    <updated>2018-07-01T03:11:17.816Z</updated>
    
    <content type="html"><![CDATA[<p>给实验室的新生和实习生培训用的资料.</p><p><a href="http://suzhouxing.github.io/assets/articles/Modeling%20in%20Combinatorial%20Optimization.pptx">组合优化问题的数学建模.pptx</a></p><p><a href="http://suzhouxing.github.io/assets/articles/Converting%20Non-linear%20Objectives%20into%20Linear%20Ones.pdf">线性化非线性表达式.pdf</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;给实验室的新生和实习生培训用的资料.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://suzhouxing.github.io/assets/articles/Modeling%20in%20Combinatorial%20Optimization.pptx&quot;&gt;组合优化问题
      
    
    </summary>
    
      <category term="技术" scheme="http://suzhouxing.github.io/techive/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="技术" scheme="http://suzhouxing.github.io/techive/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="建模" scheme="http://suzhouxing.github.io/techive/tags/%E5%BB%BA%E6%A8%A1/"/>
    
      <category term="优化" scheme="http://suzhouxing.github.io/techive/tags/%E4%BC%98%E5%8C%96/"/>
    
      <category term="数学" scheme="http://suzhouxing.github.io/techive/tags/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>欧美的优化算法公司在中国的水土不服</title>
    <link href="http://suzhouxing.github.io/techive/2018/01/31/DifferentWayOfThinking/"/>
    <id>http://suzhouxing.github.io/techive/2018/01/31/DifferentWayOfThinking/</id>
    <published>2018-01-31T13:45:46.000Z</published>
    <updated>2018-07-01T03:11:17.812Z</updated>
    
    <content type="html"><![CDATA[<p>最近做项目的过程中发现, 甲方使用的系统里据说调用了 Quintiq 的优化算法, 但是甲方表示这个算法求出来的结果完全不能用, 于是这个功能长期处于闲置状态. 突然想起之前听说中石油中石化都买了 Aspen 的系统, 但是成品油配送基本上也没用系统自带的算法, 还是在由调度员人工调度. 此外, 还听说上海交大的某教授二十年前刚从国外回来的时候, 去找东航说要帮他们做航线规划的算法, 结果东航说就那么点飞机, 人调度就够了, 不需要什么算法.</p><p>如果上面的几个故事是普遍现象的话, 那么欧美工业界的成功案例在国内确实是水土不服. 但是受限于个人眼界的狭窄, 以及获取信息的渠道有限, 上面的见闻既不可靠, 也不能反映整体情况. 工业界到底有怎样的内幕是不得而知了, 不过也许从学术界的研究中可以看出些端倪. 下面将以几个经典的问题为例, 对比一下学术论文中研究的问题和在国内遇到的实际情况.</p><h1 id="停机位分配">停机位分配</h1><ul><li>机位初始分配<ul><li>欧美一般是在近机位上下客, 如果过站时间较长可能会中途把飞机拖到远机位起飞前又拖回近机位</li><li>国内一般是不调整停机位, 近机位停满了就停到远机位, 用摆渡车把乘客拉到远机位登机</li></ul></li><li>发生延误时的机位调整<ul><li>欧美一般不变更停机位, 后继航班在空中或滑行道上等待</li><li>国内一般是直接将后继航班分配至同区域的近机位或远机位, 并通知乘客变更登机门</li></ul></li></ul><p>国内似乎是人跟着飞机跑, 而欧美似乎是飞机围着人转.</p><p>当然, 欧美也是个很大的概念, 包含了太多国家和地区, 不能一概而论. 而且论文作者也不见得和机场有深入的沟通, 研究的问题也许只是假想的应用场景.</p><h1 id="排课表">排课表</h1><ul><li>选修课<ul><li>欧美一般是学生先根据自己的兴趣选课, 由选课系统来确定课程的时间地点以最小化学生不同课程之间的时间冲突</li><li>国内一般是选课系统提前把每门课的时间地点确定好, 由学生选择想上哪些课程时自行解决时间冲突</li></ul></li><li>必修课<ul><li>欧美一般是根据课时需求统一规划上课时间和教室分配</li><li>国内一般是先排好校级公共课时间, 然后各学院分别确定专业课时间, 最后汇总协调教室分配</li></ul></li></ul><p>在选修课方面, 国内是非常具有中国特色的超大规模人肉并行计算, 而欧美则相对自由一点 (当然, 每个课堂还是有的容量限制, 不可能完全做到根据兴趣选课). 而必修课方面, 国内采用的是分而治之的方案, 后期需要花费较多精力在各学院之间协调, 而欧美直接从全局的角度考虑, 对算法性能要求很高.</p><h1 id="护士排班">护士排班</h1><ul><li>欧美一般是提前提出上班时间的偏好, 然后排班系统在考虑特殊需求的情况下均衡总工作量和工作强度等指标</li><li>国内一般是按照简单的规则排出很规整的排班表, 如果有特殊情况需要调整上班时间自行跟其他人协商调班</li></ul><p>国内的医护人员往往十分紧缺, 相对来说都是全职全能型的, 不像欧美有那么多余地可以选择不同的合同. 正因为大家的职能差别不大, 所以复杂的排班算法确实没有用武之地, 调度来调度去并没有太大差别. 而有特殊情况时私下跟他人协商临时调班也是一种人肉并行计算, 既然统一规划众口难调, 那就大家各管各饱.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近做项目的过程中发现, 甲方使用的系统里据说调用了 Quintiq 的优化算法, 但是甲方表示这个算法求出来的结果完全不能用, 于是这个功能长期处于闲置状态. 突然想起之前听说中石油中石化都买了 Aspen 的系统, 但是成品油配送基本上也没用系统自带的算法, 还是在由调
      
    
    </summary>
    
      <category term="技术" scheme="http://suzhouxing.github.io/techive/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="技术" scheme="http://suzhouxing.github.io/techive/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="建模" scheme="http://suzhouxing.github.io/techive/tags/%E5%BB%BA%E6%A8%A1/"/>
    
      <category term="运筹学" scheme="http://suzhouxing.github.io/techive/tags/%E8%BF%90%E7%AD%B9%E5%AD%A6/"/>
    
      <category term="需求分析" scheme="http://suzhouxing.github.io/techive/tags/%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>二分法与黄金分割法的区别</title>
    <link href="http://suzhouxing.github.io/techive/2018/01/14/IntervalEliminationMethod/"/>
    <id>http://suzhouxing.github.io/techive/2018/01/14/IntervalEliminationMethod/</id>
    <published>2018-01-14T01:19:00.000Z</published>
    <updated>2018-07-01T03:11:17.815Z</updated>
    
    <content type="html"><![CDATA[<p>高中数学选修课学过区间消去法, 用于求解简单的单变量无约束的优化问题. 其中的典型有二分法和黄金分割法 (0.618法), 后来还知道黄金分割法其实是斐波那契法的简化. 而很多人似乎并不清楚这两种方法的区别和适用场景.</p><p>读研之后一直在做运筹学相关的问题, 遇到的优化问题都是上百万维的多约束多目标的组合优化问题. 偶然间遇到了一个简单的一维的情况, 突然来了一种莫名的自信觉得自己可以比当时的高中数学老师讲得更清楚...</p><p>二分法主要用于寻找阶跃函数的突变点.</p><figure><img src="BisectionMethod.png" alt="阶跃函数"><figcaption>阶跃函数</figcaption></figure><p>例如二分查找, 定义比待查找元素小的元素目标函数值为 0, 比待查找元素大的元素目标函数值为 1, 则待查找元素为目标函数的突变点.</p><p>黄金分割法和斐波那契法用于寻找单峰函数的极值点.</p><figure><img src="FibonacciMethod.png" alt="单峰函数"><figcaption>单峰函数</figcaption></figure><p>例如确定药物的最佳剂量, 定义治疗效果和副作用为目标函数, 则用量比最佳剂量大或者小时综合效果都更差.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;高中数学选修课学过区间消去法, 用于求解简单的单变量无约束的优化问题. 其中的典型有二分法和黄金分割法 (0.618法), 后来还知道黄金分割法其实是斐波那契法的简化. 而很多人似乎并不清楚这两种方法的区别和适用场景.&lt;/p&gt;
&lt;p&gt;读研之后一直在做运筹学相关的问题, 遇
      
    
    </summary>
    
      <category term="数学" scheme="http://suzhouxing.github.io/techive/categories/%E6%95%B0%E5%AD%A6/"/>
    
    
      <category term="优化" scheme="http://suzhouxing.github.io/techive/tags/%E4%BC%98%E5%8C%96/"/>
    
      <category term="数学" scheme="http://suzhouxing.github.io/techive/tags/%E6%95%B0%E5%AD%A6/"/>
    
      <category term="高中" scheme="http://suzhouxing.github.io/techive/tags/%E9%AB%98%E4%B8%AD/"/>
    
  </entry>
  
  <entry>
    <title>科学是什么</title>
    <link href="http://suzhouxing.github.io/techive/2017/10/05/WhatIsScience/"/>
    <id>http://suzhouxing.github.io/techive/2017/10/05/WhatIsScience/</id>
    <published>2017-10-05T01:37:51.000Z</published>
    <updated>2018-07-01T03:11:17.818Z</updated>
    
    <content type="html"><![CDATA[<p>科学是一种描述世界运转的方法, 不能解释任何现象的成因.</p><p>人类的科学是一套建立在少数 &quot;显然成立&quot; 的假设之上的知识体系, &quot;力&quot; 就是一种假设存在的相互作用关系. 给定一个初始状态, 科学也许可以预测状态的转移, 或者说现象. 可能其中会用到一些复杂的理论, 而这些复杂的理论可以用更简单的理论解释. 但是如果你要追根溯源, 找到现象的本质, 那么科学是做不到的.</p><p>科学首先要自洽, 其次要精确. 但不幸的是, 绝对的科学也许是不存在的, 在可预见的未来中, 科学将一直是个相对的概念. 与经典力学相比, 量子力学是更科学的理论体系. 与传统中医比, 现代医学是更科学的知识体系.</p><p>题外话: 这么说来, 被很多学者诟病的机器学习其实本质上也是一种科学, 根据观察结果拟合出一个模型来描述发展趋势. 只不过其假设基础不那么显然, 预测结果也不那么精确.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;科学是一种描述世界运转的方法, 不能解释任何现象的成因.&lt;/p&gt;
&lt;p&gt;人类的科学是一套建立在少数 &amp;quot;显然成立&amp;quot; 的假设之上的知识体系, &amp;quot;力&amp;quot; 就是一种假设存在的相互作用关系. 给定一个初始状态, 科学也许可以预测状态的转移, 或
      
    
    </summary>
    
      <category term="科学" scheme="http://suzhouxing.github.io/techive/categories/%E7%A7%91%E5%AD%A6/"/>
    
    
      <category term="日常" scheme="http://suzhouxing.github.io/techive/tags/%E6%97%A5%E5%B8%B8/"/>
    
      <category term="科学" scheme="http://suzhouxing.github.io/techive/tags/%E7%A7%91%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>如何咨询技术类问题</title>
    <link href="http://suzhouxing.github.io/techive/2017/10/02/HowToAskQuestions/"/>
    <id>http://suzhouxing.github.io/techive/2017/10/02/HowToAskQuestions/</id>
    <published>2017-10-02T06:14:37.000Z</published>
    <updated>2018-07-01T03:11:17.814Z</updated>
    
    <content type="html"><![CDATA[<p>每当有人发来一张出错提示框的截图来问我怎么办的时候, 我的内心都是崩溃的.</p><p>对于这种让人摸不着头脑的提问方式, 我真想说: &quot;你把这个问题发到 StackOverflow 上, 两天内没被维护者关闭的话把链接发给我&quot;.</p><p>在这里汇总一下技术类提问指南, 免得不会问问题的提问者又来问我为什么我在 StackOverflow 上发的问题被关闭了.</p><p>[1] https://stackoverflow.com/help/how-to-ask [2] https://stackoverflow.com/help/mcve [3] https://ericlippert.com/2014/03/05/how-to-debug-small-programs/</p><blockquote><h1 id="how-do-i-ask-a-good-question">How do I ask a good question?</h1><p>We'd love to help you. To <strong>improve your chances</strong> of getting an answer, here are some tips:</p><h2 id="search-and-research"><a href="https://stackoverflow.com/search" target="_blank" rel="noopener">Search</a>, and research</h2><p>...and keep track of what you find. Even if you don't find a useful answer elsewhere on the site, including links to related questions that <em>haven't</em> helped can help others in understanding how your question is different from the rest.</p><h2 id="write-a-title-that-summarizes-the-specific-problem">Write a title that summarizes the specific problem</h2><p>The title is the first thing potential answerers will see, and if your title isn't interesting, they won't read the rest. So <em>make it count:</em></p><ul><li><strong>Pretend you're talking to a busy colleague</strong> and have to sum up your entire question in one sentence: what details can you include that will help someone identify and solve your problem? Include any error messages, key APIs, or unusual circumstances that make your question different from similar questions already on the site.</li><li><strong>Spelling, grammar and punctuation are important!</strong> Remember, this is the first part of your question others will see - you want to make a good impression. If you're not comfortable writing in English, ask a friend to proof-read it for you.</li><li>If you're having trouble summarizing the problem, <strong>write the title last</strong> - sometimes writing the rest of the question first can make it easier to describe the problem.</li></ul><p>Examples:</p><ul><li><strong>Bad:</strong> C# Math Confusion</li><li><strong>Good:</strong> Why does using float instead of int give me different results when all of my inputs are integers?</li><li><strong>Bad:</strong> [php] session doubt</li><li><strong>Good:</strong> How can I redirect users to different pages based on session data in PHP?</li><li><strong>Bad:</strong> android if else problems</li><li><strong>Good:</strong> Why does str == &quot;value&quot; evaluate to false when str is set to &quot;value&quot;?</li></ul><h2 id="introduce-the-problem-before-you-post-any-code">Introduce the problem before you post any code</h2><p>In the body of your question, start by expanding on the summary you put in the title. Explain how you encountered the problem you're trying to solve, and any difficulties that have prevented you from solving it yourself. The first paragraph in your question is the second thing most readers will see, so make it as engaging and informative as possible.</p><h2 id="help-others-reproduce-the-problem">Help others reproduce the problem</h2><p>Not all questions benefit from including code. But if your problem is <em>with</em> code you've written, you should include some. But <strong>don't just copy in your entire program!</strong> Not only is this likely to get you in trouble if you're posting your employer's code, it likely includes a lot of irrelevant details that readers will need to ignore when trying to reproduce the problem. Here are some guidelines:</p><ul><li>Include just enough code to allow others to reproduce the problem. For help with this, read <a href="https://stackoverflow.com/help/mcve" target="_blank" rel="noopener">How to create a Minimal, Complete, and Verifiable example</a>.</li><li>If it is possible to create a live example of the problem that you can <em>link</em> to (for example, on <a href="http://sqlfiddle.com/" class="uri" target="_blank" rel="noopener">http://sqlfiddle.com/</a> or <a href="http://jsbin.com/" class="uri" target="_blank" rel="noopener">http://jsbin.com/</a>) then do so - but also include the code in your question itself. Not everyone can access external sites, and the links may break over time.</li></ul><h2 id="include-all-relevant-tags">Include all relevant tags</h2><p>Try to include a tag for the language, library, and specific API your question relates to. If you start typing in the tags field, the system will suggest tags that match what you've typed - be sure and read the descriptions given for them to make sure they're relevant to the question you're asking! See also: <a href="https://stackoverflow.com/help/tagging" target="_blank" rel="noopener">What are tags, and how should I use them?</a></p><h2 id="proof-read-before-posting">Proof-read before posting!</h2><p>Now that you're ready to ask your question, take a deep breath and read through it from start to finish. Pretend you're seeing it for the first time: <em>does it make sense?</em> Try reproducing the problem yourself, in a fresh environment and make sure you can do so using only the information included in your question. Add any details you missed and read through it again. Now is a good time to make sure that your title still describes the problem!</p><h2 id="post-the-question-and-respond-to-feedback">Post the question and respond to feedback</h2><p>After you post, leave the question open in your browser for a bit, and see if anyone comments. If you missed an obvious piece of information, be ready to respond by editing your question to include it. If someone posts an answer, be ready to try it out and provide feedback!</p><h2 id="look-for-help-asking-for-help">Look for help asking for help</h2><p>In spite of all your efforts, you may find your questions poorly-received. Don't despair! Learning to ask a good question is a worthy pursuit, and not one you'll master overnight. Here are some additional resources that you may find useful:</p><ul><li><a href="http://codeblog.jonskeet.uk/2010/08/29/writing-the-perfect-question/" target="_blank" rel="noopener">Writing the perfect question</a></li><li><a href="http://meta.stackexchange.com/questions/10811/how-do-i-ask-and-answer-homework-questions" target="_blank" rel="noopener">How do I ask and answer homework questions?</a></li><li><a href="http://ericlippert.com/2014/03/05/how-to-debug-small-programs/" target="_blank" rel="noopener">How to debug small programs</a></li><li><a href="http://meta.stackexchange.com/questions/tagged/asking-questions" target="_blank" rel="noopener">Meta discussions on asking questions</a></li><li><a href="http://www.catb.org/~esr/faqs/smart-questions.html" target="_blank" rel="noopener">How to ask questions the smart way</a> — long but good advice.</li></ul></blockquote><blockquote><h1 id="how-to-create-a-minimal-complete-and-verifiable-example">How to create a Minimal, Complete, and Verifiable example</h1><p>When asking a question about a problem caused by your code, you will get much better answers if you provide code people can use to reproduce the problem. That code should be…</p><ul><li>…Minimal – Use as little code as possible that still produces the same problem</li><li>…Complete – Provide all parts needed to reproduce the problem</li><li>…Verifiable – Test the code you're about to provide to make sure it reproduces the problem</li></ul><h2 id="minimal">Minimal</h2><p>The more code there is to go through, the less likely people can find your problem. Streamline your example in one of two ways:</p><ol type="1"><li><strong>Restart from scratch.</strong> Create a new program, adding in only what is needed to see the problem. This can be faster for vast systems where you think you already know the source of the problem. Also useful if you can't post the original code publicly for legal or ethical reasons.</li><li><strong>Divide and conquer.</strong> When you have a small amount of code, but the source of the problem is entirely unclear, start removing code a bit at a time until the problem disappears – then add the last part back.</li></ol><h3 id="minimal-and-readable">Minimal <em>and</em> readable</h3><p>Minimal does not mean <em>terse</em> – don't sacrifice communication to brevity. Use consistent naming and indentation, and include comments if needed to explain portions of the code. Most code editors have a shortcut for formatting code – find it, and <em>use it!</em>Also, <strong>don't use tabs</strong> – they may look good in your editor, but they'll just make a mess on Stack Overflow.</p><h2 id="complete">Complete</h2><p>Make sure all information necessary to reproduce the problem is included:</p><ul><li>Some people might be prepared to load the parts up, and actually try them to test the answer they're about to post.</li><li>The problem might not be in the part you suspect it is, but another part entirely.</li></ul><p>If the problem requires some server-side code as well as an XML-based configuration file, include them both. If a web page problem requires HTML, some JavaScript and a stylesheet, include all three.</p><h2 id="verifiable">Verifiable</h2><p>To help you solve your problem, others will need to verify that it <em>exists:</em></p><ul><li><strong>Describe the problem.</strong> &quot;It doesn't work&quot; is not a problem statement. Tell us what the expected behavior should be. Tell us what the exact wording of the error message is, and which line of code is producing it. Put a brief summary of the problem in the title of your question.</li><li><strong>Eliminate any issues that aren't relevant to the problem.</strong> If your question isn't <em>about</em> a compiler error, ensure that there are no compile-time errors. Use a program such as <a href="http://www.jslint.com/" target="_blank" rel="noopener">JSLint</a> to validate interpreted languages. <a href="http://validator.w3.org/" target="_blank" rel="noopener">Validate</a> any HTML or XML.</li><li><strong>Ensure that the example actually reproduces the problem!</strong> If you inadvertently fixed the problem while composing the example but didn't test it again, you'd want to know that before asking someone else to help.</li></ul><p>It might help to shut the system down and restart it, or transport the example to a fresh machine to confirm it really does provide an example of the problem.</p><p>For more information on how to debug your program so you can create a minimal example, <a href="http://stackoverflow.com/users/88656/eric-lippert" target="_blank" rel="noopener">Eric Lippert</a> has a fantastic blog post on the subject: <em>How to debug small programs</em>.</p><p>You may have been told to include an MCVE by some helpful commentary, or perhaps even an MVCE if they were rushed; sorry for the initialisms, this is what they were referring to.</p></blockquote><blockquote><h1 id="how-to-debug-small-programs">How to debug small programs</h1><p>Posted on <a href="https://ericlippert.com/2014/03/05/how-to-debug-small-programs/" target="_blank" rel="noopener">March 5, 2014</a></p><p>One of the most frequent categories of bad questions I see on StackOverflow is:</p><blockquote><p><em>I wrote this program for my assignment and it doesn't work.</em> <em>[20 lines of code].</em></p></blockquote><p>And... that's it.</p><p>If you're reading this, odds are good it's because I or someone else linked here from your StackOverflow question shortly before it was closed and deleted. (If you're reading this and you're not in that position, consider leaving your favourite tips for debugging small programs in the comments.)</p><p>StackOverflow is a question-and-answer site for specific questions about actual code; &quot;<em>I wrote some buggy code that I can't fix</em>&quot; is not a <em>question</em>, it's a <em>story</em>, and not even an interesting story. &quot;<em>Why does subtracting one from zero produce a number that is larger than zero, causing my comparison against zero on line 12 to incorrectly become true?</em>&quot; is a <em>specific question about actual code</em>.</p><p>So you're asking the Internet to <em>debug a broken program that you wrote</em>. You've probably never been taught how to debug a small program, because let me tell you, <strong>what you're doing now is not an efficient way to get that problem solved</strong>. Today is a good day to learn how to debug things for yourself, because StackOverflow is not about to debug your programs for you.</p><p>I'm going to assume that your program actually compiles but its action is wrong, and that moreover, you have a test case that shows that it is wrong. Here's how to find the bug.</p><p>First, <strong>turn on all compiler warnings</strong>. There is no reason why a 20 line program should produce even a single warning. Warnings are the compiler telling you &quot;this program compiles but does not do what you think it does&quot;, and <em>since that is precisely the situation you are in</em>, it behooves you to pay attention to those warnings.</p><p><strong>Read them very carefully</strong>. If you don't understand why a warning is being produced, that's a good question for StackOverflow because it is a <em>specific question about actual code</em>. Be sure to post the exact text of the warning, the exact code that produces it, and the exact version of the compiler you're using.</p><p>If your program still has a bug, <strong>obtain a rubber duck</strong>. Or if a rubber duck is unavailable, get another computer science undergraduate, it's much the same. Explain to the duck using simple words why each line of each method in your program is obviously correct. At some point you will be unable to do so, either because you don't understand the method you wrote, or because it's wrong, or both. Concentrate your efforts on that method; <em>that's probably where the bug is</em>. Seriously, rubber duck debugging works. And as legendary programmer Raymond Chen points out in a comment below, if you can't explain to the duck why you're executing a particular statement, maybe that's because you started programming before you had a plan of attack.</p><p>Once your program compiles cleanly and the duck doesn't raise any major objections, if there's still a bug then see if you can <strong>break your code up into smaller methods</strong>, each of which does <strong>exactly one logical operation</strong>. A common error amongst all programmers, not just beginners, is to make methods that try to do multiple things and do them poorly. Smaller methods are easier to understand and therefore easier for both you and the duck to see the bugs.</p><p>While you're refactoring your methods into smaller methods, take a minute to <strong>write a technical specification for each method</strong>. Even if it is just a sentence or two, having a specification helps. The technical specification describes what the method does, what legal inputs are, what expected outputs are, what error cases are, and so on. Often by writing a specification you'll realize that you forgot to handle a particular case in a method, and that's the bug.</p><p>If you've still got a bug then first double check that your specifications contain all the <strong>preconditions and postconditions </strong>of every method. A precondition is a thing that has to be true before a method body can work correctly. A postcondition is a thing that has to be true when a method has completed its work. For example, a precondition might be &quot;this argument is a valid non-null pointer&quot; or &quot;the linked list passed in has at least two nodes&quot;, or &quot;this argument is a positive integer&quot;, or whatever. A postcondition might be &quot;the linked list has exactly one fewer item in it than it had on entry&quot;, or &quot;a certain portion of the array is now sorted&quot;, or whatever. A method that has a precondition violated indicates a bug in the caller. A method that has a postcondition violated even when all its preconditions are met indicates a bug in the method. Often by stating your preconditions and postconditions, again, you'll notice a case that you forgot in the method.</p><p>If you've still got a bug then learn how to write <strong>assertions</strong> that verify your preconditions and postconditions. An assertion is like a comment that tells you when a condition is violated; a violated condition is almost always a bug. In C# you can say <code>using System.Diagnostics;</code> at the top of your program and then <code>Debug.Assert(value != null);</code>or whatever. Every language has a mechanism for assertions; get someone to teach you how to use them in your language. Put the precondition assertions at the top of the method body and the postconditions before the method returns. (Note that this is easiest to do if every method has a single point of return.) Now when you run your program, if an assertion fires you will be alerted to the nature of the problem, and it won't be so hard to debug.</p><p>Now <strong>write test cases </strong>for each method that verify that it is behaving correctly. Test each part independently until you have confidence in it. Test a lot of simple cases; if your method sorts lists, try the empty list, a list with one item, two items, three items that are all the same, three items that are in backwards order, and a few long lists. Odds are good that your bug will show up in a simple case, which makes it easier to analyze.</p><p>Finally, if your program still has a bug, <strong>write down on a piece of paper the exact action you expect the program to take on every line of the program for the broken case</strong>. Your program is only twenty lines long. You should be able to write down <em>everything</em> that it does. Now step through the code <strong>using a debugger</strong>, examining every variable at every step of the way, and line for line verify what the program does against your list. If it does anything that's not on your list then either your list has a mistake, in which case you didn't understand what the program does, or your program has a mistake, in which case you coded it wrong. Fix the thing that is wrong. If you don't know how to fix it, at least now you have a specific technical question you can ask on StackOverflow! Either way, iterate on this process until the description of the proper execution of the program and the actual execution of the program match.</p><p>While you are running the code in the debugger I encourage you to <strong>listen to small doubts</strong>. Most programmers have a natural bias to believe their program works as expected, but you are debugging it because that assumption is wrong! Very often I've been debugging a problem and seen out of the corner of my eye the little highlight show up in Visual Studio that means &quot;a memory location was just modified&quot;, and I know that memory location has nothing to do with my problem. So then <em>why was it modified</em>? Don't ignore those nagging doubts; study the odd behaviour until you understand why it is either correct or incorrect.</p><p>If this sounds like a lot of work, that's because it is. If you can't do these techniques on twenty line programs that you wrote yourself you are unlikely to be able to use them on two million line programs written by someone else, but that's the problem that developers in industry have to solve every day. Start practicing!</p><p>And the next time you write an assignment, <strong>write the specification, test cases, preconditions, postconditions and assertions for a method before you write the body of the method!</strong> You are much less likely to have a bug, and if you do have a bug, you are much more likely to be able to find it quickly.</p><p>This methodology will not find every bug in every program, but it is highly effective for the sort of short programs that beginner programmers are assigned as homework. These techniques then scale up to finding bugs in non-trivial programs.</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;每当有人发来一张出错提示框的截图来问我怎么办的时候, 我的内心都是崩溃的.&lt;/p&gt;
&lt;p&gt;对于这种让人摸不着头脑的提问方式, 我真想说: &amp;quot;你把这个问题发到 StackOverflow 上, 两天内没被维护者关闭的话把链接发给我&amp;quot;.&lt;/p&gt;
&lt;p&gt;在
      
    
    </summary>
    
      <category term="技术" scheme="http://suzhouxing.github.io/techive/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="技术" scheme="http://suzhouxing.github.io/techive/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="提问" scheme="http://suzhouxing.github.io/techive/tags/%E6%8F%90%E9%97%AE/"/>
    
  </entry>
  
  <entry>
    <title>原来如此</title>
    <link href="http://suzhouxing.github.io/techive/2017/09/04/ThereAreReasons/"/>
    <id>http://suzhouxing.github.io/techive/2017/09/04/ThereAreReasons/</id>
    <published>2017-09-04T15:36:25.000Z</published>
    <updated>2018-07-01T03:11:17.818Z</updated>
    
    <content type="html"><![CDATA[<p>总有些很简单的事情, 自己已经习以为常了, 别人突然问起为什么反而一下解释不清.</p><p>最近写论文, 导师在改的时候问到, 为什么你的测试分析里面总是测了 8 次 16 次之类的, 正常人不是应该用整十数吗? 我一下子竟然没想到原因, 于是说程序员比较喜欢 2 的整数次幂一点. 后来过了好几天才想起来, 因为实验室的服务器都是 8 核或 64 核的...</p><p>突然又想起以前去微软面试, 突然一下卡住, 说不记得 true 是 0 还是 1 了. 还说自己平常都是用 0 表示正确的状态. 感觉面试官心里肯定在想, 连这点基本常识都没有, 你到底亲自动手写过几行代码? 后来才想起来, 因为运行正常往往只有一个状态, 但是出错可能千奇百怪...</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;总有些很简单的事情, 自己已经习以为常了, 别人突然问起为什么反而一下解释不清.&lt;/p&gt;
&lt;p&gt;最近写论文, 导师在改的时候问到, 为什么你的测试分析里面总是测了 8 次 16 次之类的, 正常人不是应该用整十数吗? 我一下子竟然没想到原因, 于是说程序员比较喜欢 2 的
      
    
    </summary>
    
      <category term="日常" scheme="http://suzhouxing.github.io/techive/categories/%E6%97%A5%E5%B8%B8/"/>
    
    
      <category term="技术" scheme="http://suzhouxing.github.io/techive/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="日常" scheme="http://suzhouxing.github.io/techive/tags/%E6%97%A5%E5%B8%B8/"/>
    
      <category term="面试" scheme="http://suzhouxing.github.io/techive/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="论文" scheme="http://suzhouxing.github.io/techive/tags/%E8%AE%BA%E6%96%87/"/>
    
  </entry>
  
  <entry>
    <title>Hexo 中使用数学公式</title>
    <link href="http://suzhouxing.github.io/techive/2017/09/03/HexoMathSupport/"/>
    <id>http://suzhouxing.github.io/techive/2017/09/03/HexoMathSupport/</id>
    <published>2017-09-03T02:29:59.000Z</published>
    <updated>2018-07-01T03:11:17.813Z</updated>
    
    <content type="html"><![CDATA[<p>为了在 Hexo 生成的网站里面显示 LaTeX 书写风格的数学公式, 尝试了不少方法. 比如官方的 <code>hexo-math</code>, 还有别人提到的 <code>hexo-renderer-mathjax</code>, 以及 <code>hexo-renderer-pandoc</code>. 但是始终不能正确显示数学公式. 最后用安装 <code>hexo-renderer-pandoc</code> 并在每个用到了数学公式的 markdown 文件里添加</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">async</span></span></span><br><span class="line"><span class="tag">  <span class="attr">src</span>=<span class="string">"https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/MathJax.js?config=TeX-MML-AM_CHTML"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>的方式实现了数学公式的渲染. 但是这个方案显然难以令人满意, 我还是更希望有个自动化的方法.</p><h1 id="定位问题">定位问题</h1><p>折腾了半天, 最后发现是 <code>hexo-inject</code> 的问题. 不知道是因为 <code>hexo-inject</code> 的 bug 还是其他原因, 生成的 html 代码里面会出现一些 <code>&lt;!-- hexo-inject:begin --&gt;&lt;!-- hexo-inject:end --&gt;</code>. 在其他地方出现都没什么问题, 因为这段代码在 html 中是注释, 但是在 <code>&lt;script&gt;&lt;/script&gt;</code> 中出现时就会被当成无法解析的 javascript 代码. 于是渲染数学公式时就悲剧了. 另外, 嵌入 Google Analytic 的代码好像也会出现类似的问题, 但是很奇怪百度统计居然没问题.</p><p>后来在 <code>hexo-math</code> 和 <code>hexo-inject</code> 的 issue 里看到 hexo 的维护者说 <code>hexo-inject</code> 跟 <code>hexo-renderer-jade</code> 冲突了.</p><h1 id="解决方案">解决方案</h1><h2 id="删除有-bug-的插件">删除有 bug 的插件</h2><p>执行以下命令删除 <code>hexo-inject</code> 插件, 并默默祈祷没有别的插件或者主题依赖这个插件.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm uninstall hexo-inject --save</span><br></pre></td></tr></table></figure><h2 id="嵌入-mathjax-的代码">嵌入 MathJax 的代码</h2><p>在 <code>themes/maupassant/layout/_partial/head.jade</code> 的末尾添加以下代码.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">script(type=&apos;text/javascript&apos;, src=&quot;https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/MathJax.js?config=TeX-MML-AM_CHTML&quot;, async)</span><br></pre></td></tr></table></figure><p>其中 <code>maupassant</code> 的位置填你自己选择的主题名字. <code>head.jade</code> 是嵌入上面的脚本的位置, 不一定非要在 head 里, 而且后缀可能不同主题的不一样 (使用了不同的引擎). 我这里选择了和主题原有文件一致的后缀, 因为主题已经声明了其依赖的插件, 不用担心无法解析的问题.</p><h1 id="结果">结果</h1><p>下面是配置成功之后的显示效果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$$</span><br><span class="line">\min \sum_&#123;i=0&#125;^&#123;+\infty&#125; \frac&#123;\exp&#123;x^2&#125;&#125;&#123;\sqrt&#123;y&#125;&#125;</span><br><span class="line">$$</span><br></pre></td></tr></table></figure><p><span class="math display">\[\min \sum_{i=0}^{+\infty} \frac{\exp{x^2}}{\sqrt{y}}\]</span></p><h1 id="总结">总结</h1><p>值得一提的是, <code>hexo-math</code> 所依赖的插件 <code>hexo-inject</code> 似乎已经被作者废弃了, 感觉 <code>hexo-math</code> 也因此成了坑. 而且就算 <code>hexo-inject</code> 的 bug 修复了, <code>hexo-math</code> 还有下标需要给下划线加反斜杠转义的问题, 仍然不能和 LaTeX 公式无缝对接.</p><p><code>hexo-renderer-mathjax</code> 作者也多年没有更新, 现在 MathJax 的 CDN 已经不再提供服务, 但是作者一直没有更新可用的地址.</p><p><code>hexo-renderer-pandoc</code> 还依赖第三方软件, 不能使用 npm 统一管理, 确实麻烦了一点. 但是作为一个经常用 Markdown 写初稿或者项目文档, 最后再用 LaTeX 整理论文的人, Typora 和 Pandoc 之类的工具基本上是装机必备, 好像没啥影响.</p><p>最后还是不得不感慨开源项目的最大缺点, 就是很难保证可持续性 -- 依赖的工具更新了它可能不能及时更新已适应新版本, 或者用户发现了 bug 也很难及时修复. 感觉还是有大企业的维护开源项目才能产出最良心最好用的软件.</p><h1 id="参考资料">参考资料</h1><p>[1] https://blog.yuanbin.me/posts/2014/05/play-mathjax-with-pandoc.html</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;为了在 Hexo 生成的网站里面显示 LaTeX 书写风格的数学公式, 尝试了不少方法. 比如官方的 &lt;code&gt;hexo-math&lt;/code&gt;, 还有别人提到的 &lt;code&gt;hexo-renderer-mathjax&lt;/code&gt;, 以及 &lt;code&gt;hexo-rend
      
    
    </summary>
    
      <category term="Hexo" scheme="http://suzhouxing.github.io/techive/categories/Hexo/"/>
    
    
      <category term="技术" scheme="http://suzhouxing.github.io/techive/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="Bug" scheme="http://suzhouxing.github.io/techive/tags/Bug/"/>
    
      <category term="博客" scheme="http://suzhouxing.github.io/techive/tags/%E5%8D%9A%E5%AE%A2/"/>
    
      <category term="Hexo" scheme="http://suzhouxing.github.io/techive/tags/Hexo/"/>
    
      <category term="数学公式" scheme="http://suzhouxing.github.io/techive/tags/%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F/"/>
    
      <category term="MathJax" scheme="http://suzhouxing.github.io/techive/tags/MathJax/"/>
    
      <category term="LaTeX" scheme="http://suzhouxing.github.io/techive/tags/LaTeX/"/>
    
  </entry>
  
  <entry>
    <title>《黑客帝国》中最大的 bug 的合理解释</title>
    <link href="http://suzhouxing.github.io/techive/2017/09/02/FixBugInTheMovieMatrix/"/>
    <id>http://suzhouxing.github.io/techive/2017/09/02/FixBugInTheMovieMatrix/</id>
    <published>2017-09-02T03:07:07.000Z</published>
    <updated>2018-07-01T03:11:17.812Z</updated>
    
    <content type="html"><![CDATA[<p>黑客帝国中最大的 bug, 莫过于 AI 为啥没有把人类统统消灭, 而是用 Matrix 把人类圈养起来了. 如果没有这个背景设定, 电影中的所有故事就都不会发生. 对此, 电影中的解释是 AI 需要利用人类的生物电/热能, 而人类只有被接入虚拟世界才能无公害地稳定供能, 否则会搞破坏或者死亡. 这个理由显然是站不住脚的 -- 人类释放能量, 首先要通过食物吸收更多的能量...</p><p>不过我们可以有另一种解释, 在目前的科技水平下看来稍微合理一点点. 首先要沿用电影的背景, AI 和人类的战争使地球表面被烟雾覆盖, 无法获取太阳能, 自然也不会有水能和风能. 然后在延伸一下, AI 经过计算得出了在当前体系结构下地球上的剩余能源 (核能/地热能等) 将在其发展为星际文明之前耗尽的结论, 为了续命必须省吃俭用节约能源. 人脑是高度集成, 高度并发且高度节能的 &quot;三高&quot; 处理器, AI 希望利用生物计算提高自己的能效. 但是因为硅基生物对碳基生物的研究还不够完善, 体外培养的一大坨神经元并不能像人脑一样完成复杂的计算任务; 而体内的大脑如果没有适当的来自感受器官的刺激会迅速萎缩或者进入类似深度睡眠的抑制状态, 无法提供可接受的运算能力. 因此 AI 不得不模拟一个虚拟世界, 不断给予人脑恰到好处的刺激, 然后利用剩余的脑力运行程序.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;黑客帝国中最大的 bug, 莫过于 AI 为啥没有把人类统统消灭, 而是用 Matrix 把人类圈养起来了. 如果没有这个背景设定, 电影中的所有故事就都不会发生. 对此, 电影中的解释是 AI 需要利用人类的生物电/热能, 而人类只有被接入虚拟世界才能无公害地稳定供能, 
      
    
    </summary>
    
      <category term="异想天开" scheme="http://suzhouxing.github.io/techive/categories/%E5%BC%82%E6%83%B3%E5%A4%A9%E5%BC%80/"/>
    
    
      <category term="异想天开" scheme="http://suzhouxing.github.io/techive/tags/%E5%BC%82%E6%83%B3%E5%A4%A9%E5%BC%80/"/>
    
      <category term="电影" scheme="http://suzhouxing.github.io/techive/tags/%E7%94%B5%E5%BD%B1/"/>
    
      <category term="黑客帝国" scheme="http://suzhouxing.github.io/techive/tags/%E9%BB%91%E5%AE%A2%E5%B8%9D%E5%9B%BD/"/>
    
      <category term="Bug" scheme="http://suzhouxing.github.io/techive/tags/Bug/"/>
    
  </entry>
  
  <entry>
    <title>Hexo 多主题切换</title>
    <link href="http://suzhouxing.github.io/techive/2017/09/02/HexoSwitchThemes/"/>
    <id>http://suzhouxing.github.io/techive/2017/09/02/HexoSwitchThemes/</id>
    <published>2017-09-02T03:00:00.000Z</published>
    <updated>2018-07-01T03:11:17.813Z</updated>
    
    <content type="html"><![CDATA[<p>因为是第一次用 Hexo, 一下子尝试了很多主题. 不断尝试新主题时还挺正常, 但是试得差不多了准备回头选一个自己满意的主题时, 奇葩的事情发生了: 页面显示突然变得非常混乱, 而且有很多之前用过的主题的痕迹.</p><p>搜索 hexo switch theme mess 什么结果都没有. 然后在整个工程目录里面找, 看什么文件被我改乱了. 找着找着发现 <code>db.json</code> 文件里面存了好多东西, 而且里面出现了很多字符串出现了其他主题的名字. 但是看它名字里写着个 &quot;db&quot; 不敢随便删. 搜索这个文件发现有人提到这个文件在 <code>.gitignore</code> 里面被设置了忽略, 看来是个随时可以重新生成的缓存文件了. 果然, 删除 <code>db.json</code> 文件之后就好了.</p><p>后来沉下心来一点一点看官方文档, 看到了一条快速入门教程里没提到的命令:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo clean</span><br></pre></td></tr></table></figure><p>前面直接删 <code>db.json</code> 的方式可能会导致部署的站点时有些多余的文件没被清理掉, 用这个命令就比较彻底了.</p><p>突然想起来最开始尝试的主题还不多时自己也切换过很多次, 但是没发现大问题, 只是有时会发现归档和关于的页面路径不正确, 不知道会不会也是缓存的问题.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;因为是第一次用 Hexo, 一下子尝试了很多主题. 不断尝试新主题时还挺正常, 但是试得差不多了准备回头选一个自己满意的主题时, 奇葩的事情发生了: 页面显示突然变得非常混乱, 而且有很多之前用过的主题的痕迹.&lt;/p&gt;
&lt;p&gt;搜索 hexo switch theme me
      
    
    </summary>
    
      <category term="Hexo" scheme="http://suzhouxing.github.io/techive/categories/Hexo/"/>
    
    
      <category term="技术" scheme="http://suzhouxing.github.io/techive/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="Bug" scheme="http://suzhouxing.github.io/techive/tags/Bug/"/>
    
      <category term="博客" scheme="http://suzhouxing.github.io/techive/tags/%E5%8D%9A%E5%AE%A2/"/>
    
      <category term="Hexo" scheme="http://suzhouxing.github.io/techive/tags/Hexo/"/>
    
      <category term="主题" scheme="http://suzhouxing.github.io/techive/tags/%E4%B8%BB%E9%A2%98/"/>
    
      <category term="缓存" scheme="http://suzhouxing.github.io/techive/tags/%E7%BC%93%E5%AD%98/"/>
    
  </entry>
  
</feed>
