---
title: 组合优化算法简介
date: 2019-01-13 11:10:16
categories:
- 技术
tags:
- 建模
- 优化
- 技术
- 数学
---
由于生产实践中面临的绝大多数具有实际意义的组合优化问题都已经在理论上被证明属于难以使用可接受的计算资源在可接受的时间内求解的 NP-Hard 问题, 其求解算法不像 P 问题一样存在标准答案.
此外, 在实际的工业应用中, 由于未来的不确定性以及评价指标常常无法完美量化等问题, 耗费大量计算资源和实践精确求出最优解几乎没有实际意义.
所以, 组合优化算法的设计往往是在优度与速度之间寻找平衡点.



# 具体求解算法设计

## 预处理

- 使用最短路或k短路将必经节点两两连起来，转换为TSP
  - 如何避免重复访问节点
  - 如果重复访问节点不可避免，如何修复
- 寻找关键节点或关键路径
  - 将问题拆分成两个规模较小的子问题
  - 在搜索时重点考虑关键节点和边


## 精确算法

- 分支限界 = 可行性剪枝 + 最优性剪枝 + 分支顺序
- 最优子结构
  - 动态规划求TSP? 复杂度中包含取值范围! 伪多项式复杂度



## 元启发式算法

## 概述

- 分类 (参考维基百科 https://upload.wikimedia.org/wikipedia/commons/c/c3/Metaheuristics_classification.svg)
  ![Classification](MetaheuristicsClassification.svg)
- 基本思想
  - 在 系统地探索整个解空间 和 盲目地探索邻近的解空间 之间寻找平衡点
  - 集中性 与 疏散性 的平衡
  - 时空开销 与 求解质量 的平衡
- 邻域动作 : 尝试对解向量做微小的改变
  - 在一次迭代中每一个决策变量都可以改变 : 精确算法
  - 在一次迭代中仅改变一个决策变量 : 原子邻域动作
  - 寻找两者的平衡点 : 集中性与疏散性的平衡
- 禁忌搜索过程  
    ![TS](TS.png)
  - 使用贪心算法或随机生成一个初始解
  - 每次从当前解移动到某个邻居解，直至一定步数不能改进
  - 然后进行扰动，贪心或随机地对解向量做更改，重复上述过程
- 元启发式算法框架  
    ![Framework](Framework.png)
  - 算法层为整个程序的框架，比如迭代局部搜索、遗传算法、混合进化算法等。
      算法层决定了使用那些搜索策略，搜索策略之间以什么次序出现，每个搜索策略的停止条件是什么。
  - 搜索层是具体的搜索算法，执行一次搜索会产生一条搜索路径。随机游走、模拟退火、局部搜索、禁忌搜索等都是搜索层的组件。
    从广义上来说，构造初始解、迭代局部搜索中的扰动过程、遗传算法中的交叉算子都是搜索层的组件。
    在搜索过程中，要考虑的主要问题是每次迭代选择什么邻域结构进行探索，以及决定停止搜索的策略。
    这里说的策略和前面算法层说的停止条件不同，策略决定条件该怎么设置，比如TS的策略是一定步数未改进就停止，而停止条件是一个特定的最大未改进步数。
  - 邻域动作选择一般是搜索过程中对算法性能影响最大的模块。
    它通过循环调用邻域动作评估层的组件对考虑范围之内的邻域动作对目标函数值的改变情况进行评估，然后按照某种策略挑选其中的一个动作。
    最常见的挑选策略有首次改进（first improvement）和最优改进（best improvement）。此外，还可以有导向性地或者随机地在整个邻域中挑选一部分邻域动作进行评估。
  - 邻域动作评估可以是结合特殊的数据结构进行增量评估或者全部重算。在绝大多数情况下增量评估的速度会远快于全部重算。
  - 邻域动作的执行比较简单，主要有更新解向量、更新辅助数据结构、更新禁忌表、更新缓存标记位和更新历史最优解等操作。
    其中更新历史最优主要是处理目标函数值相同的情况，可以随机选择，也可以设计辅助目标函数进行处理。
    别看操作很多，大多数操作都是O(1)的时间复杂度，如果算法很复杂一般也不会超过O(n)，所以这一部分其实相对来说是比较简单的。
  - 邻域动作的评估和执行都跟邻域结构的设计有很大关联
- 邻域动作举例
  - Boolean Satisfiability Problem (SAT)
  - Graph Coloring Problem
  - Personnel Scheduling Prblem
  - Capacitated P-Median Problem
  - Traveling Salesman Problem (TSP)
- 局部搜索
  - 迭代局部搜索
  - 禁忌搜索
  - 模拟退火
- 种群算法
  - 遗传算法、进化算法、模因算法
  - 蚁群算法、蜂群算法

### 初始解

- 贪心
  - 有利于快速收敛
  - 不利于初始解的多样性
- 随机

### 禁忌搜索

- 邻域结构设计
  - 原子邻域动作
  - 复合邻域动作
- 邻域动作选择策略
  - 单个邻域
    - 首次改进 (First Improvement)
    - 最大改进 (Best Improvement)
      - 多个目标函数增量相同的最优动作随机选择一个 ([水塘抽样](https://en.wikipedia.org/wiki/Reservoir_sampling))
    - 邻域抽样
  - 多邻域
    - 变邻域搜索 (VNS)
    - 根据适应性选择最合适的邻域
      - 根据历史情况
      - 根据抽样结果
    - 随机选择
- 禁忌策略
  - 禁忌表
    - 如果一个邻域动作被执行则禁止其逆操作在段时间内被选中
      - 刚增加则禁止马上被删除
      - 刚交换防止马上被换回来
    - 为其逆操作
  - 禁忌步长
    - 可能与问题规模、禁忌表大小、目标函数值、邻域动作出现次数相关
    - 一般需要加上随机成分
    - 具体实现时将禁忌多久转换为什么时候解禁
  - 解禁策略
    - 如果被禁忌的邻域动作是当前邻域的最优动作且能够改进历史最优解则允许其被执行
- 目标函数值计算
  - 因为仅对解向量做了微小的改变，所以目标函数中大多数项目并未改变，故可以进行增量评估
  - 在邻域动作执行后，大多数邻域动作与被改变的决策变量并不相关，其增量无需重新计算，故可以将其缓存起来
    - 主动更新 : 每次执行邻域动作后更新所有相关动作的增量
    - 惰性更新 : 使用标记位记录缓存是否失效，需要比较相关动作的增量时再更新

### 扰动

- 重新构造初始解
  - 需要初始解生成程序具有一定的随机性
  - 与之前的搜索完全无关，无法利用已有的搜索结果
- 贪心或随机地更改解向量中的部分元素
- 交叉算符
  - 将多个解向量中较优的子结构进行组合


## 混合整数规划

- 概述
  - 对于一组给定的自变量，确定其取值，使其在满足给定不等式组的前提下，给定的函数取到最小值
  - 决策变量的定义域可以是实数 (连续变量) 也可以是整数 (离散变量)
- 编程范式与原理简介
  - http://www.gurobi.com/resources/getting-started/lp-basics
  - http://www.gurobi.com/resources/getting-started/mip-basics
- 不同的表现形式
  - 线形规划模型的标准形式  
      ![StdForm](LP1.png)
  - 图形表示  
      ![GraphRep](LP2.png)
  - 矩阵表示  
      ![MatrixRep](LP3.png)
  - 使用方法
    - 使用专门的建模语言
      - https://www.gurobi.com/documentation/6.5/refman/model_file_formats.html
      - 举例 : [coin](qafiro.lp) 
    - 使用命令行接口
    - 使用应用程序接口
      - 添加决策变量
      - 添加目标函数
      - 添加约束
      - 求解
      - 获取决策变量取值



# 算法运行模式对比

- 树搜索
  ![TreeSearch](TreeSearch.png)
- 动态规划
  ![DynamicProgramming](DynamicProgramming.png)
- 局部搜索
  ![LocalSearch](LocalSearch.png)



# 算法工程模块清单

- 通用
  - 验证程序
    - 合法性
    - 目标函数值计算正确
  - 日志记录
  - 统计分析
- 求解器
  - 数学模型
  - 编程实现
- 启发式
  - 初始解
    - 随机
    - 贪心
  - 局部搜索
    - 邻域评估
      - 增量评估
      - 邻域动作目标函数增量缓存
      - 邻域动作优先队列
    - 邻域动作选择
    - 邻域动作执行
  - 禁忌策略
    - 禁忌表
    - 解禁策略
  - 扰动策略
