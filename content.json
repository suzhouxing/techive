{"meta":{"title":"Techive","subtitle":"An Archive for Technologies","description":"An Archive for Technologies by Zhouxing Su","author":"Zhouxing Su","url":"http://suzhouxing.github.io/techive"},"pages":[{"title":"About Me","date":"2017-09-02T11:25:24.000Z","updated":"2018-07-01T03:11:17.818Z","comments":true,"path":"about/index.html","permalink":"http://suzhouxing.github.io/techive/about/index.html","excerpt":"","text":"我就是我."}],"posts":[{"title":"Gitee 渲染 CSV 文件","slug":"GiteeCsvSupport","date":"2022-05-30T04:40:57.000Z","updated":"2022-05-30T08:18:05.044Z","comments":true,"path":"2022/05/30/GiteeCsvSupport/","link":"","permalink":"http://suzhouxing.github.io/techive/2022/05/30/GiteeCsvSupport/","excerpt":"","text":"使用 Gitee 挺长一段时间了, 感觉它是一个非常优秀的国内免费代码托管平台. 美中不足的是, 它不支持对常见的数据文件格式进行渲染. 其中就有 CSV 等纯文本表格文件, 在没有按列对齐的情况下可读性相对较低. 作为一个程序员, 当然要自己动手丰衣足食. 下面简单记录一下我的魔改方案. 此外, 顺便夹带一点关于表格 CSS 样式设置的小技巧. 使用浏览器书签手动格式化 其实浏览器的书签有一个隐藏功能, 就是执行 javascript 代码. 具体地, 若书签的 URL 以 javascript: 开头, 则后面的部分将被视为 javascript 代码, 打开书签将运行相关代码. 利用这个隐藏功能, 我们可以使用下面的 javascript 代码对 CSV 文件预览页面进行格式化. 1javascript:if (window.location.href.endsWith(\".csv\")) &#123; let box = document.getElementsByTagName(\"pre\")[0]; let lines = box.getElementsByClassName(\"line\"); let tb = \"&lt;table&gt;\"; for (let line of lines) &#123; let words = line.innerHTML.split(\",\"); tb += \"&lt;tr&gt;\"; for (let word of words) &#123; tb += \"&lt;td&gt;\" + word + \"&lt;/td&gt;\"; &#125; tb += \"&lt;/tr&gt;\"; &#125; tb += \"&lt;/table&gt;\"; box.innerHTML = tb; let sty = document.createElement(\"style\"); sty.innerHTML = \"table &#123; border-collapse: collapse; border-spacing: 0; &#125; td &#123; max-width: 5em; padding: 2px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; &#125; td:nth-child(1) &#123; max-width: 16em; &#125; tr:nth-child(odd) &#123; background-color: #eee; &#125; tr:nth-child(even) &#123; background-color: #fff; &#125;\"; document.head.append(sty); &#125; 具体地, 可以参考下图添加书签, 书签名称随便填自己记得住的名字, URL 栏粘贴上面的代码. 之后在 CSV 文件展示页面加载完毕后点击该书签, 将以表格形式展示 CSV 文件, 得到下图所示的效果. 使用浏览器插件自动格式化 基于同样的原理, 我们还可以利用 TamperMonkey 等插件实现自动格式化. TamperMonkey 等插件本质上是一个简化插件开发的插件, 它让用户可以自己编写代码, 在页面加载后对 DOM 结构进行操作. 具体地, 安装好插件后, 点击新建脚本. 复制下面的代码粘贴到代码编辑框后, 点击保存脚本. 之后打开 CSV 文件便可自动将其渲染为表格的形式. 12345678910111213141516171819202122232425262728293031// ==UserScript==// @name Gitee CSV Formatter// @namespace http://tampermonkey.net/// @version 0.1// @description try to take over the world!// @author szx// @match *://gitee.com/*.csv// @grant none// ==/UserScript==(function() &#123; 'use strict'; let box = document.getElementsByTagName(\"pre\")[0]; let lines = box.getElementsByClassName(\"line\"); let tb = \"&lt;table&gt;\"; for (let line of lines) &#123; let words = line.innerHTML.split(\",\"); tb += \"&lt;tr&gt;\"; for (let word of words) &#123; tb += \"&lt;td&gt;\" + word + \"&lt;/td&gt;\"; &#125; tb += \"&lt;/tr&gt;\"; &#125; tb += \"&lt;/table&gt;\"; box.innerHTML = tb; let sty = document.createElement(\"style\"); sty.innerHTML = \"table &#123; border-collapse: collapse; border-spacing: 0; &#125; td &#123; max-width: 5em; padding: 2px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; &#125; td:nth-child(1) &#123; max-width: 16em; &#125; tr:(odd) &#123; background-color: #eee; &#125; tr:nth-child(even) &#123; background-color: #fff; &#125;\"; document.head.append(sty);&#125;)(); 其中, @match 一行比较重要, 决定了执行该代码的条件, 即哪些 URL 符合执行条件. 此处设置为 gitee.com 内以 .csv 结尾的 URL. 此外, 表格的 CSS 样式中有个很实用的选择器 nth-child. 该选择器接受一个参数, 取值可以是 odd, even, 或 an+b (a 和 b 为正整数, 表示除 a 模 b 的所有正整数). 该选择器可以实现两行甚至多行交错显示不同样式, 或者自动对首行设置特殊样式.","categories":[{"name":"技术","slug":"技术","permalink":"http://suzhouxing.github.io/techive/categories/技术/"}],"tags":[{"name":"技术","slug":"技术","permalink":"http://suzhouxing.github.io/techive/tags/技术/"},{"name":"编程","slug":"编程","permalink":"http://suzhouxing.github.io/techive/tags/编程/"},{"name":"Git","slug":"Git","permalink":"http://suzhouxing.github.io/techive/tags/Git/"}]},{"title":"SmartLab Challenge - ReadMe","slug":"Contest-ReadMe","date":"2022-05-26T14:21:04.000Z","updated":"2022-06-05T02:56:33.524Z","comments":true,"path":"2022/05/26/Contest-ReadMe/","link":"","permalink":"http://suzhouxing.github.io/techive/2022/05/26/Contest-ReadMe/","excerpt":"","text":"与本科数据结构和算法设计与分析课程中学习的 P 问题不同, NP 难组合优化问题的计算复杂度随问题规模增长及其迅速. 因此, 在具有现实意义的问题实例上, NP 难组合优化问题的求解算法不仅有对错之分, 还有优劣之分. 由于 NP 难问题的计算复杂性, 有实际应用价值的算法通常不像 P 问题的求解是一个确定的过程, 得到正确的结果后退出. 相反地, NP 难问题的优化算法需要在计算时间与结果优度之间寻找合适的平衡点, 因此往往使用具有随机性的迭代优化的启发式算法. 为确保结果的可重现性, 启发式算法通常需要支持设置随机种子, 而其停止条件通常为由用户指定计算时间上限, 以避免对庞大的解空间进行永无止尽的探索. 此外, 相比于 P 问题求解算法的简明扼要, NP 难问题的求解算法往往是个庞大的工程, 同时有可能作为子模块接入到更复杂的系统中, 因此还需要满足软件工程的要求. 下面, 我们将以中心选址问题为例, 简单介绍本 NP 难组合优化问题算法测试平台的基本功能与使用方式. 问题描述 本平台支持的 NP 难问题清单参见 http://suzhouxing.gitee.io/techive/tags/Challenge/. 各问题描述页面内的 \"参考文献\" 一节给出了相对高效的启发式算法的学术论文, 一般直接重现第一篇能求得较好的计算结果. 请仔细阅读问题描述页面内的 \"提交要求\" 一节, 不符合要求的提交不会进行测试. SDK 算法接口概述 在问题描述页面的 \"提交要求\" 一节可以找到中心选址问题求解算法的 SDK 下载链接 https://gitee.com/suzhouxing/npbenchmark/tree/main/SDK.PCP. SDK 一般包含 3 个源文件, 其用途与内容如下: Main.cpp (禁止修改). 算法可执行文件调用入口. 所有问题均包含该文件. 用于平台调用算法进行测试. loadInput 与 saveOutput 函数为符合提交要求的算例读取和结果输出函数. test 函数为测试程序入口, 可参考 main 函数中的注释从文件读取算例以便在本地批量测试. PCenter.h (禁止修改). 算法函数接口. 根据问题名称命名. 定义 API 以便将该问题的求解算法作为子模块由其他系统调用. PCenter 类为输入数据. Centers 类为输出数据. solvePCenter 函数为算法函数接口. 算法应根据参数 input 给出的输入数据进行求解. 将计算结果保存至参数 output 中. 使用参数 isTimeout 函数对象判断是否超时. 使用参数 seed 设置随机种子. PCenter.cpp (可修改). 算法函数实现. 与算法函数接口头文件名称相同. 填写 Solver::solve 函数实现求解算法. 自行添加其他源文件. 后续平台将变更为提交源码自动编译测试, 请保持工程目录结构, 包含头文件时请使用相对路径. 示例代码详解 求解接口 solvePCenter 函数中仅一行 Solver().solve(output, input, isTimeout, seed);, 所有变量均应定义于 Solver 类的作用域内, 禁止出现全局变量, 否则不满足可并发和可重入的要求. Solver::solve 函数中, 首先使用 initRand(seed); 初始化随机数生成器, 然后自行填写求解算法代码. 与大多数问题的示例代码不同, 中心选址问题的 SDK 由于已经内置了优化转判定的求解框架, Solver::solve 函数相对更加复杂. 其中 coverAllNodesUnderFixedRadius 函数与其他问题的 Solver::solve 函数内容相似, 为判定版本问题的求解算法, 也是该问题的算法内核. Solver::solve 函数首先调用一次判定版本的算法完成初始半径下的中心选择, 然后不断缩小覆盖半径. 每次缩小覆盖半径时增量移除每个候选中心无法覆盖到的客户, 得到新的判定问题. coverAllNodesUnderFixedRadius 函数从所有节点中随机挑选中心, 直到 isTimeout 函数对象报告超时或达到输入数据指定的中心数. 注意, 测试平台的超时判断机制使用现实世界时间, 而非 CPU 时间. 显然, 该过程难以得到可行的中心选址方案, 需要将其替换为高效的优化算法. 在求解过程中或完成后, 可以使用标准错误输出 cerr 打印调试信息, 而不会影响测试平台读取计算结果. 建议提交前屏蔽相关代码以提高算法执行效率. 提交 系统处于空闲状态时, 每隔 15 分钟检查一次邮箱 (避免测试过程中进行下载邮件等操作占用 CPU 影响他人的测试结果). 按照问题描述页面的 \"提交要求\" 一节成功发送邮件并被系统拉取后, 将收到系统的自动回复, 提示当前待测试的提交数. 一次拉取若发现同一姓名或邮箱地址多次提交了同一问题的求解算法, 仅对最后一次提交的版本进行测试. 每个提交在系统中可能经历 3 种状态, 分别是已拉取待测试 (Pending), 正在测试 (Running), 测试完成 (Finished). 可在 https://gitee.com/suzhouxing/npbenchmark.data/blob/data/Queue.md 页面查看平台上测试任务的排队状态. 每个算例会使用不同随机种子进行多次独立重复测试 (一般为 5-10 次), 每次独立重复测试的超时时间依次递增. 超时时间和随机种子由两个命令行参数依次给出. 达到超时时间后, 平台将额外等待 2 秒, 若程序仍未自行退出, 将向程序发送 SIGINT 信号, 等待 1 秒若仍未结束运行则再次发送 SIGINT 信号, 等待 2 秒若还未退出则强行终止进程. 若基于 SDK 开发一般无需处理 SIGINT 信号. ⯈ 处理 SIGINT 信号 如确实有需要, 可参考如下代码设置中断信号的响应函数, 以便在收到信号时保存解或设置结束求解的标记位. 由于相关接口属于 C 语言标准库, 不支持闭包, 必须使用全局变量, 不满足提交要求, 因此强烈建议不使用该机制. 12345678910#include &lt;csignal&gt;#include &lt;cstdlib&gt;void signalHandler(int) &#123; // save solution or set stopping flag. exit(0);&#125;int main(int argc, char* argv[]) &#123; signal(SIGINT, signalHandler); return 0;&#125; 此外, 收到信号时保存解可能出现数据竞争 (https://www.gnu.org/software/libc/manual/html_node/Non_002datomic-Example.html), 必须对解向量的读写加锁, 反而开销更大. 若采用设置标记位的方案, 仍需在主循环中反复检查标记位, 其开销与判断计时器超时相比没有显著优势. 后续采用源码提交后, 将为 solve 函数添加报告计算结果的接口, 使用更精确的方式记录求到最优解的时间, 同时返回是否可以停止求解的建议 (例如已求得最优解可提前退出节约时间). 后续将对测试用例进行小幅随机等价变换 (重编号, 添加冗余, 化简等), 以避免针对算例过度调参. 所有问题的测试用例均划分为 3 个难度级别. 平台会统计每个难度级别所有算例上的: 命中排行榜上的最优结果的比例 (越高越好), 求得可行解的比例 (越高越好), 超时比例 (越低越好) 等指标. 简单难度的算例上述指标达到预设的阈值后才会测试更困难的算例, 否则将停止测试以节约时间 (因为困难算例大概率计算结果会更差). 测试完成后, 将自动回复如下图所示的详细计算结果. 其中第 1 列为算例名, 第 2 列为目标函数值, 第 3 列为算法从启动到退出的耗时. 之后若干列每个问题均不一样, 主要提示约束违反情况. 例如, 中心选址问题中, Center 列表示输出的中心数, 若大于输入数据规定的数量则为不可行解, 目标函数值将被设置为充分大数; UncoveredNode 列表示未覆盖的客户数, 若大于 0 则为不可行解, 目标函数值将被设置为充分大数. 排行榜 目前提供 Rank 和 Leaderboard 两种计算结果统计视图, 导航页面见 https://gitee.com/suzhouxing/npbenchmark.data/tree/data. Rank 视图以算例为中心, 列出每个算例上的最好结果 (前 10 名). Leaderboard 视图以提交为中心, 对每个问题的每个提交在所有算例上的整体结果进行评分与排序. 由于目前使用的托管平台不支持 csv 文件的渲染, 可以下载后使用 Excel 等软件打开. 也可以参考 (Gitee 渲染 CSV 文件) 将其格式化以直接在网页中查看, 得到下图所示的展示效果.","categories":[{"name":"算法挑战","slug":"算法挑战","permalink":"http://suzhouxing.github.io/techive/categories/算法挑战/"}],"tags":[{"name":"Challenge","slug":"Challenge","permalink":"http://suzhouxing.github.io/techive/tags/Challenge/"},{"name":"算法挑战","slug":"算法挑战","permalink":"http://suzhouxing.github.io/techive/tags/算法挑战/"},{"name":"组合优化","slug":"组合优化","permalink":"http://suzhouxing.github.io/techive/tags/组合优化/"}]},{"title":"SmartLab Challenge 2023 - Packing Equal Circles in a Circle Problem","slug":"Contest-2023PECCP","date":"2022-04-28T13:14:35.000Z","updated":"2022-06-01T08:54:04.188Z","comments":true,"path":"2022/04/28/Contest-2023PECCP/","link":"","permalink":"http://suzhouxing.github.io/techive/2022/04/28/Contest-2023PECCP/","excerpt":"","text":"圆形容器内的等圆装配问题在众多领域中有广泛的应用, 可以用来对多种组合优化问题进行建模. 圆形容器内的等圆装配问题主要研究使用大圆装小圆的问题. 例如, 光纤电缆的制造与建筑材料运输等众多应用场景都可以建模为等圆装配问题. 在理论上, 等圆装配问题是经典的非线性连续优化问题, 其求解算法往往还涉及物理系统模拟. 高效的等圆装配问题求解算法具有极其重要的理论与应用价值. 圆形容器内的等圆装配算法训练 问题概述 给定若干单位圆, 请将其无重叠地放置于一个圆形容器内, 使该圆形容器的半径最小 (即容器半径与等圆半径的比例最小). 参考文献. [1] X. Lai, J.-K. Hao, D. Yue, Z. Lü, and Z.-H. Fu, “Iterated dynamic thresholding search for packing equal circles into a circular container,” European Journal of Operational Research, vol. 299, no. 1, pp. 137–153, May 2022, doi: 10.1016/j.ejor.2021.08.044. [2] http://www.packomania.com 命令行参数 请大家编写程序时支持两个命令行参数, 依次为运行时间上限 (单位为秒) 和随机种子 (0-65535). 算例文件已重定向至标准输入 stdin/cin, 标准输出 stdout/cout 已重定向至解文件 (如需打印调试信息, 请使用标准错误输出 stderr/cerr). 例如, 在控制台运行以下命令表示调用可执行文件 peccp.exe 在限时 600 秒, 随机种子为 12345 的情况下求解路径为 ../data/n50.txt 的算例, 解文件输出至 sln.n50.txt: 1peccp.exe 600 123456 &lt;../data/n50.txt &gt;sln.n50.txt 运行时间上限. 超出运行时间上限后测试程序会强行终止算法, 请确保在此之前已输出解 (最好还能自行正常退出). 随机种子设置. 使用 C 语言随机数生成器请用 srand. 使用 C++ 随机数生成器 (如 mt19937) 请在构造时传参或调用 seed() 方法设置. 输入的算例文件格式 单独一行给出 3 个由空白字符分隔的整数, 分别表示单位圆数 N, 文献中的最优容器与等圆半径的比例 R, 用于判断单位圆是否重叠的数值误差上限 E (不超过 double 类型的精度). 事实上, 测试平台并不会进行重叠检查, 而是直接计算最小间距得到不重叠的最大半径, 故正常情况下数值误差上限 E 没有实质性作用, 仅供参考. 例如, 以下算例文件表示需放置 2 个单位圆, 圆心距大于 2.0 - 1e-15 时认为两圆不相交, 若等圆半径为 1 则大圆半径为 2. 12 2.0 1e-15 ⯈ 验证浮点数精度 运行下面代码可以发现, 当 x &lt; 1e-16 后, 2 - x == 2 为真, 即 double 的有效数字位数不超过 16 位. 这意味着两个大于 1 的数若差值在 1e-16 之内, 其 double 类型的二进制表示相同. 12345#include &lt;stdio.h&gt;void main() &#123; for (double x = 1; x &gt; 1e-20; x /= 10) &#123; printf(&quot;%e: %d\\n&quot;, x, ((2 - x) == 2)); &#125; for (double x = 1; x &gt; 1e-20; x /= 2) &#123; printf(&quot;%e: %d\\n&quot;, x, ((2 - x) == 2)); &#125;&#125; 输出的解文件格式 输出 N 行整数表示 N 个等圆相对容器圆心 (0, 0) 的位置, 第 i 行表示第 i 个等圆的圆心坐标. 每行 2 个由空白字符分隔的整数, 分别为第 i 个等圆的圆心横坐标和圆心纵坐标. 其中坐标支持两种格式: (1) 所有等圆与容器圆心距均小于 1, 表示容器半径为 1, 最大化等圆的半径 r; (2) 存在等圆与容器圆心距大于等于 1, 表示等圆半径为 1, 最小化容器的半径 R. 显然 r:1 = 1:R. 例如, 以下解文件表示 2 个半径为 1 的等圆圆心坐标分别为 (0, -1) 和 (0, 1), 容器半径为 2: 120 -10 1 上述解文件与以下解文件等价, 即 2 个半径为 0.5 的等圆圆心坐标分别为 (0, -0.5) 和 (0, 0.5), 容器半径为 1: 120 -0.50 0.5 提交要求 发送至邮箱 szx@duhe.tech. 邮件标题格式为 \"Challenge2023PECCP-姓名-学校-专业\". 邮件附件为单个压缩包 (文件大小 2M 以内), 文件名为 \"姓名-学校-专业\", 其内包含下列文件. 必要 算法的可执行文件 (Windows 平台). 建议基于官方 SDK 开发 (https://gitee.com/suzhouxing/npbenchmark/tree/main/SDK.PECCP). 用 g++ 的同学编译时建议静态链接, 即添加 -static-libgcc -static-libstdc++ 编译选项. 必要 算法源码. 可重入 (可在同一线程内反复调用而不会出现数据初始化错误或内存泄漏). 可并发 (可在同一进程内的多个线程同时运行多个算法求解实例而互不干扰, 满足此要求一般不能有全局的非只读变量). 可伸缩 (数据结构可以根据算例规模动态申请内存, 而非根据预先指定的编译期常量进行内存分配). 可选 算法在各算例上的运行情况概要, 至少包括以下几项信息 (可选, 仅在无法成功调用算法输出可通过检查程序的解时作为参考). 算例名. 容器半径 (大于等于 1) 或等圆半径 (小于 1). 计算耗时. 可选 算法在各算例上求得的颜色数最少的解文件 (可选, 仅在无法成功调用算法输出可通过检查程序的解时作为参考). 若成功提交, 在收到邮件时以及测试完成后系统均会自动发送邮件反馈提交情况. 若测试结果较优, 可在排行榜页面看到自己的运行情况 (https://gitee.com/suzhouxing/npbenchmark.data/tree/data/PECCP). 其他说明参考 (SmartLab Challenge - ReadMe). 例如: 12345678910111213苏宙行-华科-计科.zip| peccp.exe| results.csv|+---src| main.cpp| algorithm.cpp| algorithm.h|+---results n50.txt n51.txt ... 算例清单 下载地址: https://gitee.com/suzhouxing/npbenchmark.data/tree/data/PECCP/Instance 算例规模从小到大依次为 (求解难度不一定随规模增加): n50 n51 n52 n53 n54 n55 n56 n57 n58 n59 n60 n61 n62 n63 n64 n65 n66 n67 n68 n69 n70 n71 n72 n73 n74 n75 n76 n77 n78 n79 n80 n81 n82 n83 n84 n85 n86 n87 n88 n89 n90 n91 n92 n93 n94 n95 n96 n97 n98 n99 n100 n101 n102 n103 n104 n105 n106 n107 n108 n109 n110 n111 n112 n113 n114 n115 n116 n117 n118 n119 n120 n121 n122 n123 n124 n125 n126 n127 n128 n129 n130 n131 n132 n133 n134 n135 n136 n137 n138 n139 n140 n141 n142 n143 n144 n145 n146 n147 n148 n149 n150 n151 n152 n153 n154 n155 n156 n157 n158 n159 n160 n161 n162 n163 n164 n165 n166 n167 n168 n169 n170 n171 n172 n173 n174 n175 n176 n177 n178 n179 n180 n181 n182 n183 n184 n185 n186 n187 n188 n189 n190 n191 n192 n193 n194 n195 n196 n197 n198 n199 n200 n201 n202 n203 n204 n205 n206 n207 n208 n209 n210 n211 n212 n213 n214 n215 n216 n217 n218 n219 n220 n221 n222 n223 n224 n225 n226 n227 n228 n229 n230 n231 n232 n233 n234 n235 n236 n237 n238 n239 n240 n241 n242 n243 n244 n245 n246 n247 n248 n249 n950 n951 n952 n953 n954 n955 n956 n957 n958 n959 n960 n961 n962 n963 n964 n965 n966 n967 n968 n969 n970 n971 n972 n973 n974 n975 n976 n977 n978 n979 n980 n981 n982 n983 n984 n985 n986 n987 n988 n989 n990 n991 n992 n993 n994 n995 n996 n997 n998 n999 n1000 n1001 n1002 n1003 n1004 n1005 n1006 n1007 n1008 n1009 n1010 n1011 n1012 n1013 n1014 n1015 n1016 n1017 n1018 n1019 n1020 n1021 n1022 n1023 n1024 n1025 n1026 n1027 n1028 n1029 n1030 n1031 n1032 n1033 n1034 n1035 n1036 n1037 n1038 n1039 n1040 n1041 n1042 n1043 n1044 n1045 n1046 n1047 n1048 n1049 n1950 n1951 n1952 n1953 n1954 n1955 n1956 n1957 n1958 n1959 n1960 n1961 n1962 n1963 n1964 n1965 n1966 n1967 n1968 n1969 n1970 n1971 n1972 n1973 n1974 n1975 n1976 n1977 n1978 n1979 n1980 n1981 n1982 n1983 n1984 n1985 n1986 n1987 n1988 n1989 n1990 n1991 n1992 n1993 n1994 n1995 n1996 n1997 n1998 n1999 n2000 n2001 n2002 n2003 n2004 n2005 n2006 n2007 n2008 n2009 n2010 n2011 n2012 n2013 n2014 n2015 n2016 n2017 n2018 n2019 n2020 n2021 n2022 n2023 n2024 n2025 n2026 n2027 n2028 n2029 n2030 n2031 n2032 n2033 n2034 n2035 n2036 n2037 n2038 n2039 n2040 n2041 n2042 n2043 n2044 n2045 n2046 n2047 n2048 n2049","categories":[{"name":"算法挑战","slug":"算法挑战","permalink":"http://suzhouxing.github.io/techive/categories/算法挑战/"}],"tags":[{"name":"Challenge","slug":"Challenge","permalink":"http://suzhouxing.github.io/techive/tags/Challenge/"},{"name":"算法挑战","slug":"算法挑战","permalink":"http://suzhouxing.github.io/techive/tags/算法挑战/"},{"name":"组合优化","slug":"组合优化","permalink":"http://suzhouxing.github.io/techive/tags/组合优化/"}]},{"title":"SmartLab Challenge 2022 - Minimum Connected Dominating Sets","slug":"Contest-2022MCDSP","date":"2022-04-23T07:41:35.000Z","updated":"2022-05-27T10:12:48.401Z","comments":true,"path":"2022/04/23/Contest-2022MCDSP/","link":"","permalink":"http://suzhouxing.github.io/techive/2022/04/23/Contest-2022MCDSP/","excerpt":"","text":"最小连通支配集问题在众多领域中有广泛的应用, 可以用来对多种组合优化问题进行建模. 最小连通支配集问题主要研究如何挑选一系列紧密相连的节点为其他节点提供服务的问题. 例如, 通信网络, 能源传输, 物流调拨等众多行业中的选址都可以用最小连通支配集问题进行建模. 高效的最小连通支配集问题求解算法具有极其重要的理论与应用价值. 最小连通支配集算法训练 问题概述 给定一个无向图, 请挑选一个节点数最少的连通分量, 使所有节点均与该连通分量中的至少一个节点相邻. 参考文献. [1] X. Wu, Z. Lü, and F. Glover, “A Fast Vertex Weighting-Based Local Search for Finding Minimum Connected Dominating Sets,” INFORMS Journal on Computing, vol. 34, no. 2, pp. 817–833, Mar. 2022, doi: 10.1287/ijoc.2021.1106. [2] X. Wu, Z. Lü, and P. Galinier, “Restricted swap-based neighborhood search for the minimum connected dominating set problem,” Networks, vol. 69, no. 2, pp. 222–236, Mar. 2017, doi: 10.1002/net.21728. 命令行参数 请大家编写程序时支持两个命令行参数, 依次为运行时间上限 (单位为秒) 和随机种子 (0-65535). 算例文件已重定向至标准输入 stdin/cin, 标准输出 stdout/cout 已重定向至解文件 (如需打印调试信息, 请使用标准错误输出 stderr/cerr). 例如, 在控制台运行以下命令表示调用可执行文件 mcdsp.exe 在限时 600 秒, 随机种子为 12345 的情况下求解路径为 ../data/LMS.n30e44.txt 的算例, 解文件输出至 sln.LMS.n30e44.txt: 1mcdsp.exe 600 123456 &lt;../data/LMS.n30e44.txt &gt;sln.LMS.n30e44.txt 运行时间上限. 超出运行时间上限后测试程序会强行终止算法, 请确保在此之前已输出解 (最好还能自行正常退出). 随机种子设置. 使用 C 语言随机数生成器请用 srand. 使用 C++ 随机数生成器 (如 mt19937) 请在构造时传参或调用 seed() 方法设置. 输入的算例文件格式 所有算例的节点从 0 开始连续编号. 第一行给出 2 个由空白字符分隔的整数, 分别表示节点数 N 与无向边数 E (有向边数为 2E). 接下来连续 E 行, 每行包含 2 个由空白字符分隔的整数, 表示一条无向边的两个端点. 例如, 以下算例文件表示节点数为 4, 无向边数为 3; 其中: 节点 0 分别与 1, 2, 3 相邻. 12344 3 20 10 23 0 输出的解文件格式 输出 P 个用空白字符 (建议使用换行符) 分隔的整数, 分别表示挑选出的 P 个节点. 例如, 以下解文件表示选择节点 0 和 2 作为连通支配集: 1202 提交要求 发送至邮箱 szx@duhe.tech. 邮件标题格式为 \"Challenge2022MCDSP-姓名-学校-专业\". 邮件附件为单个压缩包 (文件大小 2M 以内), 文件名为 \"姓名-学校-专业\", 其内包含下列文件. 必要 算法的可执行文件 (Windows 平台). 建议基于官方 SDK 开发 (https://gitee.com/suzhouxing/npbenchmark/tree/main/SDK.MCDSP). 用 g++ 的同学编译时建议静态链接, 即添加 -static-libgcc -static-libstdc++ 编译选项. 必要 算法源码. 可重入 (可在同一线程内反复调用而不会出现数据初始化错误或内存泄漏). 可并发 (可在同一进程内的多个线程同时运行多个算法求解实例而互不干扰, 满足此要求一般不能有全局的非只读变量). 可伸缩 (数据结构可以根据算例规模动态申请内存, 而非根据预先指定的编译期常量进行内存分配). 可选 算法在各算例上的运行情况概要, 至少包括以下几项信息 (仅在无法成功调用算法输出可通过检查程序的解时作为参考). 算例名. 连通支配集节点数. 计算耗时. 可选 算法在各算例上求得的连通支配集节点数最少的解文件 (仅在无法成功调用算法输出可通过检查程序的解时作为参考). 若成功提交, 在收到邮件时以及测试完成后系统均会自动发送邮件反馈提交情况. 若测试结果较优, 可在排行榜页面看到自己的运行情况 (https://gitee.com/suzhouxing/npbenchmark.data/tree/data/MCDSP). 其他说明参考 (SmartLab Challenge - ReadMe). 例如: 12345678910111213苏宙行-华科-计科.zip| mcdsp.exe| results.csv|+---src| main.cpp| algorithm.cpp| algorithm.h|+---results LPNMR.n40e200.txt LPNMR.n45e250.txt ... 算例清单 下载地址: https://gitee.com/suzhouxing/npbenchmark.data/tree/data/MCDSP/Instance 算例规模从小到大依次为 (求解难度不一定随规模增加): LPNMR.n40e200 LPNMR.n45e250 LPNMR.n50e250 LPNMR.n55e250 LPNMR.n60e400 LPNMR.n70e250 LPNMR.n80e500 LPNMR.n90e600 LMS.n30e44 LMS.n30e87 LMS.n30e131 LMS.n30e218 LMS.n30e305 LMS.n50e61 LMS.n50e123 LMS.n50e245 LMS.n50e368 LMS.n50e613 LMS.n50e858 LMS.n70e121 LMS.n70e242 LMS.n70e483 LMS.n70e725 LMS.n70e1208 LMS.n70e1691 LMS.n100e248 LMS.n100e495 LMS.n100e990 LMS.n100e1485 LMS.n100e2475 LMS.n100e3465 LMS.n120e357 LMS.n120e714 LMS.n120e1428 LMS.n120e2142 LMS.n120e3570 LMS.n120e4998 LMS.n150e559 LMS.n150e1118 LMS.n150e2235 LMS.n150e3353 LMS.n150e5588 LMS.n150e7823 LMS.n200e995 LMS.n200e1990 LMS.n200e3980 LMS.n200e5970 LMS.n200e9950 LMS.n200e13930 BPFTC.n14e20 BPFTC.n30e41 BPFTC.n57e78 BPFTC.n73e108 BPFTC.n118e179 BPFTC.n300e409 RGG.n80e262 RGG.n80e329 RGG.n80e400 RGG.n80e474 RGG.n80e563 RGG.n80e647 RGG.n80e735 RGG.n100e335 RGG.n100e368 RGG.n100e435 RGG.n100e500 RGG.n100e575 RGG.n200e756 RGG.n200e871 RGG.n200e921 RGG.n200e997 RGG.n200e1113 RGG.n200e1127 RGG.n200e1269 RGG.n200e1305 RGG.n200e1400 RGG.n200e1501 RGG.n200e1541 RGG.n200e1730 RGG.n250e903 RGG.n250e1011 RGG.n250e1119 RGG.n250e1246 RGG.n300e1577 RGG.n300e1710 RGG.n300e1849 RGG.n300e1990 RGG.n350e1461 RGG.n350e1555 RGG.n350e1668 RGG.n350e1787 RGG.n400e1522 RGG.n400e1621 RGG.n400e1750 RGG.n400e1880 Sparse.n1000e1298 Sparse.n1000e1497 Sparse.n1000e1694 Sparse.n1500e1995 Sparse.n1500e2198 Sparse.n1500e2397 Sparse.n2000e2598 Sparse.n2000e2798 Sparse.n2000e2996 Sparse.n2500e3297 Sparse.n2500e3496 Sparse.n2500e3697 Sparse.n3000e3998 Sparse.n3000e4298 Sparse.n3000e4597 BOBL.n1000e3449 BOBL.n1000e3481 BOBL.n1000e7150 BOBL.n1000e7164 BOBL.n1000e13923 BOBL.n1000e14380 BOBL.n1000e27002 BOBL.n1000e27966 BOBL.n1000e55730 BOBL.n1000e56085 BOBL.n1000e111644 BOBL.n1000e111893 BOBL.n5000e86922 BOBL.n5000e87265 BOBL.n5000e174799 BOBL.n5000e183025 BOBL.n5000e349693 BOBL.n5000e361947 BOBL.n5000e675960 BOBL.n5000e701099 BOBL.n5000e1400601 BOBL.n5000e1408976 BOBL.n5000e2792708 BOBL.n5000e2797377","categories":[{"name":"算法挑战","slug":"算法挑战","permalink":"http://suzhouxing.github.io/techive/categories/算法挑战/"}],"tags":[{"name":"Challenge","slug":"Challenge","permalink":"http://suzhouxing.github.io/techive/tags/Challenge/"},{"name":"算法挑战","slug":"算法挑战","permalink":"http://suzhouxing.github.io/techive/tags/算法挑战/"},{"name":"组合优化","slug":"组合优化","permalink":"http://suzhouxing.github.io/techive/tags/组合优化/"}]},{"title":"SmartLab Challenge 2022 - Directed Feedback Vertex Set Problem","slug":"Contest-2022DFVS","date":"2022-04-15T13:49:35.000Z","updated":"2022-05-27T10:12:45.240Z","comments":true,"path":"2022/04/15/Contest-2022DFVS/","link":"","permalink":"http://suzhouxing.github.io/techive/2022/04/15/Contest-2022DFVS/","excerpt":"","text":"反馈点集问题在众多领域中有广泛的应用, 可以用来对多种组合优化问题进行建模. 有向反馈点集问题主要研究如何消除有向拓扑图中的环路问题. 比如在操作系统解决死锁时, 需要尽可能少地强行终止用户进程. 比如以层次图模式绘制思维导图或电路原理图时, 需要尽量避免出现逆向边. 高效的反馈点集问题求解算法具有极其重要的理论与应用价值. 有向反馈点集算法训练 问题概述 给定一个有向图, 请删除最少数量的节点 (所有与被删除节点直接相连的有向边均被一并删除), 使该有向图无环. 参考文献. [1] P. Galinier, E. Lemamou, and M. W. Bouzidi, “Applying local search to the feedback vertex set problem,” Journal of Heuristics, vol. 19, no. 5, pp. 797–818, Oct. 2013, doi: 10.1007/s10732-013-9224-z. [2] P. Festa, P. M. Pardalos, and M. G. C. Resende, “Feedback Set Problems,” in Handbook of Combinatorial Optimization: Supplement Volume A, D.-Z. Du and P. M. Pardalos, Eds. Boston, MA: Springer US, 1999, pp. 209–258. doi: 10.1007/978-1-4757-3023-4_4. [3] D. Zhao, L. Xu, S. -M. Qin, G. Liu, and Z. Wang, “The Feedback Vertex Set Problem of Multiplex Networks,” IEEE Transactions on Circuits and Systems II: Express Briefs, vol. 67, no. 12, pp. 3492–3496, Dec. 2020, doi: 10.1109/TCSII.2020.2997974. 命令行参数 请大家编写程序时支持两个命令行参数, 依次为运行时间上限 (单位为秒) 和随机种子 (0-65535). 算例文件已重定向至标准输入 stdin/cin, 标准输出 stdout/cout 已重定向至解文件 (如需打印调试信息, 请使用标准错误输出 stderr/cerr). 例如, 在控制台运行以下命令表示调用可执行文件 dfvsp.exe 在限时 600 秒, 随机种子为 12345 的情况下求解路径为 ../data/pardalos.n50e100.txt 的算例, 解文件输出至 sln.pardalos.n50e100.txt: 1dfvsp.exe 600 123456 &lt;../data/pardalos.n50e100.txt &gt;sln.pardalos.n50e100.txt 运行时间上限. 超出运行时间上限后测试程序会强行终止算法, 请确保在此之前已输出解 (最好还能自行正常退出). 随机种子设置. 使用 C 语言随机数生成器请用 srand. 使用 C++ 随机数生成器 (如 mt19937) 请在构造时传参或调用 seed() 方法设置. 输入的算例文件格式 所有算例的节点从 0 开始连续编号. 第一行给出 2 个由空白字符分隔的整数, 分别表示节点数 N, 有向边数 E. 接下来连续 N 行给出有向图的邻接表, 第 i 行表示第 i 个节点可以直接到达的节点集合, 节点集合由若干由空白字符分隔的整数表示. 例如, 以下算例文件表示节点数为 3, 有向边数为 4; 其中: 从节点 0 出发可以到达节点 1 和 2; 从节点 1 出发可以到达节点 0; 从节点 2 出发可以到达节点 1. 12343 41 201 输出的解文件格式 输出 K 个用空白字符 (建议使用换行符) 分隔的整数表示 K 个被删除的节点. 例如, 以下解文件表示删除节点 0 和 2: 1202 提交要求 发送至邮箱 szx@duhe.tech. 邮件标题格式为 \"Challenge2022DFVSP-姓名-学校-专业\". 邮件附件为单个压缩包 (文件大小 2M 以内), 文件名为 \"姓名-学校-专业\", 其内包含下列文件. 必要 算法的可执行文件 (Windows 平台). 建议基于官方 SDK 开发 (https://gitee.com/suzhouxing/npbenchmark/tree/main/SDK.DFVSP). 用 g++ 的同学编译时建议静态链接, 即添加 -static-libgcc -static-libstdc++ 编译选项. 必要 算法源码. 可重入 (可在同一线程内反复调用而不会出现数据初始化错误或内存泄漏). 可并发 (可在同一进程内的多个线程同时运行多个算法求解实例而互不干扰, 满足此要求一般不能有全局的非只读变量). 可伸缩 (数据结构可以根据算例规模动态申请内存, 而非根据预先指定的编译期常量进行内存分配). 可选 算法在各算例上的运行情况概要, 至少包括以下几项信息 (仅在无法成功调用算法输出可通过检查程序的解时作为参考). 算例名. 删除节点数. 计算耗时. 可选 算法在各算例上求得的颜色数最少的解文件 (仅在无法成功调用算法输出可通过检查程序的解时作为参考). 若成功提交, 在收到邮件时以及测试完成后系统均会自动发送邮件反馈提交情况. 若测试结果较优, 可在排行榜页面看到自己的运行情况 (https://gitee.com/suzhouxing/npbenchmark.data/DFVSP). 其他说明参考 (SmartLab Challenge - ReadMe). 例如: 12345678910111213苏宙行-华科-计科.zip| dfvsp.exe| results.csv|+---src| main.cpp| algorithm.cpp| algorithm.h|+---results pardalos.n50e100.txt pardalos.n50e150.txt ... 算例清单 下载地址: https://gitee.com/suzhouxing/npbenchmark.data/tree/data/DFVSP/Instance 算例规模从小到大依次为 (求解难度不一定随规模增加): pardalos.n50e100 pardalos.n50e150 pardalos.n50e200 pardalos.n50e250 pardalos.n50e300 pardalos.n50e500 pardalos.n50e600 pardalos.n50e700 pardalos.n50e800 pardalos.n50e900 pardalos.n100e200 pardalos.n100e300 pardalos.n100e400 pardalos.n100e500 pardalos.n100e600 pardalos.n100e1000 pardalos.n100e1100 pardalos.n100e1200 pardalos.n100e1300 pardalos.n100e1400 pardalos.n500e1000 pardalos.n500e1500 pardalos.n500e2000 pardalos.n500e2500 pardalos.n500e3000 pardalos.n500e5000 pardalos.n500e5500 pardalos.n500e6000 pardalos.n500e6500 pardalos.n500e7000 pardalos.n1000e3000 pardalos.n1000e3500 pardalos.n1000e4000 pardalos.n1000e4500 pardalos.n1000e5000 pardalos.n1000e10000 pardalos.n1000e15000 pardalos.n1000e20000 pardalos.n1000e25000 pardalos.n1000e30000 pace.h001.n1024e2103 pace.h003.n1024e3480 pace.h005.n843e3995 pace.h007.n2048e4096 pace.h009.n1024e5231 pace.h011.n1024e5480 pace.h013.n2048e5216 pace.h015.n2048e7005 pace.h017.n1024e9737 pace.h019.n1024e10284 pace.h021.n2048e10573 pace.h023.n2048e11098 pace.h025.n1024e15102 pace.h027.n2048e14738 pace.h029.n1024e19861 pace.h031.n2048e18876 pace.h033.n6301e20777 pace.h035.n8192e30498 pace.h037.n8192e30814 pace.h039.n9473e43691 pace.h041.n8192e45139 pace.h043.n8192e50901 pace.h045.n8192e54189 pace.h047.n8192e54807 pace.h049.n8192e57468 pace.h051.n8192e71995 pace.h053.n8192e73399 pace.h055.n15268e74339 pace.h057.n8192e83083 pace.h059.n7115e103689 pace.h061.n8192e112798 pace.h063.n36682e88328 pace.h065.n26475e106762 pace.h067.n8192e138733 pace.h069.n8192e156904 pace.h071.n8192e168714 pace.h073.n16384e166938 pace.h075.n34978e169522 pace.h077.n62586e147892 pace.h079.n16384e216334 pace.h081.n32768e224254 pace.h083.n32768e256256 pace.h085.n16384e283794 pace.h087.n58960e269439 pace.h089.n8192e358201 pace.h091.n16384e354031 pace.h093.n32768e363878 pace.h095.n32768e409363 pace.h097.n16384e458925 pace.h099.n97898e447979 pace.h101.n65536e618237 pace.h103.n159316e544621 pace.h105.n65536e652583 pace.h107.n32768e699385 pace.h109.n8192e839576 pace.h111.n77360e828161 pace.h113.n194085e854377 pace.h115.n262111e1234877 pace.h117.n325729e1469679 pace.h119.n342573e1619304 pace.h121.n16384e2076651 pace.h123.n4096e2097152 pace.h125.n16384e2097152 pace.h127.n32768e2128971 pace.h129.n32768e2148521 pace.h131.n16384e2194576 pace.h133.n131072e2130456 pace.h135.n32768e2235835 pace.h137.n32768e2241646 pace.h139.n16384e2293868 pace.h141.n65536e2321780 pace.h143.n32768e2412833 pace.h145.n32768e2416820 pace.h147.n32768e2422154 pace.h149.n131072e2340382 pace.h151.n65536e2457973 pace.h153.n32768e2554765 pace.h155.n131072e2459701 pace.h157.n281903e2312497 pace.h159.n32768e2621362 pace.h161.n32768e2684883 pace.h163.n32768e2696696 pace.h165.n131072e2622100 pace.h167.n65536e2731506 pace.h169.n32768e2808603 pace.h171.n131072e2741624 pace.h173.n32768e2843144 pace.h175.n131072e2757784 pace.h177.n131072e2784435 pace.h179.n131072e2921009 pace.h181.n131072e2950732 pace.h183.n131072e3115621 pace.h185.n32768e3222505 pace.h187.n131072e3225441 pace.h189.n262144e3100310 pace.h191.n131072e3275806 pace.h193.n32768e3734348 pace.h195.n4096e4194304 pace.h197.n8192e4194304 pace.h199.n875713e5105039 ⯈ 隐藏算例 pace.e001.n512e651 pace.e003.n1024e6055 pace.e005.n1024e5736 pace.e007.n1024e4198 pace.e009.n1024e6804 pace.e011.n4096e15076 pace.e013.n2048e7038 pace.e015.n2048e9390 pace.e017.n1024e3800 pace.e019.n2048e11718 pace.e021.n2048e6147 pace.e023.n2048e5400 pace.e025.n1024e2802 pace.e027.n2048e9406 pace.e029.n2048e11302 pace.e031.n4096e26071 pace.e033.n1024e2010 pace.e035.n4096e17074 pace.e037.n4096e28675 pace.e039.n1024e2570 pace.e041.n4096e27082 pace.e043.n2048e5700 pace.e045.n4096e30202 pace.e047.n4096e28612 pace.e049.n4096e23857 pace.e051.n4096e12946 pace.e053.n4096e26872 pace.e055.n4096e12085 pace.e057.n4096e12298 pace.e059.n1024e1124 pace.e061.n2048e4320 pace.e063.n4096e23766 pace.e065.n8192e48759 pace.e067.n2048e4241 pace.e069.n4096e22368 pace.e071.n2048e4896 pace.e073.n8192e51796 pace.e075.n8192e31504 pace.e077.n8192e54744 pace.e079.n8192e52154 pace.e081.n8192e51030 pace.e083.n2048e3537 pace.e085.n8192e69446 pace.e087.n8192e69372 pace.e089.n8192e55556 pace.e091.n2048e3364 pace.e093.n16384e109487 pace.e095.n8192e59029 pace.e097.n16384e103725 pace.e099.n8192e38175 pace.e101.n32768e246723 pace.e103.n16384e77536 pace.e105.n2048e10584 pace.e107.n16384e104833 pace.e109.n16384e149298 pace.e111.n2048e31904 pace.e113.n1024e25750 pace.e115.n32768e304304 pace.e117.n32768e304790 pace.e119.n32768e272707 pace.e121.n1024e5480 pace.e123.n32768e256256 pace.e125.n32768e288748 pace.e127.n2048e25492 pace.e129.n32768e256665 pace.e131.n32768e240240 pace.e133.n2048e22332 pace.e135.n32768e240816 pace.e137.n2048e7003 pace.e139.n65536e288492 pace.e141.n65536e303686 pace.e143.n65536e303696 pace.e145.n2048e27086 pace.e147.n1024e25052 pace.e149.n1024e3624 pace.e151.n65536e653240 pace.e153.n2048e22306 pace.e155.n65536e619239 pace.e157.n65536e652583 pace.e159.n65536e550097 pace.e161.n2048e28713 pace.e163.n131072e574081 pace.e165.n131072e603932 pace.e167.n1024e5487 pace.e169.n131072e604300 pace.e171.n131072e604042 pace.e173.n1024e23175 pace.e175.n2048e22520 pace.e177.n32768e320320 pace.e179.n2048e27346 pace.e181.n32768e321088 pace.e183.n1024e5471 pace.e185.n4096e62879 pace.e187.n1024e3632 pace.e189.n1024e2048 pace.e191.n2048e4143 pace.e193.n1024e17144 pace.e195.n1024e32768 pace.e197.n4096e93346 pace.e199.n16384e559996","categories":[{"name":"算法挑战","slug":"算法挑战","permalink":"http://suzhouxing.github.io/techive/categories/算法挑战/"}],"tags":[{"name":"Challenge","slug":"Challenge","permalink":"http://suzhouxing.github.io/techive/tags/Challenge/"},{"name":"算法挑战","slug":"算法挑战","permalink":"http://suzhouxing.github.io/techive/tags/算法挑战/"},{"name":"组合优化","slug":"组合优化","permalink":"http://suzhouxing.github.io/techive/tags/组合优化/"}]},{"title":"SmartLab Challenge 2022 - Obstacle-Avoiding Rectilinear Steiner Minimum Tree","slug":"Contest-2022OARSMT","date":"2022-03-25T08:19:42.000Z","updated":"2022-05-27T10:12:51.158Z","comments":true,"path":"2022/03/25/Contest-2022OARSMT/","link":"","permalink":"http://suzhouxing.github.io/techive/2022/03/25/Contest-2022OARSMT/","excerpt":"","text":"斯坦纳树问题是芯片设计, 管道规划与网络设计等领域中的重要问题, 应用场景十分广泛. 而避障直线最小斯坦纳树问题作为一类特殊的斯坦纳树问题, 是数字电路物理设计中全局布线环节的核心问题之一. 避障直线最小斯坦纳树问题主要研究如何用不穿过障碍的正交线段将平面上的一系列节点连接起来, 使得线段总长度最短的问题. 比如在 ASIC 的经典设计流程中, 需要在所有元件布局已经固定的情况下为每个网规划无短路和断路的导线连接方案. 比如在 FPGA 的物理综合过程中, 需要确定逻辑门阵列间的数据通路以实现目标电路的功能. 因此, 高效的避障直线最小斯坦纳树问题的求解算法具有极其重要的理论与应用价值. 矩形装箱算法训练 问题概述 在平面直角坐标中, 给定一系列节点和矩形障碍, 请确定一系列正交线段 (与 x 轴或 y 轴平行) 的起点和终点, 使得在所有线段均不穿过障碍且任意两点均存在由连续线段构成的路径的情况下, 线段的总长度最短. 参考文献. [1] T. Huang, L. Li, and E. F. Y. Young, “On the Construction of Optimal Obstacle-Avoiding Rectilinear Steiner Minimum Trees,” IEEE Transactions on Computer-Aided Design of Integrated Circuits and Systems, vol. 30, no. 5, pp. 718–731, May 2011, doi: 10.1109/TCAD.2010.2098930. [2] C. Liu, S. Kuo, D. T. Lee, C. Lin, J. Weng, and S. Yuan, “Obstacle-Avoiding Rectilinear Steiner Tree Construction: A Steiner-Point-Based Algorithm,” IEEE Transactions on Computer-Aided Design of Integrated Circuits and Systems, vol. 31, no. 7, pp. 1050–1060, Jul. 2012, doi: 10.1109/TCAD.2012.2185050. [3] H. Zhang and D.-Y. Ye, “Key-node-based local search discrete artificial bee colony algorithm for obstacle-avoiding rectilinear Steiner tree construction,” Neural Computing and Applications, vol. 26, no. 4, pp. 875–898, May 2015, doi: 10.1007/s00521-014-1760-4. [4] H. Zhang, D. Ye, and W. Guo, “A heuristic for constructing a rectilinear Steiner tree by reusing routing resources over obstacles,” Integration, vol. 55, pp. 162–175, Sep. 2016, doi: 10.1016/j.vlsi.2016.06.001. 命令行参数 请大家编写程序时支持两个命令行参数, 依次为运行时间上限 (单位为秒) 和随机种子 (0-65535). 算例文件已重定向至标准输入 stdin/cin, 标准输出 stdout/cout 已重定向至解文件 (如需打印调试信息, 请使用标准错误输出 stderr/cerr). 例如, 在控制台运行以下命令表示调用可执行文件 oarsmt.exe 在限时 300 秒, 随机种子为 12345 的情况下求解路径为 ../data/rc01.n10o10.txt 的算例, 解文件输出至 sln.rc01.n10o10.txt: 1oarsmt.exe 300 123456 &lt;../data/rc01.n10o10.txt &gt;sln.rc01.n10o10.txt 运行时间上限. 超出运行时间上限后测试程序会强行终止算法, 请确保在此之前已输出解 (最好还能自行正常退出). 随机种子设置. 使用 C 语言随机数生成器请用 srand. 使用 C++ 随机数生成器 (如 mt19937) 请在构造时传参或调用 seed() 方法设置. 输入的算例文件格式 所有算例的节点和障碍分别从 0 开始连续编号. 所有坐标均为整数, 所有区间均为闭区间 (线段包含两个端点, 障碍包含边框). 第一行给出 2 个由空白字符分隔的整数, 分别表示节点数量 N 和障碍数量 O. 接下来连续 N 行, 每行包含 2 个由空白字符分隔的整数, 分别表示节点的横坐标和纵坐标. 接下来连续 O 行, 每行包含 4 个由空白字符分隔的整数, 分别表示障碍的最小横坐标, 最小纵坐标, 最大横坐标, 最大纵坐标. 例如, 以下算例文件表示有 4 个节点和 3 个障碍; 其中, 节点 0 的坐标为 (1, 3); 节点 1 的坐标为 (3, 1); 节点 2 的坐标为 (0, 2); 节点 3 的坐标为 (0, 3); 障碍 0 为 (0, 0) 与 (1, 1) 的包络矩形; 障碍 1 为端点为 (1, 1) 与 (2, 1) 的线段; 障碍 2 为 (1, 1) 所在位置: 123456784 31 33 10 20 30 0 1 11 1 2 11 1 1 1 输出的解文件格式 输出 K 行整数表示 K 条路径的形状, 第 i 行表示第 i 条路径的起点, 转折点, 终点坐标. 每行包含至少 4 个由空白字符分隔的整数或字母, 第一个整数表示第 i 条路径的起点横坐标, 第二个整数表示第 i 条路径的起点纵坐标. 随后连续若干由空白字符分隔的二元组, 二元组 (O, D) 表示路径沿方向 O 延长距离 D, 其中方向 O 的取值为字母 x 或 y. 例如, 以下解文件表示 3 条路径的形状; 其中, 路径 0 的起点坐标为 (0, 2), 先纵坐标 +1 到达途经点 (0, 3), 然后横坐标 +1 到达终点 (1, 3); 路径 1 的起点坐标为 (1, 3), 横坐标 +2 到达终点坐标为 (3, 3); 路径 2 的起点坐标为 (3, 3), 纵坐标 -2 到达终点坐标为 (3, 1): 1230 2 y 1 x 11 3 x 23 3 y -2 提交要求 发送至邮箱 szx@duhe.tech. 邮件标题格式为 \"Challenge2022OARSMT-姓名-学校-专业\". 邮件附件为单个压缩包 (文件大小 2M 以内), 文件名为 \"姓名-学校-专业\", 其内包含下列文件. 必要 算法的可执行文件 (Windows 平台). 建议基于官方 SDK 开发 (https://gitee.com/suzhouxing/npbenchmark/tree/main/SDK.OARSMT). 用 g++ 的同学编译时请静态链接, 即添加 -static-libgcc -static-libstdc++ 编译选项. 必要 算法源码. 可重入 (可在同一线程内反复调用而不会出现数据初始化错误或内存泄漏). 可并发 (可在同一进程内的多个线程同时运行多个算法求解实例而互不干扰, 满足此要求一般不能有全局的非只读变量). 可伸缩 (数据结构可以根据算例规模动态申请内存, 而非根据预先指定的编译期常量进行内存分配). 可选 算法在各算例上的运行情况概要, 至少包括以下几项信息 (仅在无法成功调用算法输出可通过检查程序的解时作为参考). 算例名. 剩余未覆盖元素数. 计算耗时. 可选 算法在各算例上求得包络矩形面积最小的解文件 (仅在无法成功调用算法输出可通过检查程序的解时作为参考). 若成功提交, 在收到邮件时以及测试完成后系统均会自动发送邮件反馈提交情况. 若测试结果较优, 可在排行榜页面看到自己的运行情况 (https://gitee.com/suzhouxing/npbenchmark.data/tree/data/OARSMT). 其他说明参考 (SmartLab Challenge - ReadMe). 例如: 12345678910111213苏宙行-华科-计科.zip| packing.exe| results.csv|+---src| main.cpp| algorithm.cpp| algorithm.h|+---results rc01.n10o10.txt rc02.n30o10.txt ... 算例清单 下载地址: https://gitee.com/suzhouxing/npbenchmark.data/tree/data/OARSMT/Instance ind1.n10o32 ind2.n10o43 ind3.n10o50 ind4.n25o79 ind5.n33o71 rt01.n10o500 rt02.n50o500 rt03.n100o500 rt04.n100o1000 rt05.n200o2000 rc01.n10o10 rc02.n30o10 rc03.n50o10 rc04.n70o10 rc05.n100o10 rc06.n100o500 rc07.n200o500 rc08.n200o800 rc09.n200o1000 rc10.n500o100 rc11.n1000o100 rc12.n1000o10000 rl01.n5000o5000 rl02.n10000o500 rl03.n10000o100 rl04.n10000o10 rl05.n10000o0 bonn.n109o101 bonn.n23292o54 bonn.n35574o158 bonn.n46269o127 bonn.n108500o141 bonn.n129399o210 bonn.n639639o382 bonn.n783352o175","categories":[{"name":"算法挑战","slug":"算法挑战","permalink":"http://suzhouxing.github.io/techive/categories/算法挑战/"}],"tags":[{"name":"Challenge","slug":"Challenge","permalink":"http://suzhouxing.github.io/techive/tags/Challenge/"},{"name":"算法挑战","slug":"算法挑战","permalink":"http://suzhouxing.github.io/techive/tags/算法挑战/"},{"name":"组合优化","slug":"组合优化","permalink":"http://suzhouxing.github.io/techive/tags/组合优化/"}]},{"title":"从羽毛球的角度谈科研","slug":"FromBadmintonToResearch","date":"2021-10-03T03:52:37.000Z","updated":"2022-03-01T07:46:29.604Z","comments":true,"path":"2021/10/03/FromBadmintonToResearch/","link":"","permalink":"http://suzhouxing.github.io/techive/2021/10/03/FromBadmintonToResearch/","excerpt":"","text":"羽毛球是一种技巧性很强的运动, 新手想要提高球技, 最大的困难往往在于纠正姿势. 不正确的姿势往往无法快速跑位导致接不到球, 或者接到回球质量很差打不到位, 长此以往还容易导致运动损伤. 相反地, 正确的姿势能够充分发挥全身的力量, 击球质量高打得有来有回不仅观赏性强, 锻炼效果也更好. 从握拍方式到挥拍动作再到移动步法, 既然采用正确的姿势有这么多好处, 为什么大多数人不愿意纠正姿势呢? 因为大家熟悉的打法上限虽低, 下限却比较高, 至少跟水平相当的人菜鸡互啄还是能碰到球的, 打多了水平也能有一定的提升. 而纠正姿势的过程是十分痛苦的, 往往要经历一段 \"邯郸学步\" 的状态, 变得连拍子都抓不稳球都不会打了. 概括地说, 绝大多数人太在乎一时的输赢与得失, 没有理解古人 \"以退为进\" 和 \"磨刀不误砍柴工\" 的智慧. 这是第一层原因 -- 放不下, 输不起. 另一方面, 很多人根本不知道有哪些 \"基本功\" 以及如何练习. 有些人可能根本没看过职业选手们的精彩对决; 有些人看过高手过招, 但是将其完全归功于天赋, 而对一招一式之间的共性无动于衷; 有些人知道基础训练的重要性, 但没有进一步思考运动员们到底训练了什么. 这是第二层原因 -- 不探索, 不总结. 此外, 还有些常见的劣根性, 在任何领域都是人类进步的阻碍. 有些人被传授以基本的招式, 却不勤加练习提升 \"内功\", 把需要主观意识控制的别扭的动作变成条件反射般自然而然的动作. 人们总是会找各种各样的借口自我欺骗, 而最普遍的自我欺骗, 便是 \"下次我会努力克服这些问题\". 这是第三层原因 -- 找借口, 爱拖延. 打羽毛球时, 有了扎实的基本功, 才有资格去谈千变万化的战术, 否则身体就会跟不上思维, 想法难以付诸现实. 做科学研究也是一样. 很多人科研的姿势不对, 总是想走捷径利用现成的工具. 现成的工具虽然能够让你快速得到可以看得到的成果 (下限很高), 却总是存在局限性, 如果不具备修改甚至创新的能力, 便无法取得更进一步的提升 (上限很低). 而基本功从哪里来? 科学研究的基本功又有哪几项呢? 答案其实很简单, 大家可以自己去探索和领悟.","categories":[{"name":"科学","slug":"科学","permalink":"http://suzhouxing.github.io/techive/categories/科学/"}],"tags":[{"name":"技术","slug":"技术","permalink":"http://suzhouxing.github.io/techive/tags/技术/"},{"name":"科学","slug":"科学","permalink":"http://suzhouxing.github.io/techive/tags/科学/"},{"name":"异想天开","slug":"异想天开","permalink":"http://suzhouxing.github.io/techive/tags/异想天开/"}]},{"title":"SmartLab Challenge 2021 - Vehicle Routing Problem with Time Windows","slug":"Contest-2021VRP","date":"2021-09-27T01:47:34.000Z","updated":"2022-05-27T10:12:41.633Z","comments":true,"path":"2021/09/27/Contest-2021VRP/","link":"","permalink":"http://suzhouxing.github.io/techive/2021/09/27/Contest-2021VRP/","excerpt":"","text":"带时间窗的车辆路由问题是交通运输与物流配送等领域中的重要问题, 其应用场景在生产生活中随处可见. 带时间窗的车辆路由问题主要研究如何确定一系列从同一个仓库出发的车辆的行驶路径, 在每辆车均不超载且每个客户都在给定时间窗内被访问的前提下, 最小化所有车辆的行驶时间之和. 比如快递配送过程中, 配送员能携带的物品重量有限, 同时每个客户只在特定的时段内有空收件, 快递公司需要调度配送员用最短的工时完成所有配送任务. 相反地, 在物流公司提供上门取件服务时, 揽件人员也会面临同样的优化问题. 因此, 高效的带时间窗的车辆路由问题的求解算法在理论上与实践上均意义重大. 带时间窗的车辆路由算法训练 问题概述 给定一个有向完全图, 图中包含一个仓库节点和若干客户节点. 每个客户节点都对应一个配送请求, 需要一个在指定的时间窗内将给定重量的物品一次性送达, 交接过程花费固定的时间. 此外, 每辆车的最大载重量相同且均需从仓库出发最后回到仓库, 同时任意两点间的最短行驶时间已知 (超时视为到达节点后原地等待). 请确定使用几辆车参与配送, 并给出每辆车依次访问的有序节点列表, 使得所有车辆的总行驶时间最短. 参考文献. [1] M. M. Solomon, “Algorithms for the Vehicle Routing and Scheduling Problems with Time Window Constraints,” Operations Research, vol. 35, no. 2, pp. 254–265, 1987, doi: 10.1287/opre.35.2.254. [2] Y. Nagata and O. Bräysy, “A powerful route minimization heuristic for the vehicle routing problem with time windows,” Operations Research Letters, vol. 37, no. 5, pp. 333–338, 2009, doi: 10.1016/j.orl.2009.04.006. [3] Y. Nagata, O. Bräysy, and W. Dullaert, “A penalty-based edge assembly memetic algorithm for the vehicle routing problem with time windows,” Computers &amp; Operations Research, vol. 37, no. 4, pp. 724–737, 2010, doi: 10.1016/j.cor.2009.06.022. [4] R. Baldacci, A. Mingozzi, and R. Roberti, “New Route Relaxation and Pricing Strategies for the Vehicle Routing Problem,” Operations Research, vol. 59, no. 5, pp. 1269–1283, 2011, doi: 10.1287/opre.1110.0975. [5] http://dimacs.rutgers.edu/programs/challenge/vrp/vrptw [6] http://dimacs.rutgers.edu/files/7616/3155/5530/VRPTW_Competition_Rules.pdf [7] https://www.sintef.no/projectweb/top/vrptw/homberger-benchmark/200-customers 命令行参数 请大家编写程序时支持两个命令行参数, 依次为运行时间上限 (单位为秒) 和随机种子 (0-65535). 算例文件已重定向至标准输入 stdin/cin, 标准输出 stdout/cout 已重定向至解文件 (如需打印调试信息, 请使用标准错误输出 stderr/cerr). 例如, 在控制台运行以下命令表示调用可执行文件 vrptw.exe 在限时 300 秒, 随机种子为 12345 的情况下求解路径为 ../data/solomon.c101.txt 的算例, 解文件输出至 sln.solomon.c101.txt: 1vrptw.exe 300 123456 &lt;../data/solomon.c101.txt &gt;sln.solomon.c101.txt 运行时间上限. 超出运行时间上限后测试程序会强行终止算法, 请确保在此之前已输出解 (最好还能自行正常退出). 随机种子设置. 使用 C 语言随机数生成器请用 srand. 使用 C++ 随机数生成器 (如 mt19937) 请在构造时传参或调用 seed() 方法设置. 输入的算例文件格式 所有算例的节点和车辆分别从 0 开始连续编号, 所有节点分布于平面直角坐标系中. 节点 0 为仓库, 即车辆的起点和终点, 其物品重量, 最短停留时间, 时间窗开始时间均为 0. 第一行给出 3 个由空白字符分隔的整数, 分别表示节点数 N, 最大可用车辆数 K, 以及各车辆的载重量上限 M. 接下来连续 N 行, 每行包含 6 个由空白字符分隔的整数, 第 i 行的 6 个整数依次表示第 i 个节点的 x 坐标, y 坐标, 物品重量, 最短停留时间 (服务时间), 最早到达时间, 最晚到达时间. 例如, 以下算例文件表示有 4 个节点和 3 辆车, 每辆车的容量为 10; 其中, 节点 0 的坐标为 (1, 5), 物品重量为 0, 最短停留时间为 0, 时间窗开始和结束时间分别为 0 和 8; 节点 1 的坐标为 (2, 1), 物品重量为 6, 最短停留时间为 3, 时间窗开始和结束时间分别为 4 和 5; 节点 2 的坐标为 (3, 7), 物品重量为 2, 最短停留时间为 4, 时间窗开始和结束时间分别为 5 和 6; 节点 3 的坐标为 (8, 8), 物品重量为 9, 最短停留时间为 5, 时间窗开始和结束时间分别为 6 和 7: 123454 3 101 5 0 0 0 82 1 6 3 4 53 7 2 4 5 68 8 9 5 6 7 注意, 本问题所用算例集中假设行驶时间等于两点间的距离, 目前的距离计算遵循文献与 DIMACS 竞赛中的约定, 使用截断保留一位小数的欧氏距离 (\\(t = \\lfloor 10 d \\rfloor / 10\\)), 具体计算方式以 SDK 中的代码为准. 输出的解文件格式 输出 V 行整数表示 V 辆车 (V &lt; K) 的行驶路径, 第 i 行第 j 个整数表示第 i 辆车经过的第 j 个客户节点. 例如, 以下解文件表示 2 辆车的行驶路径; 其中, 车辆 0 从仓库 0 出发后依次经过节点 3, 最后回到仓库 0; 车辆 1 从仓库 0 出发后依次经过节点 1 和 2, 最后回到仓库 0: 1231 2 提交要求 发送至邮箱 szx@duhe.tech. 邮件标题格式为 \"Challenge2021VRPTW2d-姓名-学校-专业\". 邮件附件为单个压缩包, 文件名为 \"姓名-学校-专业\", 其内包含下列文件. 必要 算法的可执行文件 (Windows 平台). 建议基于官方 SDK 开发 (https://gitee.com/suzhouxing/npbenchmark/tree/main/SDK.VRPTW2d). 用 g++ 的同学编译时请静态链接, 即添加 -static-libgcc -static-libstdc++ 编译选项. 必要 算法源码. 可重入 (可在同一线程内反复调用而不会出现数据初始化错误或内存泄漏). 可并发 (可在同一进程内的多个线程同时运行多个算法求解实例而互不干扰, 满足此要求一般不能有全局的非只读变量). 可伸缩 (数据结构可以根据算例规模动态申请内存, 而非根据预先指定的编译期常量进行内存分配). 可选 算法在各算例上的运行情况概要, 至少包括以下几项信息 (仅在无法成功调用算法输出可通过检查程序的解时作为参考). 算例名. 使用的车辆数. 所有车辆的行驶时长总和. 计算耗时. 可选 算法在各算例上求得的路径总长度最短的解文件 (仅在无法成功调用算法输出可通过检查程序的解时作为参考). 若成功提交, 在收到邮件时以及测试完成后系统均会自动发送邮件反馈提交情况. 若测试结果较优, 可在排行榜页面看到自己的运行情况 (https://gitee.com/suzhouxing/npbenchmark.data/tree/data/VRPTW2d). 其他说明参考 (SmartLab Challenge - ReadMe). 例如: 12345678910111213苏宙行-华科-计科.zip| vrptw2d.exe| results.csv|+---src| main.cpp| algorithm.cpp| algorithm.h|+---results solomon.c101.n101v25c200.txt solomon.c102.n101v25c200.txt ... 算例清单 下载地址: https://gitee.com/suzhouxing/npbenchmark.data/tree/data/VRPTW2d/Instance solomon.c101.n101v25c200 solomon.c102.n101v25c200 solomon.c103.n101v25c200 solomon.c104.n101v25c200 solomon.c105.n101v25c200 solomon.c106.n101v25c200 solomon.c107.n101v25c200 solomon.c108.n101v25c200 solomon.c109.n101v25c200 solomon.c201.n101v25c700 solomon.c202.n101v25c700 solomon.c203.n101v25c700 solomon.c204.n101v25c700 solomon.c205.n101v25c700 solomon.c206.n101v25c700 solomon.c207.n101v25c700 solomon.c208.n101v25c700 solomon.r101.n101v25c200 solomon.r102.n101v25c200 solomon.r103.n101v25c200 solomon.r104.n101v25c200 solomon.r105.n101v25c200 solomon.r106.n101v25c200 solomon.r107.n101v25c200 solomon.r108.n101v25c200 solomon.r109.n101v25c200 solomon.r110.n101v25c200 solomon.r111.n101v25c200 solomon.r112.n101v25c200 solomon.r201.n101v25c1000 solomon.r202.n101v25c1000 solomon.r203.n101v25c1000 solomon.r204.n101v25c1000 solomon.r205.n101v25c1000 solomon.r206.n101v25c1000 solomon.r207.n101v25c1000 solomon.r208.n101v25c1000 solomon.r209.n101v25c1000 solomon.r210.n101v25c1000 solomon.r211.n101v25c1000 solomon.rc101.n101v25c200 solomon.rc102.n101v25c200 solomon.rc103.n101v25c200 solomon.rc104.n101v25c200 solomon.rc105.n101v25c200 solomon.rc106.n101v25c200 solomon.rc107.n101v25c200 solomon.rc108.n101v25c200 solomon.rc201.n101v25c1000 solomon.rc202.n101v25c1000 solomon.rc203.n101v25c1000 solomon.rc204.n101v25c1000 solomon.rc205.n101v25c1000 solomon.rc206.n101v25c1000 solomon.rc207.n101v25c1000 solomon.rc208.n101v25c1000 homberger.c10201.n201v50c200 homberger.c10202.n201v50c200 homberger.c10203.n201v50c200 homberger.c10204.n201v50c200 homberger.c10205.n201v50c200 homberger.c10206.n201v50c200 homberger.c10207.n201v50c200 homberger.c10208.n201v50c200 homberger.c10209.n201v50c200 homberger.c10210.n201v50c200 homberger.c10401.n401v100c200 homberger.c10402.n401v100c200 homberger.c10403.n401v100c200 homberger.c10404.n401v100c200 homberger.c10405.n401v100c200 homberger.c10406.n401v100c200 homberger.c10407.n401v100c200 homberger.c10408.n401v100c200 homberger.c10409.n401v100c200 homberger.c10410.n401v100c200 homberger.c10601.n601v150c200 homberger.c10602.n601v150c200 homberger.c10603.n601v150c200 homberger.c10604.n601v150c200 homberger.c10605.n601v150c200 homberger.c10606.n601v150c200 homberger.c10607.n601v150c200 homberger.c10608.n601v150c200 homberger.c10609.n601v150c200 homberger.c10610.n601v150c200 homberger.c10801.n801v200c200 homberger.c10802.n801v200c200 homberger.c10803.n801v200c200 homberger.c10804.n801v200c200 homberger.c10805.n801v200c200 homberger.c10806.n801v200c200 homberger.c10807.n801v200c200 homberger.c10808.n801v200c200 homberger.c10809.n801v200c200 homberger.c10810.n801v200c200 homberger.c11001.n1001v250c200 homberger.c11002.n1001v250c200 homberger.c11003.n1001v250c200 homberger.c11004.n1001v250c200 homberger.c11005.n1001v250c200 homberger.c11006.n1001v250c200 homberger.c11007.n1001v250c200 homberger.c11008.n1001v250c200 homberger.c11009.n1001v250c200 homberger.c11010.n1001v250c200 homberger.c20201.n201v50c700 homberger.c20202.n201v50c700 homberger.c20203.n201v50c700 homberger.c20204.n201v50c700 homberger.c20205.n201v50c700 homberger.c20206.n201v50c700 homberger.c20207.n201v50c700 homberger.c20208.n201v50c700 homberger.c20209.n201v50c700 homberger.c20210.n201v50c700 homberger.c20401.n401v100c700 homberger.c20402.n401v100c700 homberger.c20403.n401v100c700 homberger.c20404.n401v100c700 homberger.c20405.n401v100c700 homberger.c20406.n401v100c700 homberger.c20407.n401v100c700 homberger.c20408.n401v100c700 homberger.c20409.n401v100c700 homberger.c20410.n401v100c700 homberger.c20601.n601v150c700 homberger.c20602.n601v150c700 homberger.c20603.n601v150c700 homberger.c20604.n601v150c700 homberger.c20605.n601v150c700 homberger.c20606.n601v150c700 homberger.c20607.n601v150c700 homberger.c20608.n601v150c700 homberger.c20609.n601v150c700 homberger.c20610.n601v150c700 homberger.c20801.n801v200c700 homberger.c20802.n801v200c700 homberger.c20803.n801v200c700 homberger.c20804.n801v200c700 homberger.c20805.n801v200c700 homberger.c20806.n801v200c700 homberger.c20807.n801v200c700 homberger.c20808.n801v200c700 homberger.c20809.n801v200c700 homberger.c20810.n801v200c700 homberger.c21001.n1001v250c700 homberger.c21002.n1001v250c700 homberger.c21003.n1001v250c700 homberger.c21004.n1001v250c700 homberger.c21005.n1001v250c700 homberger.c21006.n1001v250c700 homberger.c21007.n1001v250c700 homberger.c21008.n1001v250c700 homberger.c21009.n1001v250c700 homberger.c21010.n1001v250c700 homberger.r10201.n201v50c200 homberger.r10202.n201v50c200 homberger.r10203.n201v50c200 homberger.r10204.n201v50c200 homberger.r10205.n201v50c200 homberger.r10206.n201v50c200 homberger.r10207.n201v50c200 homberger.r10208.n201v50c200 homberger.r10209.n201v50c200 homberger.r10210.n201v50c200 homberger.r10401.n401v100c200 homberger.r10402.n401v100c200 homberger.r10403.n401v100c200 homberger.r10404.n401v100c200 homberger.r10405.n401v100c200 homberger.r10406.n401v100c200 homberger.r10407.n401v100c200 homberger.r10408.n401v100c200 homberger.r10409.n401v100c200 homberger.r10410.n401v100c200 homberger.r10601.n601v150c200 homberger.r10602.n601v150c200 homberger.r10603.n601v150c200 homberger.r10604.n601v150c200 homberger.r10605.n601v150c200 homberger.r10606.n601v150c200 homberger.r10607.n601v150c200 homberger.r10608.n601v150c200 homberger.r10609.n601v150c200 homberger.r10610.n601v150c200 homberger.r10801.n801v200c200 homberger.r10802.n801v200c200 homberger.r10803.n801v200c200 homberger.r10804.n801v200c200 homberger.r10805.n801v200c200 homberger.r10806.n801v200c200 homberger.r10807.n801v200c200 homberger.r10808.n801v200c200 homberger.r10809.n801v200c200 homberger.r10810.n801v200c200 homberger.r11001.n1001v250c200 homberger.r11002.n1001v250c200 homberger.r11003.n1001v250c200 homberger.r11004.n1001v250c200 homberger.r11005.n1001v250c200 homberger.r11006.n1001v250c200 homberger.r11007.n1001v250c200 homberger.r11008.n1001v250c200 homberger.r11009.n1001v250c200 homberger.r11010.n1001v250c200 homberger.r20201.n201v50c1000 homberger.r20202.n201v50c1000 homberger.r20203.n201v50c1000 homberger.r20204.n201v50c1000 homberger.r20205.n201v50c1000 homberger.r20206.n201v50c1000 homberger.r20207.n201v50c1000 homberger.r20208.n201v50c1000 homberger.r20209.n201v50c1000 homberger.r20210.n201v50c1000 homberger.r20401.n401v100c1000 homberger.r20402.n401v100c1000 homberger.r20403.n401v100c1000 homberger.r20404.n401v100c1000 homberger.r20405.n401v100c1000 homberger.r20406.n401v100c1000 homberger.r20407.n401v100c1000 homberger.r20408.n401v100c1000 homberger.r20409.n401v100c1000 homberger.r20410.n401v100c1000 homberger.r20601.n601v150c1000 homberger.r20602.n601v150c1000 homberger.r20603.n601v150c1000 homberger.r20604.n601v150c1000 homberger.r20605.n601v150c1000 homberger.r20606.n601v150c1000 homberger.r20607.n601v150c1000 homberger.r20608.n601v150c1000 homberger.r20609.n601v150c1000 homberger.r20610.n601v150c1000 homberger.r20801.n801v200c1000 homberger.r20802.n801v200c1000 homberger.r20803.n801v200c1000 homberger.r20804.n801v200c1000 homberger.r20805.n801v200c1000 homberger.r20806.n801v200c1000 homberger.r20807.n801v200c1000 homberger.r20808.n801v200c1000 homberger.r20809.n801v200c1000 homberger.r20810.n801v200c1000 homberger.r21001.n1001v250c1000 homberger.r21002.n1001v250c1000 homberger.r21003.n1001v250c1000 homberger.r21004.n1001v250c1000 homberger.r21005.n1001v250c1000 homberger.r21006.n1001v250c1000 homberger.r21007.n1001v250c1000 homberger.r21008.n1001v250c1000 homberger.r21009.n1001v250c1000 homberger.r21010.n1001v250c1000 homberger.rc10201.n201v50c200 homberger.rc10202.n201v50c200 homberger.rc10203.n201v50c200 homberger.rc10204.n201v50c200 homberger.rc10205.n201v50c200 homberger.rc10206.n201v50c200 homberger.rc10207.n201v50c200 homberger.rc10208.n201v50c200 homberger.rc10209.n201v50c200 homberger.rc10210.n201v50c200 homberger.rc10401.n401v100c200 homberger.rc10402.n401v100c200 homberger.rc10403.n401v100c200 homberger.rc10404.n401v100c200 homberger.rc10405.n401v100c200 homberger.rc10406.n401v100c200 homberger.rc10407.n401v100c200 homberger.rc10408.n401v100c200 homberger.rc10409.n401v100c200 homberger.rc10410.n401v100c200 homberger.rc10601.n601v150c200 homberger.rc10602.n601v150c200 homberger.rc10603.n601v150c200 homberger.rc10604.n601v150c200 homberger.rc10605.n601v150c200 homberger.rc10606.n601v150c200 homberger.rc10607.n601v150c200 homberger.rc10608.n601v150c200 homberger.rc10609.n601v150c200 homberger.rc10610.n601v150c200 homberger.rc10801.n801v200c200 homberger.rc10802.n801v200c200 homberger.rc10803.n801v200c200 homberger.rc10804.n801v200c200 homberger.rc10805.n801v200c200 homberger.rc10806.n801v200c200 homberger.rc10807.n801v200c200 homberger.rc10808.n801v200c200 homberger.rc10809.n801v200c200 homberger.rc10810.n801v200c200 homberger.rc11001.n1001v250c200 homberger.rc11002.n1001v250c200 homberger.rc11003.n1001v250c200 homberger.rc11004.n1001v250c200 homberger.rc11005.n1001v250c200 homberger.rc11006.n1001v250c200 homberger.rc11007.n1001v250c200 homberger.rc11008.n1001v250c200 homberger.rc11009.n1001v250c200 homberger.rc11010.n1001v250c200 homberger.rc20201.n201v50c1000 homberger.rc20202.n201v50c1000 homberger.rc20203.n201v50c1000 homberger.rc20204.n201v50c1000 homberger.rc20205.n201v50c1000 homberger.rc20206.n201v50c1000 homberger.rc20207.n201v50c1000 homberger.rc20208.n201v50c1000 homberger.rc20209.n201v50c1000 homberger.rc20210.n201v50c1000 homberger.rc20401.n401v100c1000 homberger.rc20402.n401v100c1000 homberger.rc20403.n401v100c1000 homberger.rc20404.n401v100c1000 homberger.rc20405.n401v100c1000 homberger.rc20406.n401v100c1000 homberger.rc20407.n401v100c1000 homberger.rc20408.n401v100c1000 homberger.rc20409.n401v100c1000 homberger.rc20410.n401v100c1000 homberger.rc20601.n601v150c1000 homberger.rc20602.n601v150c1000 homberger.rc20603.n601v150c1000 homberger.rc20604.n601v150c1000 homberger.rc20605.n601v150c1000 homberger.rc20606.n601v150c1000 homberger.rc20607.n601v150c1000 homberger.rc20608.n601v150c1000 homberger.rc20609.n601v150c1000 homberger.rc20610.n601v150c1000 homberger.rc20801.n801v200c1000 homberger.rc20802.n801v200c1000 homberger.rc20803.n801v200c1000 homberger.rc20804.n801v200c1000 homberger.rc20805.n801v200c1000 homberger.rc20806.n801v200c1000 homberger.rc20807.n801v200c1000 homberger.rc20808.n801v200c1000 homberger.rc20809.n801v200c1000 homberger.rc20810.n801v200c1000 homberger.rc21001.n1001v250c1000 homberger.rc21002.n1001v250c1000 homberger.rc21003.n1001v250c1000 homberger.rc21004.n1001v250c1000 homberger.rc21005.n1001v250c1000 homberger.rc21006.n1001v250c1000 homberger.rc21007.n1001v250c1000 homberger.rc21008.n1001v250c1000 homberger.rc21009.n1001v250c1000 homberger.rc21010.n1001v250c1000","categories":[{"name":"算法挑战","slug":"算法挑战","permalink":"http://suzhouxing.github.io/techive/categories/算法挑战/"}],"tags":[{"name":"Challenge","slug":"Challenge","permalink":"http://suzhouxing.github.io/techive/tags/Challenge/"},{"name":"算法挑战","slug":"算法挑战","permalink":"http://suzhouxing.github.io/techive/tags/算法挑战/"},{"name":"组合优化","slug":"组合优化","permalink":"http://suzhouxing.github.io/techive/tags/组合优化/"}]},{"title":"运筹优化相关算法竞赛合集","slug":"CompetitionNavigation","date":"2021-09-16T02:00:27.000Z","updated":"2022-04-22T06:30:01.748Z","comments":true,"path":"2021/09/16/CompetitionNavigation/","link":"","permalink":"http://suzhouxing.github.io/techive/2021/09/16/CompetitionNavigation/","excerpt":"","text":"很欣慰地看到, 国家越来越重视竞赛了, 各个教育阶段的升学和考核等政策都在逐步向有竞赛成果的人倾斜. 相比于论文, 大部分竞赛有相对客观的评价标准, 第一只有一个, 很难出现大量无意义的低质量的重复研究. 因此, 后来者无需花费大量时间甄别前人到底尝试过哪些方法, 其中哪些是有效的, 哪些是无用的. 下面将简单列举一下与运筹优化相关的竞赛. 周期性竞赛 计算机科学 CS 电子设计自动化 EDA ICCAD (每年) http://iccad-contest.org ISPD (每年) http://www.ispd.cc/?page=contests EDAAI (每年/随时提交) http://www.eda-ai.org/ 集成电路EDA设计精英挑战赛 (每年) https://eda.icisc.cn/ 逻辑综合 IWLS (每年) https://www.iwls.org/ ReactiveSynthesis (每年) http://www.syntcomp.org/ SyGuS (每年) https://sygus.org/comp/ EDAthon (每年) https://sites.google.com/view/ceda-hk/edathon-2021 静态时序分析 TAU (每年) https://sites.google.com/view/tau-contest-2021/home/past-contests NP 问题通用求解引擎 命题逻辑 SAT (每年) http://www.satcompetition.org/ 历史链接 http://www.maxsat.udl.cat/ MaxSAT (每年) https://maxsat-evaluations.github.io/ 谓词逻辑 SMT (每年) https://smt-comp.github.io/previous.html QBF (每年) http://www.qbflib.org/index_eval.php 约束编程 MiniZinc (每年) https://www.minizinc.org/challenge.html XCSP (每年) http://xcsp.org/competition 可计算性与计算复杂性理论 HWMCC (每年) http://fmv.jku.at/hwmcc20/#history ModelChecking (每年) https://mcc.lip6.fr/ ModelCounting (每年) https://mccompetition.org/past_iterations 人工智能 AI 规划调度 ICAPS (每年) https://www.icaps-conference.org/competitions/ 自动定理证明 CASC (每年) http://www.tptp.org/CASC/ 改写引擎 REC (不规律) http://rec.gforge.inria.fr/ 并行计算 GraphChallenge (每年) https://graphchallenge.mit.edu/challenges 运筹学 OR DIMACS (不规律) http://dimacs.rutgers.edu/programs/challenge/ 历史链接 http://dimacs.rutgers.edu/archive/Challenges/ ROADEF (每一到两年) http://www.roadef.org/challenge PACE (每年) https://pacechallenge.org/ VeRoLog (不规律) https://www.euro-online.org/websites/verolog/verolog-solver-challenge/ 生物信息学 BI 蛋白质结构预测 CASP (每两年) https://predictioncenter.org/ 其他竞赛导航 学术会议或权威机构 FLoC (逻辑相关竞赛汇总) (每四年) https://floc2022.org/ https://www.floc2018.org/floc-olympic-games/ http://vsl2014.at/olympics/ GECCO (运筹优化竞赛汇总) (每年) https://gecco-2021.sigevo.org/Competitions https://gecco-2020.sigevo.org/index.html/Competitions PATAT (时刻表调度相关竞赛汇总) (不规律) https://www.patatconference.org/communityService.html TACAS (系统构建与分析的算法与工具相关竞赛汇总) (不规律) https://tacas.info/toolympics.php 竞赛平台 华为 https://competition.huaweicloud.com/competitions 阿里 https://tianchi.aliyun.com/competition/gameList/activeList AIcrowd https://www.aicrowd.com/challenges kaggle https://www.kaggle.com/competitions Biendata https://biendata.xyz/ 京东 https://jdata.jd.com/html/list.html OPTIL (排行榜) https://www.optil.io/optilion/problems 个人搜集 HSU (各类竞赛汇总) https://www.hsu-hh.de/logistik/research/challenges 已结束竞赛 ROADEF/EURO 电网检修计划 http://www.roadef.org/challenge/2020/en/index.php 玻璃切割 http://www.roadef.org/challenge/2018/en/index.php 库存路由 http://www.roadef.org/challenge/2016/en/index.php 负载均衡 http://www.roadef.org/challenge/2012/en/index.php GECCO 监控相机布局 http://www.mage.fst.uha.fr/brevilliers/ocp-uscp-benchmark/index.html 历史链接 http://www.mage.fst.uha.fr/brevilliers/gecco-2020-ocp-uscp-competition 历史链接 http://www.mage.fst.uha.fr/brevilliers/gecco-2021-ocp-uscp-competition AIcrowd 列车调度 https://www.aicrowd.com/challenges/flatland-3 京东 库存管理 https://jdata.jd.com/html/detail.html?id=4 车辆路由 https://jdata.jd.com/html/detail.html?id=5 阿里 布料切割 https://tianchi.aliyun.com/competition/entrance/231749/introduction 作业调度 https://tianchi.aliyun.com/competition/entrance/231663/introduction 物流运输 https://tianchi.aliyun.com/competition/entrance/231623/introduction 航班延误恢复 https://tianchi.aliyun.com/competition/entrance/231609/introduction 无人机路径规划 https://tianchi.aliyun.com/competition/entrance/231622/introduction 客流量预测 https://tianchi.aliyun.com/competition/entrance/231588/information 华为 卫星通信路径规划 https://competition.huaweicloud.com/information/1000041474/circumstance 机器分配 2018 年软件精英挑战赛 中心选址流量分发 2017 年软件精英挑战赛 光网络路由 2016 年软件精英挑战赛 滴滴 出租车订单分配 https://biendata.xyz/competition/kdd_didi/ 护士排班 护士排班 https://nrpcompetition.kuleuven-kulak.be/ 多阶段护士排班 http://mobiz.vives.be/inrc2/ CHeSC 跨领域启发式搜索 http://www.asap.cs.nott.ac.uk/external/chesc2011/index.html","categories":[{"name":"组合优化","slug":"组合优化","permalink":"http://suzhouxing.github.io/techive/categories/组合优化/"}],"tags":[{"name":"组合优化","slug":"组合优化","permalink":"http://suzhouxing.github.io/techive/tags/组合优化/"},{"name":"运筹优化","slug":"运筹优化","permalink":"http://suzhouxing.github.io/techive/tags/运筹优化/"},{"name":"算法竞赛","slug":"算法竞赛","permalink":"http://suzhouxing.github.io/techive/tags/算法竞赛/"},{"name":"网址导航","slug":"网址导航","permalink":"http://suzhouxing.github.io/techive/tags/网址导航/"}]},{"title":"再谈统一建模语言与通用求解器","slug":"GeneralSolver","date":"2021-09-01T12:03:58.000Z","updated":"2021-09-16T12:56:57.744Z","comments":true,"path":"2021/09/01/GeneralSolver/","link":"","permalink":"http://suzhouxing.github.io/techive/2021/09/01/GeneralSolver/","excerpt":"","text":"多年以前曾经有过一段与统一建模语言与通用求解器相关的意识流 (数据库中的搜索, 组合优化问题的搜索, 统一建模语言与通用求解器). 最近机缘巧合, 又遇到了这个话题, 于是又做了进一步的思考. 总的来说, 如果能设计一个能与针对特定问题的专用算法相媲美的通用求解器, 无论是精确还是近似, 其实际应用价值不亚于证明 P = NP. 可惜, 天上不会掉馅饼, 一个高价值的问题, 难度往往也不会低. 我们需要什么样的通用求解器? 如果说好奇心驱使人类进行科学探索, 那么, 懒, 则是人类发展技术的动力源泉. \"复用\" 是软件工程的核心思想之一, 说白了就是懒, 不想做别人甚至自己早就做过的工作. 在求解组合优化问题时, 我们当然也希望充分利用现有的研究成果. 算法设计中有很多平衡, 在这里, 我们关注的是算法的开发难度和结果优度之间的平衡, 以及开发效率和运行效率之间的平衡. 通用求解器的美好愿景是, 我们只用向计算机描述我们的问题, 它便能自动求出最优解. 然而, 其最大的问题就是如何向计算机描述我们的需求. 计算机往往只能接受形式化的语言, 即程序设计语言. 相比于命令式的编程语言, 声明式的编程语言更适合用于数学建模. 它们仅用于陈述事实, 所有声明是平行的, 需要被同时满足, 而不像命令式编程语言描述事件和操作的先后顺序. 不幸的是, 用数学语言形式化地描述问题对很多人来说都是一件十分困难的事情. 毕竟, 很多人用自然语言都无法清晰地描述需求, 定义问题. 简洁的建模语言入门容易, 但表达能力往往较弱, 十分考验使用者的经验与技巧. 复杂的建模语言表达能力强, 但学习成本也十分高昂. 如果既简洁又强大的建模语言真的存在, 大概率又会难以绕开自然语言的问题, 即二义性. 另一方面, 通用算法想要识别问题结构, 然后进行针对性处理是非常困难的. 然而, 且不说不同问题, 即使是同一个问题, 面对不同特性的测试用例, 不同算法的性能也有天壤之别. 比如, 拿最短简单路径这种教科书级别的 P 问题来举例: 若所有边权重相同, 则可以直接用广度优先搜索进行求解; 若在平面图上, 可以用欧氏距离作为启发函数使用 A* 算法高效求解; 若在网格上, 可以有更多基于地标和可达范围的加速策略... 如果能给计算机一些提示, 使其能够利用问题结构的信息, 将对求解效率产生十分积极的影响. 几个通用求解器的技术路线 数学规划 以 Gurobi 和 CPLEX 为代表的数学规划求解器, 主要基于线性规划求得线性松弛, 再基于线性松弛进行树搜索. 以个人经验来看, 虽然很多求解器还支持特殊形式的二次规划 (QP), 但其表达能力和求解效果往往不如混合整数规划 (MIP), 故此处仅讨论后者. 数学规划可以适应离散优化与连续优化相结合的场景, 表达能力足以支撑生产生活中绝大多数组合优化问题的建模. 但是, 正如 Harold Hotelling 的 \"名言\", \"But we all know the world is nonlinear\", 大量组合优化问题无法直接用 MIP 等建模语言进行描述. 最简单的情形便是 \"逻辑或\" 的关系, MIP 要求所有约束同时满足, 即 \"逻辑与\" 的关系, 所有约束对应的超平面将解空间切成一个单纯形 (凸多胞形) 构成可行解空间, \"逻辑或\" 会使可行解空间产生凹陷. 我们需要添加布尔类型的辅助变量进行升维, 使用 Big-M 的技巧, 将线性不可分的解空间转换为线性可分的, 将逻辑约束转述为代数约束. 进行上述处理后, 问题结构往往变得高度非线性, 不同的转换方式会不同程度地丢失问题的结构信息, 导致求解效果不够理想, 以至于最短路径或最小生成树之类的 P 问题求解速度往往也难以接受. SAT/MaxSAT/SMT 以 MiniSAT 及其衍生出的众多开源求解器为代表的通用求解器, 主要基于问题之间普遍存在可以相互归约/转换的关系, 通过一定的编码技巧将各类约束统一表达为布尔表达式. 与数学规划方法基于代数理论以连续优化为切入点不同, SAT/MaxSAT/SMT 方法的重心在逻辑推理, 直接面向离散优化. 由于 NP 完全问题之间普遍存在的可归约性, SAT 问题作为第一个 NP 完全问题, 其求解器理论上可以求解所有 NP 完全问题. 然而, NP 完全问题只是所有组合优化问题中一个很小的子集, 即使扩展到了 MaxSAT, 表达能力也十分有限而充满技巧性. 例如, 在数学规划中十分基础的 \\(a + b \\le c\\) 的约束, 要编码成 SAT 算例甚至类似于设计一个包含加法器和比较器的电路. 当然, 更进一步发展到 Satisfiability Modulo Theories (SMT) 之后, 表达能力产生了质的飞跃, 但从其目前的受欢迎程度来看 (我并没有使用过 SMT), 求解效率似乎也随之发生了质的跌落... 约束编程 以 MiniZinc 为代表的约束编程求解器, 其实现主要基于树搜索算法. 约束编程中各式各样的约束类型十分丰富, 表达能力很强, 乍一看好像和 SMT 很接近, 但是由于研究不多, 在此不做过多评价. 个人感觉约束编程中对很多常见的约束类型进行了封装或者模板化, 在简化调用代码的同时可以完整地呈现问题结构, 而不是以被使用者打散的状态出现. 做个不恰当的类比, 我们在描述一块砖的受到的重力时, 正常人都是用整块砖的质量乘以地表重力加速度, 而不是考虑砖里面每个原子的受到的万有引力以及原子间的相互作用. 比如在排序问题中, 我们需要给每个元素安排一个序号, 所有序号互不相同, 学过排序算法的都知道, 我们每次只交换两个元素就不会违反这个互不相同 (all-different) 约束. 但是如果使用者给出了 \\(n^{2}\\) 条约束, 告诉求解器任意两个元素的序号不相等, 那么求解器就需要经过一系列约束推理 (传播) 才能发现, 修改了 A 的序号之后, 必须把另一个元素的序号改成 A 原来的序号才行. 如果建模语言直接支持一类 all-different 约束, 则可以保留这种结构信息. 当然, 与其丰富的特性相对应地, 其学习成本也不见得比学习一门编程语言以及启发式算法的基本思想低多少. 有意思的是, 物理学家们努力在寻找大统一理论来解释所有相互作用, 虽然似乎目前进展不太顺利. 局部搜索 以 LocalSolver 为代表的基于局部搜索的通用求解器. 局部搜索算法与人的求解过程十分相似, 都是从初始解出发, 不断对当前解进行修改, 只对搜索路径或上下文信息进行有限的记录. 对于约束较少的优化问题, 局部搜索具有极高的适应性. 例如, 以最小化问题为例, 局部搜索关注上界, 是真实可行的解的目标函数值, 因此更符合实际需求. 而树搜索为了确保最优性, 关注的往往是下界, 是理论上最优解的目标函数值, 其实努力方向稍微有点走偏了. 然而, 局部搜索算法的设计是高度依赖问题结构的, 算法性能的关键一方面是邻域动作, 即每次如何修改当前解, 另一方面是邻域范围, 即每次评估哪些邻域动作. 如果只是对解向量进行任意的修改, 可能会浪费大量时间在无效的动作上. 以前面的 all-different 约束为例, 改变一个元素的序号后, 下一步可以把 n 个元素的序号更改为 1 到 n 中的任意一个, 共有 \\(n^{2}\\) 个动作, 但其实只有一个能得到可行解. 因此, 个人对于基于局部搜索的 \"傻瓜式\" \"即开即用\" 的通用求解器持相对悲观的态度, 不进行定制化将难以发挥局部搜索算法的强大威力. 算法库 以 COIN-OR 和 dlib 为代表的算法库. 主要基于问题之间普遍存在可以分解/组合的关系, 由算法设计者对各种子算法进行组合形成完整问题的求解算法. 使用算法库与基于 SAT/MaxSAT/SMT 构建通用求解器在思路上十分相似, 但从另一个角度看又是两个极端. 算法库几乎将算法设计的压力全部扔给了使用者, 甚至可以说这条技术路线完全没有超出软件工程的范畴. 而已知算法庞大的数量将极大地限制其可用性, 屠龙勇士最终往往会成为新的恶龙. 我已经有过类似的经历, 需要使用一个经典算法时, 发现很多第三方库中都有, 但是为了用一个简单的算法, 需要把整个庞大的工程集成到我的代码中, 感觉十分繁琐. 同时, 这些算法为了支持多种多样的应用场景往往会有很复杂的参数控制算法的行为, 即使我只需要最基础的功能, 我也得花大量时间仔细研究使用说明. 于是我决定自己重新实现一下, 并在以后的使用中日积月累, 功能越来越强大. 直到有一天, 我向学弟学妹们推销我那瑞士军刀般的算法库时, 大家都望而却步, 我才发现, 我的 \"杰作\" 已经成为了自己曾经不屑一顾的东西... 当然我们也不必过于悲观, 在特定领域中算法库应该还是有其用武之地的. 事实上, 基于数学规划的方法为我们提供了一些思路, 比如行生成 (惰性约束) 和列生成 (分支定价) 框架就是典型案例, 其子问题往往是个很简单的 P 问题, 可以由算法库提供支撑. 更通用地, 我们可以用函数式的编程范式对算法进行组合, 例如, 上层问题每找到一个可行解 (大格局), 就调用回调函数进行下层问题的求解 (完整解), 然后将完整解的可行性和优度反馈给上层, 上层根据反馈结果开展进一步搜索. 算法框架 以 SCIP 和 EasyLocal 为代表的算法框架. 说白了还是软件工程, 提取算法中公共的重复的部分, 将需要定制化的部分开放出来 (当然也可以提供默认的实现以提高易用性), 可以用于任何方法学. 对现有的框架了解不多, 自己设想的框架还在规划中, 在此不展开讨论. 能够指导求解的统一建模语言 前面反复提到 \"问题结构\" 这个词, 它到底是个什么东西? 到底能为求解带来多大的好处? 其实我自己也没想清楚, 只有两个模糊的思路. 一方面, 如果我们按某种策略对解空间进行探索, 那么有些约束将自然满足, 根本不用考虑, 不用专门添加约束加以限制. 比如对于 SAT 问题, 我们默认同一个变元在所有子句中的取值是完全一致的, 就是一种很自然的约束, 在满足这个约束的基础上去寻找满足所有子句的变元取值. 事实上, 我们还可以进行完全不同的建模, 比如要求所有子句必须都满足, 然后最大化同一变元在不同子句中的一致性, 其求解效果可能有天壤之别, 但求解器很难知道还有另一个等价的可以高效求解的模型. 另一方面, 如果我们按某种策略对解空间进行探索, 一旦探索过某些特定的子结构, 则可以排除一部分解空间包含更优解的可能性. 这个思路在 P 问题的求解中应用尤为广泛, 在 NP 问题中也较为常见, 比如动态规划的最优子结构, 树搜索的剪枝策略等等. 我是研究元启发式算法的, 下面我还是以我的老本行为切入点, 探讨一下在建模层面为求解算法提供指导的可能性. 前面提到, 影响局部搜索算法求解效果最关键的两个因素是邻域动作和邻域范围, 除此之外, 如何高效地增量评估邻居解的目标函数值, 以及如何近似评估目标函数值, 都是局部搜索中的重要问题. 指导求解的统一建模语言, 至少可以从这几个方面入手. 邻域动作 \"启发式\" 的含义即借鉴人与自然的经验. 局部搜索其实十分自然, 就像人在解决问题一样, 先做个差不多的方案, 然后左调调右调调, 看看能不能改出一个更好的方案. 因此, 定义邻域动作其实并不比数学规划或约束编程复杂. 而合理的邻域动作定义, 可以充分利用问题结构, 省略部分十分自然的约束. 比如集合覆盖, 如果邻域动作是交换两个集合的选中状态, 则无需添加选中集合数量约束. 用形式化的语言描述, 令所有子集的集合为 \\(S\\), 选中的子集集合为 \\(X\\), 交换邻域动作可以定义为 \\(M = \\{ X \\leftarrow X \\cup \\{ p \\} \\setminus \\{ q \\} | p \\in S \\setminus X, q \\in X \\}\\). 邻域范围 定义邻域范围其实也只涉及简单的集合定义, 甚至没有超出高中数学的范畴. 合理的邻域范围定义, 可以充分利用问题结构, 避免评估毫无希望的邻域动作, 或者适当缩小邻域对单位评估改进量 (评估的邻域解数量 / 最优邻域动作目标函数值改进量) 进行平衡. 比如作业车间调度, 相比于任意调整同机器上两个工序的先后顺序, 高效的邻域范围往往会针对关键路径上的工序, 因为其他工序的顺序调整无法直接缩短完工时间. 再次以集合覆盖为例, 每个交换动作中新增子集时, 相比于从所有未选中集合中挑选一个, 高效的邻域范围可以是随机选中一个未覆盖元素, 尝试添加一个能够覆盖该元素的集合. 用形式化的语言描述, 令所有子集的集合为 \\(S\\), 选中的子集集合为 \\(X\\), 子集 \\(s\\) 可覆盖的元素集合为 \\(C_{s}\\), 可覆盖元素 \\(e\\) 的子集集合为 \\(B_{e}\\), 未覆盖元素集合 \\(U(X) = \\bigcup_{s \\in S} C_{s} \\setminus \\bigcup_{s \\in X} C_{s}\\). 精简的交换邻域可以定义为 \\(N = \\{ X \\leftarrow X \\cup \\{ p \\} \\setminus \\{ q \\} | \\exists e \\in U(X), \\forall p \\in B_{e}, \\forall q \\in X \\}\\). 注意, 这里的符号使用可能不太严谨, 我们用存在量词 \\(\\exists\\) 表示从集合中随机选取一个元素, 还应进一步规范化. 增量评估 通用的增量评估虽然可行, 但其效率往往难以达到极致. 很多时候我们需要在更新代价和查询代价之间进行平衡, 往往需要一个中间数据结构实现辅助计算. 我们可以定义辅助查找表, 定义每轮迭代时目标函数如何通过这个查找表进行计算, 然后执行完邻域动作后查找表中的相关数据如何更新, 来提高评估效率. 近似评估 对于相对复杂的问题, 往往增量评估的代价都十分巨大, 此时我们需要使用近似评估策略, 筛选出若干较有潜力的解, 然后对其进行精确评估选出真正的最优动作. 近似评估其实于邻域范围有些许重叠, 邻域范围相当于可以在 O(1) 时间内完成的近似评估, 直接筛掉没有改进潜力的动作. 当然, 近似评估除了由人根据经验定义, 也完全有可能实现通用化和智能化, 即使用机器学习的技术, 进行函数逼近, 自动学习出一个开销很小的函数来模拟真实的目标函数. 总结 通用求解器是一个美好的愿景, 基于局部搜索的通用求解器更是十分有吸引力的方向. 而局部搜索的优势在于其对问题结构的把握, 丧失了问题结构的指引, 局部搜索的效果必然大打折扣. 因此, 个人认为, 我们在统一建模语言的基础上, 适当加入算法设计的提示信息, 对算法进行合理引导, 应该是比较有前景的技术路线.","categories":[{"name":"技术","slug":"技术","permalink":"http://suzhouxing.github.io/techive/categories/技术/"}],"tags":[{"name":"运筹优化","slug":"运筹优化","permalink":"http://suzhouxing.github.io/techive/tags/运筹优化/"},{"name":"技术","slug":"技术","permalink":"http://suzhouxing.github.io/techive/tags/技术/"},{"name":"建模","slug":"建模","permalink":"http://suzhouxing.github.io/techive/tags/建模/"},{"name":"通用求解器","slug":"通用求解器","permalink":"http://suzhouxing.github.io/techive/tags/通用求解器/"}]},{"title":"SmartLab Challenge 2021 - Rectangle Packing","slug":"Contest-2021RectPacking","date":"2021-07-10T09:21:42.000Z","updated":"2022-05-27T10:12:35.149Z","comments":true,"path":"2021/07/10/Contest-2021RectPacking/","link":"","permalink":"http://suzhouxing.github.io/techive/2021/07/10/Contest-2021RectPacking/","excerpt":"","text":"矩形装箱问题是物流运输, 芯片制造与游戏开发等领域中的重要问题, 应用场景十分广泛. 矩形装箱问题主要研究如何将一系列矩形块不重叠地摆放至矩形容器中, 使得容器面积最小的问题. 比如玻璃制造过程中, 要在原料 (大矩形) 上进行切割得到一系列成品 (小矩形). 比如在集成电路的物理设计中, 需要用最小的面积排布大量宏单元和标准单元以节约成本. 比如在游戏贴图加载时, 需要将若干矩形图片拼合成大块的矩形图像以充分发挥显存性能. 因此, 高效的矩形装箱问题的求解算法具有极其重要的理论与应用价值. 矩形装箱算法训练 问题概述 给定一系列长宽固定的矩形块, 可以旋转 0 或 90 度, 请确定每个矩形块的左下角坐标, 使得在所有矩形块不重叠的情况下, 包络所有矩形块的矩形区域面积最小. 参考文献. [1] L. Wei, W.-C. Oon, W. Zhu, and A. Lim, “A skyline heuristic for the 2D rectangular packing and strip packing problems,” European Journal of Operational Research, vol. 215, no. 2, pp. 337–346, 2011, doi: 10.1016/j.ejor.2011.06.022. [2] L. Wei, T. Tian, W. Zhu, and A. Lim, “A block-based layer building approach for the 2D guillotine strip packing problem,” European Journal of Operational Research, vol. 239, no. 1, pp. 58–69, 2014, doi: 10.1016/j.ejor.2014.04.020. [3] K. He, P. Ji, and C. Li, “Dynamic reduction heuristics for the rectangle packing area minimization problem,” European Journal of Operational Research, vol. 241, no. 3, pp. 674–685, 2015, doi: 10.1016/j.ejor.2014.09.042. [4] L. Wei, Q. Hu, S. C. H. Leung, and N. Zhang, “An improved skyline based heuristic for the 2D strip packing problem and its efficient implementation,” Computers &amp; Operations Research, vol. 80, pp. 113–127, 2017, doi: 10.1016/j.cor.2016.11.024. [5] K. He, H. Yang, Y. Jin, Q. Hu, and P. Ji, “The Orthogonal Packing and Scheduling Problem: Model, Heuristic, and Benchmark,” IEEE Transactions on Systems, Man, and Cybernetics: Systems, vol. 50, no. 4, pp. 1372–1383, Apr. 2020, doi: 10.1109/TSMC.2017.2768072. [6] P. Ji, K. He, Z. Wang, Y. Jin, and J. Wu, “A Quasi-Newton-based Floorplanner for fixed-outline floorplanning,” Computers &amp; Operations Research, vol. 129, p. 105225, 2021, doi: 10.1016/j.cor.2021.105225. 命令行参数 请大家编写程序时支持两个命令行参数, 依次为运行时间上限 (单位为秒) 和随机种子 (0-65535). 算例文件已重定向至标准输入 stdin/cin, 标准输出 stdout/cout 已重定向至解文件 (如需打印调试信息, 请使用标准错误输出 stderr/cerr). 例如, 在控制台运行以下命令表示调用可执行文件 packing.exe 在限时 300 秒, 随机种子为 12345 的情况下求解路径为 ../data/gsrc.b10a221679.txt 的算例, 解文件输出至 sln.gsrc.b10a221679.txt: 1packing.exe 300 123456 &lt;../data/gsrc.b10a221679.txt &gt;sln.gsrc.b10a221679.txt 运行时间上限. 超出运行时间上限后测试程序会强行终止算法, 请确保在此之前已输出解 (最好还能自行正常退出). 随机种子设置. 使用 C 语言随机数生成器请用 srand. 使用 C++ 随机数生成器 (如 mt19937) 请在构造时传参或调用 seed() 方法设置. 输入的算例文件格式 所有算例的矩形块均从 0 开始连续编号. 第一行给出一个整数 N, 表示矩形块的数量. 接下来连续 N 行, 每行包含 2 个由空白字符分隔的整数, 表示矩形块的长和宽 (不发生旋转的情况下，长度对应横坐标，宽度对应纵坐标). 例如, 以下算例文件表示需放置 4 个矩形块; 其中, 矩形块 0 的长为 1 宽为 3; 矩形块 1 的长为 3 宽为 1; 矩形块 2 的长为 2 宽为 2; 矩形块 3 的长为 2 宽为 2: 1234541 33 12 22 2 输出的解文件格式 输出 N 行整数表示 N 个矩形块的放置情况, 第 i 行表示第 i 个矩形块的左下角坐标和旋转情况. 每行 3 个由空白字符分隔的整数, 分别为第 i 个矩形块的最小横坐标, 最小纵坐标, 旋转度数 (必须为 0 或 90). 例如, 以下解文件表示 4 个矩形块的放置情况; 其中, 矩形块 0 的左下角坐标为 (0, 0), 不旋转; 矩形块 1 的左下角坐标为 (1, 0), 旋转 90 度; 矩形块 2 的左下角坐标为 (2, 0), 不旋转; 矩形块 3 的左下角坐标为 (2, 2), 不旋转: 12340 0 01 0 902 0 02 2 0 提交要求 发送至邮箱 szx@duhe.tech. 邮件标题格式为 \"Challenge2021RPP-姓名-学校-专业\". 邮件附件为单个压缩包 (文件大小 2M 以内), 文件名为 \"姓名-学校-专业\", 其内包含下列文件. 必要 算法的可执行文件 (Windows 平台). 建议基于官方 SDK 开发 (https://gitee.com/suzhouxing/npbenchmark/tree/main/SDK.RPP). 用 g++ 的同学编译时请静态链接, 即添加 -static-libgcc -static-libstdc++ 编译选项. 必要 算法源码. 可重入 (可在同一线程内反复调用而不会出现数据初始化错误或内存泄漏). 可并发 (可在同一进程内的多个线程同时运行多个算法求解实例而互不干扰, 满足此要求一般不能有全局的非只读变量). 可伸缩 (数据结构可以根据算例规模动态申请内存, 而非根据预先指定的编译期常量进行内存分配). 可选 算法在各算例上的运行情况概要, 至少包括以下几项信息 (仅在无法成功调用算法输出可通过检查程序的解时作为参考). 算例名. 剩余未覆盖元素数. 计算耗时. 可选 算法在各算例上求得包络矩形面积最小的解文件 (仅在无法成功调用算法输出可通过检查程序的解时作为参考). 若成功提交, 在收到邮件时以及测试完成后系统均会自动发送邮件反馈提交情况. 若测试结果较优, 可在排行榜页面看到自己的运行情况 (https://gitee.com/suzhouxing/npbenchmark.data/tree/data/RPP). 其他说明参考 (SmartLab Challenge - ReadMe). 例如: 12345678910111213苏宙行-华科-计科.zip| packing.exe| results.csv|+---src| main.cpp| algorithm.cpp| algorithm.h|+---results gsrc.b10a221679.txt gsrc.b30a208591.txt ... 算例清单 下载地址: https://gitee.com/suzhouxing/npbenchmark.data/tree/data/RPP/Instance gsrc.b10a221679 gsrc.b30a208591 gsrc.b50a198579 gsrc.b100a179501 gsrc.b200a175696 gsrc.b300a273170 mcnc.ami33.b33a1156449 mcnc.ami49.b49a35445424 mcnc.apte.b9a46561628 mcnc.hp.b11a8830584 mcnc.xerox.b10a19350296","categories":[{"name":"算法挑战","slug":"算法挑战","permalink":"http://suzhouxing.github.io/techive/categories/算法挑战/"}],"tags":[{"name":"Challenge","slug":"Challenge","permalink":"http://suzhouxing.github.io/techive/tags/Challenge/"},{"name":"算法挑战","slug":"算法挑战","permalink":"http://suzhouxing.github.io/techive/tags/算法挑战/"},{"name":"组合优化","slug":"组合优化","permalink":"http://suzhouxing.github.io/techive/tags/组合优化/"}]},{"title":"SmartLab Challenge 2021 - Routing and Wavelength Assignment","slug":"Contest-2021RWA","date":"2021-07-10T09:20:58.000Z","updated":"2022-05-27T10:12:38.712Z","comments":true,"path":"2021/07/10/Contest-2021RWA/","link":"","permalink":"http://suzhouxing.github.io/techive/2021/07/10/Contest-2021RWA/","excerpt":"","text":"路由与波长分配问题是通信领域中的重要问题, 具有较高的实际应用价值. 路由与波长分配问题主要研究如何为通信业务规划传输路径并分配波长, 使得所有业务可以在互不干扰的情况下传输. 高效的路由与波长分配问题的求解算法对提高网络的传输效率具有意义重大. 同时, 路由与波长分配问题还与多智能体路径规划以及芯片布线十分相似, 具有重要的理论意义. 路由与波长分配算法训练 问题概述 给定一个有向图, 以及一系列通信业务, 每个通信业务有固定的起点和终点. 请为每个通信业务规划一条传输路径, 并为其分配一个波长, 在确保每条有向边上经过的所有业务波长互不相同的前提下, 最小化使用的波长数. 参考文献. [1] Y. Fang, Z. Lü, Z. Su, Y. Wang, T. Zhang, and Q. Zhang, “Local Search based on a New Neighborhood for Routing and Wavelength Assignment,” in 2020 IEEE International Conference on Systems, Man, and Cybernetics (SMC), 2020, pp. 1123–1128. doi: 10.1109/SMC42975.2020.9283031. 命令行参数 请大家编写程序时支持两个命令行参数, 依次为运行时间上限 (单位为秒) 和随机种子 (0-65535). 算例文件已重定向至标准输入 stdin/cin, 标准输出 stdout/cout 已重定向至解文件 (如需打印调试信息, 请使用标准错误输出 stderr/cerr). 例如, 在控制台运行以下命令表示调用可执行文件 rwa.exe 在限时 300 秒, 随机种子为 12345 的情况下求解路径为 ../data/ATT.n90e274t359.txt 的算例, 解文件输出至 sln.ATT.n90e274t359.txt: 1rwa.exe 300 123456 &lt;../data/ATT.n90e274t359.txt &gt;sln.ATT.n90e274t359.txt 运行时间上限. 超出运行时间上限后测试程序会强行终止算法, 请确保在此之前已输出解 (最好还能自行正常退出). 随机种子设置. 使用 C 语言随机数生成器请用 srand. 使用 C++ 随机数生成器 (如 mt19937) 请在构造时传参或调用 seed() 方法设置. 输入的算例文件格式 所有算例的节点从 0 开始连续编号. 第一行给出 3 个由空白字符分隔的整数, 分别表示节点数 N, 有向边数 E, 以及通信业务数 T. 接下来连续 E 行, 每行包含 2 个由空白字符分隔的整数, 第 i 行表示第 i 条有向边的源点和宿点. 接下来连续 T 行, 每行包含 2 个由空白字符分隔的整数, 第 i 行表示第 i 个通信业务的起点和终点. 例如, 以下算例文件表示在 4 个节点和 5 条有向边的有向图上传输 3 个通信业务; 其中, 有向图包含 0, 1, 2, 3 共 4 个节点以及 0-1, 1-2, 2-3, 3-0, 1-0 共 4 条有向边, 通信业务 0 的起点为 0 终点为 1, 通信业务 1 的起点为 1 终点为 0, 通信业务 2 的起点为 1 终点为 3: 1234567894 5 30 11 22 33 01 00 11 01 3 输出的解文件格式 输出 T 行整数表示 T 个通信业务的传输方案, 第 i 行表示第 i 个通信业务的波长分配和传输路径. 每行第一个整数表示第 i 个通信业务使用的波长, 第二个整数表示传输路径上的节点数, 随后连续 P 个由空白字符分隔的整数表示传输路径上依次经过的节点. 波长可以取 int 范围内任意整数, 检查程序自动统计不同的整数的数量. 传输路径上的节点若不包含通信业务的起点和终点, 检查程序将自动将其添加至路径中. 例如, 以下解文件表示 3 个通信业务的波长分配和传输路径; 其中, 通信业务 0 使用的波长为 1, 依次经过节点 0 和 1; 通信业务 1 使用的波长为 1, 直接从起点 1 到达终点 0; 通信业务 2 使用的波长为 0, 依次经过节点 1 和 2, 最后到达终点 3: 1231 2 0 11 00 2 1 2 提交要求 发送至邮箱 szx@duhe.tech. 邮件标题格式为 \"Challenge2021RWA-姓名-学校-专业\". 邮件附件为单个压缩包 (文件大小 2M 以内), 文件名为 \"姓名-学校-专业\", 其内包含下列文件. 必要 算法的可执行文件 (Windows 平台). 建议基于官方 SDK 开发 (https://gitee.com/suzhouxing/npbenchmark/tree/main/SDK.RWA). 用 g++ 的同学编译时请静态链接, 即添加 -static-libgcc -static-libstdc++ 编译选项. 必要 算法源码. 可重入 (可在同一线程内反复调用而不会出现数据初始化错误或内存泄漏). 可并发 (可在同一进程内的多个线程同时运行多个算法求解实例而互不干扰, 满足此要求一般不能有全局的非只读变量). 可伸缩 (数据结构可以根据算例规模动态申请内存, 而非根据预先指定的编译期常量进行内存分配). 可选 算法在各算例上的运行情况概要, 至少包括以下几项信息 (仅在无法成功调用算法输出可通过检查程序的解时作为参考). 算例名. 使用的波长数. 计算耗时. 可选 算法在各算例上求得的使用波长数最少的解文件 (仅在无法成功调用算法输出可通过检查程序的解时作为参考). 若成功提交, 在收到邮件时以及测试完成后系统均会自动发送邮件反馈提交情况. 若测试结果较优, 可在排行榜页面看到自己的运行情况 (https://gitee.com/suzhouxing/npbenchmark.data/tree/data/RWA). 其他说明参考 (SmartLab Challenge - ReadMe). 例如: 12345678910111213苏宙行-华科-计科.zip| rwa.exe| results.csv|+---src| main.cpp| algorithm.cpp| algorithm.h|+---results ATT.n90e274t359.txt ATT2.n71e350t2918.txt ... 算例清单 下载地址: https://gitee.com/suzhouxing/npbenchmark.data/tree/data/RWA/Instance 算例规模从小到大依次为 (求解难度不一定随规模增加, 但除 Z* 以外的算例应该都很容易求解): ATT.n90e274t359 ATT2.n71e350t2918 Brasil.n27e140t1370 EON.n20e78t373 Finland.n31e102t930 NSF-01.n14e42t284 NSF-03.n14e42t285 NSF-12.n14e42t551 NSF-48.n14e42t547 NSF2-01.n14e44t284 NSF2-03.n14e44t285 NSF2-12.n14e44t551 NSF2-48.n14e44t547 Y3-020-1.n100e344t1975 Y3-020-2.n100e368t1961 Y3-020-3.n100e356t2055 Y3-020-4.n100e354t1989 Y3-020-5.n100e350t1975 Y3-040-1.n100e344t3894 Y3-040-2.n100e368t3956 Y3-040-3.n100e356t4012 Y3-040-4.n100e354t3959 Y3-040-5.n100e350t3996 Y3-060-1.n100e344t5967 Y3-060-2.n100e368t5907 Y3-060-3.n100e356t5989 Y3-060-4.n100e354t5932 Y3-060-5.n100e350t5990 Y3-080-1.n100e344t7959 Y3-080-2.n100e368t7911 Y3-080-3.n100e356t7987 Y3-080-4.n100e354t7908 Y3-080-5.n100e350t7924 Y3-100-1.n100e344t9900 Y3-100-2.n100e368t9900 Y3-100-3.n100e356t9900 Y3-100-4.n100e354t9900 Y3-100-5.n100e350t9900 Y4-020-1.n100e440t1975 Y4-020-2.n100e460t1961 Y4-020-3.n100e436t2055 Y4-020-4.n100e442t1989 Y4-020-5.n100e430t1975 Y4-040-1.n100e440t3894 Y4-040-2.n100e460t3956 Y4-040-3.n100e436t4012 Y4-040-4.n100e442t3959 Y4-040-5.n100e430t3996 Y4-060-1.n100e440t5967 Y4-060-2.n100e460t5907 Y4-060-3.n100e436t5989 Y4-060-4.n100e442t5932 Y4-060-5.n100e430t5990 Y4-080-1.n100e440t7959 Y4-080-2.n100e460t7911 Y4-080-3.n100e436t7987 Y4-080-4.n100e442t7908 Y4-080-5.n100e430t7924 Y4-100-1.n100e440t9900 Y4-100-2.n100e460t9900 Y4-100-3.n100e436t9900 Y4-100-4.n100e442t9900 Y4-100-5.n100e430t9900 Y5-020-1.n100e570t1975 Y5-020-2.n100e504t1961 Y5-020-3.n100e582t2055 Y5-020-4.n100e548t1989 Y5-020-5.n100e568t1975 Y5-040-1.n100e570t3894 Y5-040-2.n100e504t3956 Y5-040-3.n100e582t4012 Y5-040-4.n100e548t3959 Y5-040-5.n100e568t3996 Y5-060-1.n100e570t5967 Y5-060-2.n100e504t5907 Y5-060-3.n100e582t5989 Y5-060-4.n100e548t5932 Y5-060-5.n100e568t5990 Y5-080-1.n100e570t7959 Y5-080-2.n100e504t7911 Y5-080-3.n100e582t7987 Y5-080-4.n100e548t7908 Y5-080-5.n100e568t7924 Y5-100-1.n100e570t9900 Y5-100-2.n100e504t9900 Y5-100-3.n100e582t9900 Y5-100-4.n100e548t9900 Y5-100-5.n100e568t9900 Z04x25-020.n100e400t1975 Z04x25-040.n100e400t3894 Z04x25-060.n100e400t5967 Z04x25-080.n100e400t7959 Z04x25-100.n100e400t9900 Z05x20-020.n100e400t1975 Z05x20-040.n100e400t3894 Z05x20-060.n100e400t5967 Z05x20-080.n100e400t7959 Z05x20-100.n100e400t9900 Z06x17-020.n102e408t1975 Z06x17-040.n102e408t3894 Z06x17-060.n102e408t5967 Z06x17-080.n102e408t7959 Z06x17-100.n102e408t10302 Z08x13-020.n104e416t1975 Z08x13-040.n104e416t3894 Z08x13-060.n104e416t5967 Z08x13-080.n104e416t7959 Z08x13-100.n104e416t10712 Z10x10-020.n100e400t1975 Z10x10-040.n100e400t3894 Z10x10-060.n100e400t5967 Z10x10-080.n100e400t7959 Z10x10-100.n100e400t9900","categories":[{"name":"算法挑战","slug":"算法挑战","permalink":"http://suzhouxing.github.io/techive/categories/算法挑战/"}],"tags":[{"name":"Challenge","slug":"Challenge","permalink":"http://suzhouxing.github.io/techive/tags/Challenge/"},{"name":"算法挑战","slug":"算法挑战","permalink":"http://suzhouxing.github.io/techive/tags/算法挑战/"},{"name":"组合优化","slug":"组合优化","permalink":"http://suzhouxing.github.io/techive/tags/组合优化/"}]},{"title":"SmartLab Challenge 2020 - Flexible Job Shop Scheduling","slug":"Contest-2020FJSP","date":"2021-01-14T02:05:34.000Z","updated":"2022-05-27T10:12:21.471Z","comments":true,"path":"2021/01/14/Contest-2020FJSP/","link":"","permalink":"http://suzhouxing.github.io/techive/2021/01/14/Contest-2020FJSP/","excerpt":"","text":"柔性作业车间调度问题是智能制造与高性能计算等领域中的重要问题, 具有广泛应用场景. 柔性作业车间调度问题主要研究如何调度有限的资源依次执行多项任务, 使得完成所有任务的完工时间最短的问题. 比如芯片代工厂生产芯片时, 每块晶圆需要在不同机台依次完成光刻与蚀刻等多道工序. 比如在某些大规模并行计算场景中, 计算任务间存在依赖关系, 后继任务的输入为前驱任务的输出. 高效的柔性作业车间调度问题的求解算法具有极其重要的理论与应用价值. 柔性作业车间调度算法训练 问题概述 给定若干任务, 每个任务可由若干给定的机器中的任意一台花费给定的时间完成. 每个任务的全部前序任务完工后才能开工, 在不同机器间转移不消耗时间. 每台机器同一时间仅能执行一个任务且不可抢占, 即完成一个任务后才能开始下一个任务. 请确定每个任务何时在哪台机器上开工, 使得最后一个完工的任务最早完工. 柔性作业车间调度问题为上述任务调度问题的特例, 任务依赖拓扑为若干条单链. 即给定若干工件, 每个工件由一系列必须依次完成的工序组成. 参考文献. [1] J. Ding, Z. Lü, C. M. Li, L. Shen, L. Xu, and F. Glover, “A two-individual based evolutionary algorithm for the flexible job shop scheduling problem,” in Proceedings of the AAAI Conference on Artificial Intelligence, Jul. 2019, vol. 33, pp. 2262–2271. doi: 10.1609/aaai.v33i01.33012262. [2] C. Zhang, P. Li, Z. Guan, and Y. Rao, “A tabu search algorithm with a new neighborhood structure for the job shop scheduling problem,” Computers &amp; Operations Research, vol. 34, no. 11, pp. 3229–3242, 2007, doi: 10.1016/j.cor.2005.12.002. [3] M. A. González, C. R. Vela, and R. Varela, “Scatter search with path relinking for the flexible job shop scheduling problem,” European Journal of Operational Research, vol. 245, no. 1, Art. no. 1, Aug. 2015, doi: 10.1016/j.ejor.2015.02.052. 命令行参数 请大家编写程序时支持两个命令行参数, 依次为运行时间上限 (单位为秒) 和随机种子 (0-65535). 算例文件已重定向至标准输入 stdin/cin, 标准输出 stdout/cout 已重定向至解文件 (如需打印调试信息, 请使用标准错误输出 stderr/cerr). 例如, 在控制台运行以下命令表示调用可执行文件 fjsp.exe 在限时 300 秒, 随机种子为 12345 的情况下求解路径为 ../data/jsp.FT06.m6j6c1.txt 的算例, 解文件输出至 sln.jsp.FT06.m6j6c1.txt: 1fjsp.exe 300 123456 &lt;../data/jsp.FT06.m6j6c1.txt &gt;sln.jsp.FT06.m6j6c1.txt 运行时间上限. 超出运行时间上限后测试程序会强行终止算法, 请确保在此之前已输出解 (最好还能自行正常退出). 随机种子设置. 使用 C 语言随机数生成器请用 srand. 使用 C++ 随机数生成器 (如 mt19937) 请在构造时传参或调用 seed() 方法设置. 输入的算例文件格式 所有算例的任务和机器分别从 0 开始连续编号. 第一行给出 3 个由空白字符分隔的整数, 分别表示任务数 N, 机器数 M, 以及所有任务所有工序的最大的候选机器数 C (若 C = 1 说明该算例为 JSP 算例). 接下来连续 N 行, 第 i 行表示第 i 个任务的信息. 每行第一个整数表示第 i 个任务的工序数 K, 随后连续 K 组由空白字符分隔的数据, 第 j 组数据表示该任务的第 j 道工序的信息. 每组数据第一个整数表示可执行该工序的候选机器数 S, 随后连续 S 个由空白字符分隔的二元组, 二元组 (G, D) 表示该工序可由机器 G 执行且加工时长为 D. 例如, 以下算例文件表示有 2 个任务和 4 台机器, 每个任务至多 2 台候选机器; 其中, 任务 0 由 4 道工序构成, 其工序 0 可由机器 1 花费时长 654 完成, 其工序 1 可由机器 2 花费时长 147 完成, 其工序 2 可由机器 3 花费时长 345 完成, 其工序 3 可由机器 0 花费时长 447 完成; 任务 1 由 3 道工序构成, 其工序 0 可由机器 1 花费时长 321 完成或由机器 0 花费时长 321 完成, 其工序 1 可由机器 2 花费时长 520 完成, 其工序 2 可由机器 3 花费时长 789 完成: 1232 4 24 1 1 654 1 2 147 1 3 345 1 0 4473 2 1 321 0 321 1 2 520 1 3 789 上述算例内数据的分组情况可以更加直观地表示成下面的情况: 1232 4 24 [1 (1 654)] [1 (2 147)] [1 (3 345)] [1 (0 447)]3 [2 (1 321) (0 321)] [1 (2 520)] [1 (3 789)] 为了使算例的数据分组更加直观, 给出的算例可能会按照如下约定: 使用 4 个空格分隔每行的 K 组数据, 使用 2 个空格分隔 S 个二元组. 输出的解文件格式 输出 M 行整数表示 M 台机器的任务分配与排序情况, 第 i 行表示第 i 台机器上执行的工序的有序列表. 每一行第一个整数表示第 i 台机器加工的工序数 E, 随后连续 E 个由空白字符分隔的二元组, 二元组 (J, O) 表示加工了任务 J 的工序 O, 二元组的出现顺序表示第 i 台机器的加工顺序. 例如, 以下解文件表示 2 台机器上的任务分配与排序情况; 其中, 机器 0 执行了 3 道工序, 依次为任务 1 的工序 1, 任务 0 的工序 0, 任务 2 的工序 0; 机器 1 加工了 2 道工序, 依次为任务 0 的工序 1, 任务 1 的工序 0: 123 1 1 0 0 2 02 0 1 1 0 注意上述调度方案存在死锁, 不是可行的调度方案. 提交要求 发送至邮箱 szx@duhe.tech. 邮件标题格式为 \"Challenge2020FJSP-姓名-学校-专业\". 邮件附件为单个压缩包, 文件名为 \"姓名-学校-专业\", 其内包含下列文件. 必要 算法的可执行文件 (Windows 平台). 建议基于官方 SDK 开发 (https://gitee.com/suzhouxing/npbenchmark/tree/main/SDK.FJSP). 用 g++ 的同学编译时请静态链接, 即添加 -static-libgcc -static-libstdc++ 编译选项. 必要 算法源码. 可重入 (可在同一线程内反复调用而不会出现数据初始化错误或内存泄漏). 可并发 (可在同一进程内的多个线程同时运行多个算法求解实例而互不干扰, 满足此要求一般不能有全局的非只读变量). 可伸缩 (数据结构可以根据算例规模动态申请内存, 而非根据预先指定的编译期常量进行内存分配). 可选 算法在各算例上的运行情况概要, 至少包括以下几项信息 (仅在无法成功调用算法输出可通过检查程序的解时作为参考). 算例名. 所有任务的完工时间. 计算耗时. 可选 算法在各算例上求得的完工时间最短的解文件 (仅在无法成功调用算法输出可通过检查程序的解时作为参考). 若成功提交, 在收到邮件时以及测试完成后系统均会自动发送邮件反馈提交情况. 若测试结果较优, 可在排行榜页面看到自己的运行情况 (https://gitee.com/suzhouxing/npbenchmark.data/tree/data/FJSP). 其他说明参考 (SmartLab Challenge - ReadMe). 例如: 12345678910111213苏宙行-华科-计科.zip| fjsp.exe| results.csv|+---src| main.cpp| algorithm.cpp| algorithm.h|+---results fjsp.barnes.mt10c1.m11j10c2.txt fjsp.barnes.mt10cc.m12j10c2.txt ... 算例清单 下载地址: https://gitee.com/suzhouxing/npbenchmark.data/tree/data/FJSP/Instance fjsp.barnes.mt10c1.m11j10c2 fjsp.barnes.mt10cc.m12j10c2 fjsp.barnes.mt10x.m11j10c2 fjsp.barnes.mt10xx.m12j10c3 fjsp.barnes.mt10xxx.m13j10c4 fjsp.barnes.mt10xy.m12j10c2 fjsp.barnes.mt10xyz.m13j10c2 fjsp.barnes.setb4c9.m11j15c2 fjsp.barnes.setb4cc.m12j15c2 fjsp.barnes.setb4x.m11j15c2 fjsp.barnes.setb4xx.m12j15c3 fjsp.barnes.setb4xxx.m13j15c4 fjsp.barnes.setb4xy.m12j15c2 fjsp.barnes.setb4xyz.m13j15c2 fjsp.barnes.seti5c12.m16j15c2 fjsp.barnes.seti5cc.m17j15c2 fjsp.barnes.seti5x.m16j15c2 fjsp.barnes.seti5xx.m17j15c3 fjsp.barnes.seti5xxx.m18j15c4 fjsp.barnes.seti5xy.m17j15c2 fjsp.barnes.seti5xyz.m18j15c2 fjsp.brandimarte.Mk01.m6j10c3 fjsp.brandimarte.Mk02.m6j10c6 fjsp.brandimarte.Mk03.m8j15c5 fjsp.brandimarte.Mk04.m8j15c3 fjsp.brandimarte.Mk05.m4j15c2 fjsp.brandimarte.Mk06.m15j10c5 fjsp.brandimarte.Mk07.m5j20c5 fjsp.brandimarte.Mk08.m10j20c2 fjsp.brandimarte.Mk09.m10j20c5 fjsp.brandimarte.Mk10.m15j20c5 fjsp.dauzere.01a.m5j10c3 fjsp.dauzere.02a.m5j10c4 fjsp.dauzere.03a.m5j10c5 fjsp.dauzere.04a.m5j10c3 fjsp.dauzere.05a.m5j10c4 fjsp.dauzere.06a.m5j10c5 fjsp.dauzere.07a.m8j15c4 fjsp.dauzere.08a.m8j15c6 fjsp.dauzere.09a.m8j15c8 fjsp.dauzere.10a.m8j15c4 fjsp.dauzere.11a.m8j15c6 fjsp.dauzere.12a.m8j15c8 fjsp.dauzere.13a.m10j20c4 fjsp.dauzere.14a.m10j20c7 fjsp.dauzere.15a.m10j20c10 fjsp.dauzere.16a.m10j20c4 fjsp.dauzere.17a.m10j20c7 fjsp.dauzere.18a.m10j20c10 fjsp.hurink.edata-abz5.m10j10c2 fjsp.hurink.edata-abz6.m10j10c2 fjsp.hurink.edata-abz7.m15j20c3 fjsp.hurink.edata-abz8.m15j20c3 fjsp.hurink.edata-abz9.m15j20c3 fjsp.hurink.edata-car1.m5j11c2 fjsp.hurink.edata-car2.m4j13c2 fjsp.hurink.edata-car3.m5j12c2 fjsp.hurink.edata-car4.m4j14c2 fjsp.hurink.edata-car5.m6j10c2 fjsp.hurink.edata-car6.m9j8c2 fjsp.hurink.edata-car7.m7j7c2 fjsp.hurink.edata-car8.m8j8c2 fjsp.hurink.edata-la01.m5j10c2 fjsp.hurink.edata-la02.m5j10c2 fjsp.hurink.edata-la03.m5j10c2 fjsp.hurink.edata-la04.m5j10c2 fjsp.hurink.edata-la05.m5j10c2 fjsp.hurink.edata-la06.m5j15c2 fjsp.hurink.edata-la07.m5j15c2 fjsp.hurink.edata-la08.m5j15c2 fjsp.hurink.edata-la09.m5j15c2 fjsp.hurink.edata-la10.m5j15c2 fjsp.hurink.edata-la11.m5j20c2 fjsp.hurink.edata-la12.m5j20c2 fjsp.hurink.edata-la13.m5j20c2 fjsp.hurink.edata-la14.m5j20c2 fjsp.hurink.edata-la15.m5j20c2 fjsp.hurink.edata-la16.m10j10c2 fjsp.hurink.edata-la17.m10j10c2 fjsp.hurink.edata-la18.m10j10c2 fjsp.hurink.edata-la19.m10j10c2 fjsp.hurink.edata-la20.m10j10c2 fjsp.hurink.edata-la21.m10j15c3 fjsp.hurink.edata-la22.m10j15c3 fjsp.hurink.edata-la23.m10j15c2 fjsp.hurink.edata-la24.m10j15c3 fjsp.hurink.edata-la25.m10j15c3 fjsp.hurink.edata-la26.m10j20c3 fjsp.hurink.edata-la27.m10j20c3 fjsp.hurink.edata-la28.m10j20c3 fjsp.hurink.edata-la29.m10j20c3 fjsp.hurink.edata-la30.m10j20c3 fjsp.hurink.edata-la31.m10j30c3 fjsp.hurink.edata-la32.m10j30c3 fjsp.hurink.edata-la33.m10j30c2 fjsp.hurink.edata-la34.m10j30c3 fjsp.hurink.edata-la35.m10j30c2 fjsp.hurink.edata-la36.m15j15c3 fjsp.hurink.edata-la37.m15j15c3 fjsp.hurink.edata-la38.m15j15c3 fjsp.hurink.edata-la39.m15j15c3 fjsp.hurink.edata-la40.m15j15c3 fjsp.hurink.edata-mt06.m6j6c2 fjsp.hurink.edata-mt10.m10j10c2 fjsp.hurink.edata-mt20.m5j20c2 fjsp.hurink.edata-orb01.m10j10c2 fjsp.hurink.edata-orb02.m10j10c2 fjsp.hurink.edata-orb03.m10j10c2 fjsp.hurink.edata-orb04.m10j10c2 fjsp.hurink.edata-orb05.m10j10c2 fjsp.hurink.edata-orb06.m10j10c2 fjsp.hurink.edata-orb07.m10j10c2 fjsp.hurink.edata-orb08.m10j10c2 fjsp.hurink.edata-orb09.m10j10c2 fjsp.hurink.edata-orb10.m10j10c2 fjsp.hurink.rdata-abz5.m10j10c3 fjsp.hurink.rdata-abz6.m10j10c3 fjsp.hurink.rdata-abz7.m15j20c3 fjsp.hurink.rdata-abz8.m15j20c3 fjsp.hurink.rdata-abz9.m15j20c3 fjsp.hurink.rdata-car1.m5j11c3 fjsp.hurink.rdata-car2.m4j13c3 fjsp.hurink.rdata-car3.m5j12c3 fjsp.hurink.rdata-car4.m4j14c3 fjsp.hurink.rdata-car5.m6j10c3 fjsp.hurink.rdata-car6.m9j8c3 fjsp.hurink.rdata-car7.m7j7c3 fjsp.hurink.rdata-car8.m8j8c3 fjsp.hurink.rdata-la01.m5j10c3 fjsp.hurink.rdata-la02.m5j10c3 fjsp.hurink.rdata-la03.m5j10c3 fjsp.hurink.rdata-la04.m5j10c3 fjsp.hurink.rdata-la05.m5j10c3 fjsp.hurink.rdata-la06.m5j15c3 fjsp.hurink.rdata-la07.m5j15c3 fjsp.hurink.rdata-la08.m5j15c3 fjsp.hurink.rdata-la09.m5j15c3 fjsp.hurink.rdata-la10.m5j15c3 fjsp.hurink.rdata-la11.m5j20c3 fjsp.hurink.rdata-la12.m5j20c3 fjsp.hurink.rdata-la13.m5j20c3 fjsp.hurink.rdata-la14.m5j20c3 fjsp.hurink.rdata-la15.m5j20c3 fjsp.hurink.rdata-la16.m10j10c3 fjsp.hurink.rdata-la17.m10j10c3 fjsp.hurink.rdata-la18.m10j10c3 fjsp.hurink.rdata-la19.m10j10c3 fjsp.hurink.rdata-la20.m10j10c3 fjsp.hurink.rdata-la21.m10j15c3 fjsp.hurink.rdata-la22.m10j15c3 fjsp.hurink.rdata-la23.m10j15c3 fjsp.hurink.rdata-la24.m10j15c3 fjsp.hurink.rdata-la25.m10j15c3 fjsp.hurink.rdata-la26.m10j20c3 fjsp.hurink.rdata-la27.m10j20c3 fjsp.hurink.rdata-la28.m10j20c3 fjsp.hurink.rdata-la29.m10j20c3 fjsp.hurink.rdata-la30.m10j20c3 fjsp.hurink.rdata-la31.m10j30c3 fjsp.hurink.rdata-la32.m10j30c3 fjsp.hurink.rdata-la33.m10j30c3 fjsp.hurink.rdata-la34.m10j30c3 fjsp.hurink.rdata-la35.m10j30c3 fjsp.hurink.rdata-la36.m15j15c3 fjsp.hurink.rdata-la37.m15j15c3 fjsp.hurink.rdata-la38.m15j15c3 fjsp.hurink.rdata-la39.m15j15c3 fjsp.hurink.rdata-la40.m15j15c3 fjsp.hurink.rdata-mt06.m6j6c3 fjsp.hurink.rdata-mt10.m10j10c3 fjsp.hurink.rdata-mt20.m5j20c3 fjsp.hurink.rdata-orb01.m10j10c3 fjsp.hurink.rdata-orb02.m10j10c3 fjsp.hurink.rdata-orb03.m10j10c3 fjsp.hurink.rdata-orb04.m10j10c3 fjsp.hurink.rdata-orb05.m10j10c3 fjsp.hurink.rdata-orb06.m10j10c3 fjsp.hurink.rdata-orb07.m10j10c3 fjsp.hurink.rdata-orb08.m10j10c3 fjsp.hurink.rdata-orb09.m10j10c3 fjsp.hurink.rdata-orb10.m10j10c3 ##fjsp.hurink.sdata-abz5.m10j10c1 &lt;=&gt; jsp.ABZ05.m10j10c1 ##fjsp.hurink.sdata-abz6.m10j10c1 &lt;=&gt; jsp.ABZ06.m10j10c1 ##fjsp.hurink.sdata-abz7.m15j20c1 &lt;=&gt; jsp.ABZ07.m15j20c1 ##fjsp.hurink.sdata-abz8.m15j20c1 &lt;=&gt; jsp.ABZ08.m15j20c1 ##fjsp.hurink.sdata-abz9.m15j20c1 &lt;=&gt; jsp.ABZ09.m15j20c1 fjsp.hurink.sdata-car1.m5j11c1 fjsp.hurink.sdata-car2.m4j13c1 fjsp.hurink.sdata-car3.m5j12c1 fjsp.hurink.sdata-car4.m4j14c1 fjsp.hurink.sdata-car5.m6j10c1 fjsp.hurink.sdata-car6.m9j8c1 fjsp.hurink.sdata-car7.m7j7c1 fjsp.hurink.sdata-car8.m8j8c1 ##fjsp.hurink.sdata-la01.m5j10c1 &lt;=&gt; jsp.LA01.m5j10c1 ##fjsp.hurink.sdata-la02.m5j10c1 &lt;=&gt; jsp.LA02.m5j10c1 ##fjsp.hurink.sdata-la03.m5j10c1 &lt;=&gt; jsp.LA03.m5j10c1 ##fjsp.hurink.sdata-la04.m5j10c1 &lt;=&gt; jsp.LA04.m5j10c1 ##fjsp.hurink.sdata-la05.m5j10c1 &lt;=&gt; jsp.LA05.m5j10c1 ##fjsp.hurink.sdata-la06.m5j15c1 &lt;=&gt; jsp.LA06.m5j15c1 ##fjsp.hurink.sdata-la07.m5j15c1 &lt;=&gt; jsp.LA07.m5j15c1 ##fjsp.hurink.sdata-la08.m5j15c1 &lt;=&gt; jsp.LA08.m5j15c1 ##fjsp.hurink.sdata-la09.m5j15c1 &lt;=&gt; jsp.LA09.m5j15c1 ##fjsp.hurink.sdata-la10.m5j15c1 &lt;=&gt; jsp.LA10.m5j15c1 ##fjsp.hurink.sdata-la11.m5j20c1 &lt;=&gt; jsp.LA11.m5j20c1 ##fjsp.hurink.sdata-la12.m5j20c1 &lt;=&gt; jsp.LA12.m5j20c1 ##fjsp.hurink.sdata-la13.m5j20c1 &lt;=&gt; jsp.LA13.m5j20c1 ##fjsp.hurink.sdata-la14.m5j20c1 &lt;=&gt; jsp.LA14.m5j20c1 ##fjsp.hurink.sdata-la15.m5j20c1 &lt;=&gt; jsp.LA15.m5j20c1 ##fjsp.hurink.sdata-la16.m10j10c1 &lt;=&gt; jsp.LA16.m10j10c1 ##fjsp.hurink.sdata-la17.m10j10c1 &lt;=&gt; jsp.LA17.m10j10c1 ##fjsp.hurink.sdata-la18.m10j10c1 &lt;=&gt; jsp.LA18.m10j10c1 ##fjsp.hurink.sdata-la19.m10j10c1 &lt;=&gt; jsp.LA19.m10j10c1 ##fjsp.hurink.sdata-la20.m10j10c1 &lt;=&gt; jsp.LA20.m10j10c1 ##fjsp.hurink.sdata-la21.m10j15c1 &lt;=&gt; jsp.LA21.m10j15c1 ##fjsp.hurink.sdata-la22.m10j15c1 &lt;=&gt; jsp.LA22.m10j15c1 ##fjsp.hurink.sdata-la23.m10j15c1 &lt;=&gt; jsp.LA23.m10j15c1 ##fjsp.hurink.sdata-la24.m10j15c1 &lt;=&gt; jsp.LA24.m10j15c1 ##fjsp.hurink.sdata-la25.m10j15c1 &lt;=&gt; jsp.LA25.m10j15c1 ##fjsp.hurink.sdata-la26.m10j20c1 &lt;=&gt; jsp.LA26.m10j20c1 ##fjsp.hurink.sdata-la27.m10j20c1 &lt;=&gt; jsp.LA27.m10j20c1 ##fjsp.hurink.sdata-la28.m10j20c1 &lt;=&gt; jsp.LA28.m10j20c1 ##fjsp.hurink.sdata-la29.m10j20c1 &lt;=&gt; jsp.LA29.m10j20c1 ##fjsp.hurink.sdata-la30.m10j20c1 &lt;=&gt; jsp.LA30.m10j20c1 ##fjsp.hurink.sdata-la31.m10j30c1 &lt;=&gt; jsp.LA31.m10j30c1 ##fjsp.hurink.sdata-la32.m10j30c1 &lt;=&gt; jsp.LA32.m10j30c1 ##fjsp.hurink.sdata-la33.m10j30c1 &lt;=&gt; jsp.LA33.m10j30c1 ##fjsp.hurink.sdata-la34.m10j30c1 &lt;=&gt; jsp.LA34.m10j30c1 ##fjsp.hurink.sdata-la35.m10j30c1 &lt;=&gt; jsp.LA35.m10j30c1 ##fjsp.hurink.sdata-la36.m15j15c1 &lt;=&gt; jsp.LA36.m15j15c1 ##fjsp.hurink.sdata-la37.m15j15c1 &lt;=&gt; jsp.LA37.m15j15c1 ##fjsp.hurink.sdata-la38.m15j15c1 &lt;=&gt; jsp.LA38.m15j15c1 ##fjsp.hurink.sdata-la39.m15j15c1 &lt;=&gt; jsp.LA39.m15j15c1 ##fjsp.hurink.sdata-la40.m15j15c1 &lt;=&gt; jsp.LA40.m15j15c1 ##fjsp.hurink.sdata-mt06.m6j6c1 &lt;=&gt; jsp.FT06.m6j6c1 ##fjsp.hurink.sdata-mt10.m10j10c1 &lt;=&gt; jsp.FT10.m10j10c1 ##fjsp.hurink.sdata-mt20.m5j20c1 &lt;=&gt; jsp.FT20.m5j20c1 ##fjsp.hurink.sdata-orb01.m10j10c1 &lt;=&gt; jsp.ORB01.m10j10c1 ##fjsp.hurink.sdata-orb02.m10j10c1 &lt;=&gt; jsp.ORB02.m10j10c1 ##fjsp.hurink.sdata-orb03.m10j10c1 &lt;=&gt; jsp.ORB03.m10j10c1 ##fjsp.hurink.sdata-orb04.m10j10c1 &lt;=&gt; jsp.ORB04.m10j10c1 ##fjsp.hurink.sdata-orb05.m10j10c1 &lt;=&gt; jsp.ORB05.m10j10c1 ##fjsp.hurink.sdata-orb06.m10j10c1 &lt;=&gt; jsp.ORB06.m10j10c1 ##fjsp.hurink.sdata-orb07.m10j10c1 &lt;=&gt; jsp.ORB07.m10j10c1 ##fjsp.hurink.sdata-orb08.m10j10c1 &lt;=&gt; jsp.ORB08.m10j10c1 ##fjsp.hurink.sdata-orb09.m10j10c1 &lt;=&gt; jsp.ORB09.m10j10c1 ##fjsp.hurink.sdata-orb10.m10j10c1 &lt;=&gt; jsp.ORB10.m10j10c1 fjsp.hurink.vdata-abz5.m10j10c9 fjsp.hurink.vdata-abz6.m10j10c8 fjsp.hurink.vdata-abz7.m15j20c11 fjsp.hurink.vdata-abz8.m15j20c13 fjsp.hurink.vdata-abz9.m15j20c12 fjsp.hurink.vdata-car1.m5j11c5 fjsp.hurink.vdata-car2.m4j13c4 fjsp.hurink.vdata-car3.m5j12c4 fjsp.hurink.vdata-car4.m4j14c3 fjsp.hurink.vdata-car5.m6j10c5 fjsp.hurink.vdata-car6.m9j8c7 fjsp.hurink.vdata-car7.m7j7c6 fjsp.hurink.vdata-car8.m8j8c7 fjsp.hurink.vdata-la01.m5j10c5 fjsp.hurink.vdata-la02.m5j10c5 fjsp.hurink.vdata-la03.m5j10c5 fjsp.hurink.vdata-la04.m5j10c4 fjsp.hurink.vdata-la05.m5j10c5 fjsp.hurink.vdata-la06.m5j15c5 fjsp.hurink.vdata-la07.m5j15c5 fjsp.hurink.vdata-la08.m5j15c5 fjsp.hurink.vdata-la09.m5j15c5 fjsp.hurink.vdata-la10.m5j15c5 fjsp.hurink.vdata-la11.m5j20c5 fjsp.hurink.vdata-la12.m5j20c5 fjsp.hurink.vdata-la13.m5j20c4 fjsp.hurink.vdata-la14.m5j20c5 fjsp.hurink.vdata-la15.m5j20c5 fjsp.hurink.vdata-la16.m10j10c8 fjsp.hurink.vdata-la17.m10j10c9 fjsp.hurink.vdata-la18.m10j10c9 fjsp.hurink.vdata-la19.m10j10c8 fjsp.hurink.vdata-la20.m10j10c8 fjsp.hurink.vdata-la21.m10j15c8 fjsp.hurink.vdata-la22.m10j15c8 fjsp.hurink.vdata-la23.m10j15c8 fjsp.hurink.vdata-la24.m10j15c8 fjsp.hurink.vdata-la25.m10j15c9 fjsp.hurink.vdata-la26.m10j20c9 fjsp.hurink.vdata-la27.m10j20c9 fjsp.hurink.vdata-la28.m10j20c9 fjsp.hurink.vdata-la29.m10j20c9 fjsp.hurink.vdata-la30.m10j20c9 fjsp.hurink.vdata-la31.m10j30c9 fjsp.hurink.vdata-la32.m10j30c9 fjsp.hurink.vdata-la33.m10j30c8 fjsp.hurink.vdata-la34.m10j30c9 fjsp.hurink.vdata-la35.m10j30c9 fjsp.hurink.vdata-la36.m15j15c12 fjsp.hurink.vdata-la37.m15j15c12 fjsp.hurink.vdata-la38.m15j15c12 fjsp.hurink.vdata-la39.m15j15c11 fjsp.hurink.vdata-la40.m15j15c11 fjsp.hurink.vdata-mt06.m6j6c5 fjsp.hurink.vdata-mt10.m10j10c8 fjsp.hurink.vdata-mt20.m5j20c5 fjsp.hurink.vdata-orb01.m10j10c8 fjsp.hurink.vdata-orb02.m10j10c8 fjsp.hurink.vdata-orb03.m10j10c8 fjsp.hurink.vdata-orb04.m10j10c9 fjsp.hurink.vdata-orb05.m10j10c8 fjsp.hurink.vdata-orb06.m10j10c8 fjsp.hurink.vdata-orb07.m10j10c8 fjsp.hurink.vdata-orb08.m10j10c8 fjsp.hurink.vdata-orb09.m10j10c8 fjsp.hurink.vdata-orb10.m10j10c8 jsp.ABZ05.m10j10c1 jsp.ABZ06.m10j10c1 jsp.ABZ07.m15j20c1 jsp.ABZ08.m15j20c1 jsp.ABZ09.m15j20c1 jsp.DMU01.m15j20c1 jsp.DMU02.m15j20c1 jsp.DMU03.m15j20c1 jsp.DMU04.m15j20c1 jsp.DMU05.m15j20c1 jsp.DMU06.m20j20c1 jsp.DMU07.m20j20c1 jsp.DMU08.m20j20c1 jsp.DMU09.m20j20c1 jsp.DMU10.m20j20c1 jsp.DMU11.m15j30c1 jsp.DMU12.m15j30c1 jsp.DMU13.m15j30c1 jsp.DMU14.m15j30c1 jsp.DMU15.m15j30c1 jsp.DMU16.m20j30c1 jsp.DMU17.m20j30c1 jsp.DMU18.m20j30c1 jsp.DMU19.m20j30c1 jsp.DMU20.m20j30c1 jsp.DMU21.m15j40c1 jsp.DMU22.m15j40c1 jsp.DMU23.m15j40c1 jsp.DMU24.m15j40c1 jsp.DMU25.m15j40c1 jsp.DMU26.m20j40c1 jsp.DMU27.m20j40c1 jsp.DMU28.m20j40c1 jsp.DMU29.m20j40c1 jsp.DMU30.m20j40c1 jsp.DMU31.m15j50c1 jsp.DMU32.m15j50c1 jsp.DMU33.m15j50c1 jsp.DMU34.m15j50c1 jsp.DMU35.m15j50c1 jsp.DMU36.m20j50c1 jsp.DMU37.m20j50c1 jsp.DMU38.m20j50c1 jsp.DMU39.m20j50c1 jsp.DMU40.m20j50c1 jsp.DMU41.m15j20c1 jsp.DMU42.m15j20c1 jsp.DMU43.m15j20c1 jsp.DMU44.m15j20c1 jsp.DMU45.m15j20c1 jsp.DMU46.m20j20c1 jsp.DMU47.m20j20c1 jsp.DMU48.m20j20c1 jsp.DMU49.m20j20c1 jsp.DMU50.m20j20c1 jsp.DMU51.m15j30c1 jsp.DMU52.m15j30c1 jsp.DMU53.m15j30c1 jsp.DMU54.m15j30c1 jsp.DMU55.m15j30c1 jsp.DMU56.m20j30c1 jsp.DMU57.m20j30c1 jsp.DMU58.m20j30c1 jsp.DMU59.m20j30c1 jsp.DMU60.m20j30c1 jsp.DMU61.m15j40c1 jsp.DMU62.m15j40c1 jsp.DMU63.m15j40c1 jsp.DMU64.m15j40c1 jsp.DMU65.m15j40c1 jsp.DMU66.m20j40c1 jsp.DMU67.m20j40c1 jsp.DMU68.m20j40c1 jsp.DMU69.m20j40c1 jsp.DMU70.m20j40c1 jsp.DMU71.m15j50c1 jsp.DMU72.m15j50c1 jsp.DMU73.m15j50c1 jsp.DMU74.m15j50c1 jsp.DMU75.m15j50c1 jsp.DMU76.m20j50c1 jsp.DMU77.m20j50c1 jsp.DMU78.m20j50c1 jsp.DMU79.m20j50c1 jsp.DMU80.m20j50c1 jsp.FT06.m6j6c1 jsp.FT10.m10j10c1 jsp.FT20.m5j20c1 jsp.LA01.m5j10c1 jsp.LA02.m5j10c1 jsp.LA03.m5j10c1 jsp.LA04.m5j10c1 jsp.LA05.m5j10c1 jsp.LA06.m5j15c1 jsp.LA07.m5j15c1 jsp.LA08.m5j15c1 jsp.LA09.m5j15c1 jsp.LA10.m5j15c1 jsp.LA11.m5j20c1 jsp.LA12.m5j20c1 jsp.LA13.m5j20c1 jsp.LA14.m5j20c1 jsp.LA15.m5j20c1 jsp.LA16.m10j10c1 jsp.LA17.m10j10c1 jsp.LA18.m10j10c1 jsp.LA19.m10j10c1 jsp.LA20.m10j10c1 jsp.LA21.m10j15c1 jsp.LA22.m10j15c1 jsp.LA23.m10j15c1 jsp.LA24.m10j15c1 jsp.LA25.m10j15c1 jsp.LA26.m10j20c1 jsp.LA27.m10j20c1 jsp.LA28.m10j20c1 jsp.LA29.m10j20c1 jsp.LA30.m10j20c1 jsp.LA31.m10j30c1 jsp.LA32.m10j30c1 jsp.LA33.m10j30c1 jsp.LA34.m10j30c1 jsp.LA35.m10j30c1 jsp.LA36.m15j15c1 jsp.LA37.m15j15c1 jsp.LA38.m15j15c1 jsp.LA39.m15j15c1 jsp.LA40.m15j15c1 jsp.ORB01.m10j10c1 jsp.ORB02.m10j10c1 jsp.ORB03.m10j10c1 jsp.ORB04.m10j10c1 jsp.ORB05.m10j10c1 jsp.ORB06.m10j10c1 jsp.ORB07.m10j10c1 jsp.ORB08.m10j10c1 jsp.ORB09.m10j10c1 jsp.ORB10.m10j10c1 jsp.SWV01.m10j20c1 jsp.SWV02.m10j20c1 jsp.SWV03.m10j20c1 jsp.SWV04.m10j20c1 jsp.SWV05.m10j20c1 jsp.SWV06.m15j20c1 jsp.SWV07.m15j20c1 jsp.SWV08.m15j20c1 jsp.SWV09.m15j20c1 jsp.SWV10.m15j20c1 jsp.SWV11.m10j50c1 jsp.SWV12.m10j50c1 jsp.SWV13.m10j50c1 jsp.SWV14.m10j50c1 jsp.SWV15.m10j50c1 jsp.SWV16.m10j50c1 jsp.SWV17.m10j50c1 jsp.SWV18.m10j50c1 jsp.SWV19.m10j50c1 jsp.SWV20.m10j50c1 jsp.TA01.m15j15c1 jsp.TA02.m15j15c1 jsp.TA03.m15j15c1 jsp.TA04.m15j15c1 jsp.TA05.m15j15c1 jsp.TA06.m15j15c1 jsp.TA07.m15j15c1 jsp.TA08.m15j15c1 jsp.TA09.m15j15c1 jsp.TA10.m15j15c1 jsp.TA11.m15j20c1 jsp.TA12.m15j20c1 jsp.TA13.m15j20c1 jsp.TA14.m15j20c1 jsp.TA15.m15j20c1 jsp.TA16.m15j20c1 jsp.TA17.m15j20c1 jsp.TA18.m15j20c1 jsp.TA19.m15j20c1 jsp.TA20.m15j20c1 jsp.TA21.m20j20c1 jsp.TA22.m20j20c1 jsp.TA23.m20j20c1 jsp.TA24.m20j20c1 jsp.TA25.m20j20c1 jsp.TA26.m20j20c1 jsp.TA27.m20j20c1 jsp.TA28.m20j20c1 jsp.TA29.m20j20c1 jsp.TA30.m20j20c1 jsp.TA31.m15j30c1 jsp.TA32.m15j30c1 jsp.TA33.m15j30c1 jsp.TA34.m15j30c1 jsp.TA35.m15j30c1 jsp.TA36.m15j30c1 jsp.TA37.m15j30c1 jsp.TA38.m15j30c1 jsp.TA39.m15j30c1 jsp.TA40.m15j30c1 jsp.TA41.m20j30c1 jsp.TA42.m20j30c1 jsp.TA43.m20j30c1 jsp.TA44.m20j30c1 jsp.TA45.m20j30c1 jsp.TA46.m20j30c1 jsp.TA47.m20j30c1 jsp.TA48.m20j30c1 jsp.TA49.m20j30c1 jsp.TA50.m20j30c1 jsp.TA51.m15j50c1 jsp.TA52.m15j50c1 jsp.TA53.m15j50c1 jsp.TA54.m15j50c1 jsp.TA55.m15j50c1 jsp.TA56.m15j50c1 jsp.TA57.m15j50c1 jsp.TA58.m15j50c1 jsp.TA59.m15j50c1 jsp.TA60.m15j50c1 jsp.TA61.m20j50c1 jsp.TA62.m20j50c1 jsp.TA63.m20j50c1 jsp.TA64.m20j50c1 jsp.TA65.m20j50c1 jsp.TA66.m20j50c1 jsp.TA67.m20j50c1 jsp.TA68.m20j50c1 jsp.TA69.m20j50c1 jsp.TA70.m20j50c1 jsp.TA71.m20j100c1 jsp.TA72.m20j100c1 jsp.TA73.m20j100c1 jsp.TA74.m20j100c1 jsp.TA75.m20j100c1 jsp.TA76.m20j100c1 jsp.TA77.m20j100c1 jsp.TA78.m20j100c1 jsp.TA79.m20j100c1 jsp.TA80.m20j100c1 jsp.YN01.m20j20c1 jsp.YN02.m20j20c1 jsp.YN03.m20j20c1 jsp.YN04.m20j20c1","categories":[{"name":"算法挑战","slug":"算法挑战","permalink":"http://suzhouxing.github.io/techive/categories/算法挑战/"}],"tags":[{"name":"Challenge","slug":"Challenge","permalink":"http://suzhouxing.github.io/techive/tags/Challenge/"},{"name":"算法挑战","slug":"算法挑战","permalink":"http://suzhouxing.github.io/techive/tags/算法挑战/"},{"name":"组合优化","slug":"组合优化","permalink":"http://suzhouxing.github.io/techive/tags/组合优化/"}]},{"title":"SmartLab Challenge 2020 - p-Center and Unicost Set Covering","slug":"Contest-2020pCenter","date":"2020-12-22T02:19:15.000Z","updated":"2022-05-27T10:12:31.413Z","comments":true,"path":"2020/12/22/Contest-2020pCenter/","link":"","permalink":"http://suzhouxing.github.io/techive/2020/12/22/Contest-2020pCenter/","excerpt":"","text":"中心选址问题是通信与物流等领域中的重要问题, 其背后的单一成本集合覆盖问题更是用途广泛. 中心选址问题和单一成本集合覆盖问题主要研究如何使用有限的资源提供尽可能高质量的服务的问题. 例如, 移动基站, 消防站, 物流仓库, 数据中心等众多设施的选址都可以建模为中心选址问题. 高效的中心选址或单一成本集合覆盖问题的求解算法具有极其重要的理论与应用价值. 中心选址与单一成本集合覆盖算法训练 问题概述 给定一系列节点, 从中选出若干节点作为中心为其他节点提供服务. 若一个节点由某个中心服务, 则认为其间存在一条服务边. 在确保每个节点至少由一个中心服务的前提下, 使最长的服务边最短. 若固定服务半径 (服务边的最大长度), 该问题等价于集合覆盖问题. 即给定一系列元素与若干子集, 请选择给定数量的子集, 使其并集等于所有元素的全集. 参考文献. [1] Z. Su, Q. Zhang, Z. Lü, C.-M. Li, W. Lin, and F. Ma, “Weighting-based Variable Neighborhood Search for Optimal Camera Placement,” Proceedings of the AAAI Conference on Artificial Intelligence, vol. 35, no. 14, pp. 12400–12408, 2021. [2] Q. Zhang, Z. Lü, Z. Su, C. Li, Y. Fang, and F. Ma, “Vertex Weighting-Based Tabu Search for p-Center Problem,” in Proceedings of the Twenty-Ninth International Joint Conference on Artificial Intelligence, IJCAI-20, 2020, pp. 1481–1487. doi: 10.24963/ijcai.2020/206. 命令行参数 请大家编写程序时支持两个命令行参数, 依次为运行时间上限 (单位为秒) 和随机种子 (0-65535). 算例文件已重定向至标准输入 stdin/cin, 标准输出 stdout/cout 已重定向至解文件 (如需打印调试信息, 请使用标准错误输出 stderr/cerr). 例如, 在控制台运行以下命令表示调用可执行文件 pcenter.exe 在限时 1000 秒, 随机种子为 12345 的情况下求解路径为 ../data/pmed1.n100p5.txt 的算例, 解文件输出至 sln.pmed1.n100p5.txt: 1pcenter.exe 1000 123456 &lt;../data/pmed1.n100p5.txt &gt;sln.pmed1.n100p5.txt 运行时间上限. 超出运行时间上限后测试程序会强行终止算法, 请确保在此之前已输出解 (最好还能自行正常退出). 随机种子设置. 使用 C 语言随机数生成器请用 srand. 使用 C++ 随机数生成器 (如 mt19937) 请在构造时传参或调用 seed() 方法设置. 输入的算例文件格式 所有算例均已根据给定覆盖半径转换为判定问题, 处理为一系列固定集合数的单一成本集合覆盖算例, 并附有逐步缩小半径时新增的无法覆盖的节点的信息. 转换后每个节点都可以覆盖若干节点, 同时也对称地被若干节点覆盖, 故转换后的单一成本集合覆盖算例中集合数等于元素数. 所有算例的元素和集合分别从 0 开始连续编号. 第一行给出 2 个由空白字符分隔的整数 N 和 P, 分别表示节点数和中心数 (从集合覆盖的角度来看, N 既是集合数又是元素数, P 为可挑选出的集合数). 接下来每 2 行一组, 连续 N 组给出每个集合的覆盖范围. 每组中第一行为该集合能覆盖的元素数量 C, 第二行为空白字符分隔的 C 个数字, 分别表示该集合能覆盖的元素的编号. 然后给出 2 个由空白字符分隔的整数 U 和 L, 分别表示覆盖半径边长序号的上界和下界 (其中上界即前面给出的判定问题对应的覆盖半径的边长序号, 下界为估计值). 接下来连续 U - L 行给出每缩小一次覆盖半径新增的无法覆盖的元素的信息 (若 U = L = 0, 说明前面给出的判定问题对应的覆盖半径已经为最优半径, 缩小半径后已不存在可行解). 每行第一个整数 K 表示本次缩小半径将导致 K 个元素不再被某个集合覆盖, 随后连续 K 个由空白字符分隔的整数 S 表示集合 S 将新增一个无法覆盖的元素 (同一个集合可能重复出现多次). 注意, 在前面给出的判定问题数据中, 每个集合可覆盖的元素已按从近到远的顺序排序, 即每次只用将集合 S 可覆盖元素列表末尾的一个元素删除即可. 例如, 以下算例文件表示集合和元素的数量均为 4, 要求挑选出 2 个集合覆盖所有元素; 其中, 集合 0 可以覆盖 2 个元素, 分别为元素 0 和 3; 集合 1 可以覆盖 2 个元素, 分别为元素 1 和 2; 集合 2 可以覆盖 3 个元素, 分别为元素 1, 2 和 3; 集合 3 可以覆盖 2 个元素, 分别为元素 0 和 2; 覆盖半径边长序号的上界为 5 下界为 3; 其中, 半径缩小为第 4 短的边时, 集合 2 无法再覆盖最远的元素 3, 集合 3 无法再覆盖最远的元素 2; 半径缩小为第 3 短的边时, 集合 1 无法再覆盖最远的元素 2, 集合 2 无法再覆盖最远的元素 1: 1234567891011124 220 321 231 2 320 25 32 2 32 1 2 输出的解文件格式 输出 P 个用空白字符 (建议使用换行符) 分隔的整数, 分别表示挑选出的 P 个中心 (集合). 例如, 以下解文件表示选择节点 0 和 2 作为中心 (集合): 1202 提交要求 发送至邮箱 szx@duhe.tech. 邮件标题格式为 \"Challenge2020PCP-姓名-学校-专业\". 邮件附件为单个压缩包 (文件大小 2M 以内), 文件名为 \"姓名-学校-专业\", 其内包含下列文件. 必要 算法的可执行文件 (Windows 平台). 建议基于官方 SDK 开发 (https://gitee.com/suzhouxing/npbenchmark/tree/main/SDK.PCP). 用 g++ 的同学编译时请静态链接, 即添加 -static-libgcc -static-libstdc++ 编译选项. 必要 算法源码. 可重入 (可在同一线程内反复调用而不会出现数据初始化错误或内存泄漏). 可并发 (可在同一进程内的多个线程同时运行多个算法求解实例而互不干扰, 满足此要求一般不能有全局的非只读变量). 可伸缩 (数据结构可以根据算例规模动态申请内存, 而非根据预先指定的编译期常量进行内存分配). 可选 算法在各算例上的运行情况概要, 至少包括以下几项信息 (仅在无法成功调用算法输出可通过检查程序的解时作为参考). 算例名. 服务半径. 计算耗时. 可选 算法在各算例上求得的完全覆盖的解文件 (仅在无法成功调用算法输出可通过检查程序的解时作为参考). 若成功提交, 在收到邮件时以及测试完成后系统均会自动发送邮件反馈提交情况. 若测试结果较优, 可在排行榜页面看到自己的运行情况 (https://gitee.com/suzhouxing/npbenchmark.data/tree/data/PCP). 其他说明参考 (SmartLab Challenge - ReadMe). 例如: 12345678910111213苏宙行-华科-计科.zip| pcenter.exe| results.csv|+---src| main.cpp| algorithm.cpp| algorithm.h|+---results pmed1.n100p5.txt pmed2.n100p10.txt ... 算例清单 下载地址: https://gitee.com/suzhouxing/npbenchmark.data/tree/data/PCP/Instance 算例规模从小到大依次为 (求解难度不一定随规模增加, 但除 pcb3038* 以外的算例应该都很容易求解): pmed01.n100p005 pmed02.n100p010 pmed03.n100p010 pmed04.n100p020 pmed05.n100p033 pmed06.n200p005 pmed07.n200p010 pmed08.n200p020 pmed09.n200p040 pmed10.n200p067 pmed11.n300p005 pmed12.n300p010 pmed13.n300p030 pmed14.n300p060 pmed15.n300p100 pmed16.n400p005 pmed17.n400p010 pmed18.n400p040 pmed19.n400p080 pmed20.n400p133 pmed21.n500p005 pmed22.n500p010 pmed23.n500p050 pmed24.n500p100 pmed25.n500p167 pmed26.n600p005 pmed27.n600p010 pmed28.n600p060 pmed29.n600p120 pmed30.n600p200 pmed31.n700p005 pmed32.n700p010 pmed33.n700p070 pmed34.n700p140 pmed35.n800p005 pmed36.n800p010 pmed37.n800p080 pmed38.n900p005 pmed39.n900p010 pmed40.n900p090 u1060p010 u1060p020 u1060p030 u1060p040 u1060p050 u1060p060 u1060p070 u1060p080 u1060p090 u1060p100 u1060p110 u1060p120 u1060p130 u1060p140 u1060p150 rl1323p010 rl1323p020 rl1323p030 rl1323p040 rl1323p050 rl1323p060 rl1323p070 rl1323p080 rl1323p090 rl1323p100 u1817p010 u1817p020 u1817p030 u1817p040 u1817p050 u1817p060 u1817p070 u1817p080 u1817p090 u1817p100 u1817p110 u1817p120 u1817p130 u1817p140 u1817p150 pcb3038p010r729 pcb3038p020r494 pcb3038p030r394 pcb3038p040r337 pcb3038p050r299 pcb3038p100r207 pcb3038p150r165 pcb3038p200r141 pcb3038p250r123 pcb3038p300r116 pcb3038p350r105 pcb3038p400r97 pcb3038p450r89 pcb3038p500r85","categories":[{"name":"算法挑战","slug":"算法挑战","permalink":"http://suzhouxing.github.io/techive/categories/算法挑战/"}],"tags":[{"name":"Challenge","slug":"Challenge","permalink":"http://suzhouxing.github.io/techive/tags/Challenge/"},{"name":"算法挑战","slug":"算法挑战","permalink":"http://suzhouxing.github.io/techive/tags/算法挑战/"},{"name":"组合优化","slug":"组合优化","permalink":"http://suzhouxing.github.io/techive/tags/组合优化/"}]},{"title":"SmartLab Challenge 2020 - Graph Coloring","slug":"Contest-2020GraphColoring","date":"2020-12-09T02:28:35.000Z","updated":"2022-05-27T10:12:27.150Z","comments":true,"path":"2020/12/09/Contest-2020GraphColoring/","link":"","permalink":"http://suzhouxing.github.io/techive/2020/12/09/Contest-2020GraphColoring/","excerpt":"","text":"图着色问题在众多领域中有广泛的应用, 可以用来对各种各样的组合优化问题进行建模. 图着色问题主要研究独占资源的分配问题. 比如在编译器给变量分配寄存器分配时, 如果两个变量的生命周期有交集, 则不能分配至同一寄存器. 比如在机场分配停机位时, 如果两架飞机的过站时间有交集, 则不能分配至同一停机位. 比如在光纤网络中进行波长分配时, 如果两条光路经过同一条链路, 则不能使用同一波长传输. 比如移动基站进行通讯频率分配时, 如果两个终端设备位于同一组天线的覆盖范围内, 则不能使用同一通讯频率. 比如在学校排课表时, 如果两个班级要上同一位教师的课, 则其上课时间不能相同. 高效的图着色问题求解算法具有极其重要的理论与应用价值. 图着色算法训练 问题概述 给定一个无向图, 请为每个节点染一种颜色, 在任意一条无向边两端的节点颜色不同的情况下, 最小化使用的颜色数. 参考文献. [1] Z. Lü and J.-K. Hao, “A memetic algorithm for graph coloring,” European Journal of Operational Research, vol. 203, no. 1, pp. 241–250, 2010, doi: 10.1016/j.ejor.2009.07.016. [2] L. Moalic and A. Gondran, “Variations on memetic algorithms for graph coloring problems,” Journal of Heuristics, vol. 24, no. 1, pp. 1–24, 2018, doi: 10.1007/s10732-017-9354-9. 命令行参数 请大家编写程序时支持两个命令行参数, 依次为运行时间上限 (单位为秒) 和随机种子 (0-65535). 算例文件已重定向至标准输入 stdin/cin, 标准输出 stdout/cout 已重定向至解文件 (如需打印调试信息, 请使用标准错误输出 stderr/cerr). 例如, 在控制台运行以下命令表示调用可执行文件 gcp.exe 在限时 600 秒, 随机种子为 12345 的情况下求解路径为 ../data/DSJC500.5.txt 的算例, 解文件输出至 sln.dsjc500.5.txt: 1gcp.exe 600 123456 &lt;../data/DSJC500.5.txt &gt;sln.dsjc500.5.txt 运行时间上限. 超出运行时间上限后测试程序会强行终止算法, 请确保在此之前已输出解 (最好还能自行正常退出). 随机种子设置. 使用 C 语言随机数生成器请用 srand. 使用 C++ 随机数生成器 (如 mt19937) 请在构造时传参或调用 seed() 方法设置. 输入的算例文件格式 所有算例的节点从 0 开始连续编号. 第一行给出 3 个由空白字符分隔的整数, 分别表示节点数 N, 无向边数 E (有向边数为 2E), 以及参考颜色数 C (相对容易求得可行解, 非最优颜色数). 接下来连续 E 行, 每行包含 2 个由空白字符分隔的整数, 表示一条无向边的两个端点. 例如, 以下算例文件表示节点数为 4, 无向边数为 3, 参考颜色数为 2; 其中: 节点 0 分别与 1, 2, 3 相邻. 12344 3 20 10 23 0 输出的解文件格式 输出 N 个用空白字符 (建议使用换行符) 分隔整数表示 N 个节点的染色情况, 第 i 个整数表示第 i 个节点的颜色. 颜色可以取 int 范围内任意非负整数, 检查程序自动统计不同的非负整数的数量. 例如, 以下解文件表示节点 0 染颜色 0, 节点 1 染颜色 1, 节点 2 染颜色 1, 节点 3 染颜色 1: 12340111 提交要求 发送至邮箱 szx@duhe.tech. 邮件标题格式为 \"Challenge2020GCP-姓名-学校-专业\". 邮件附件为单个压缩包 (文件大小 2M 以内), 文件名为 \"姓名-学校-专业\", 其内包含下列文件. 必要 算法的可执行文件 (Windows 平台). 建议基于官方 SDK 开发 (https://gitee.com/suzhouxing/npbenchmark/tree/main/SDK.GCP). 用 g++ 的同学编译时建议静态链接, 即添加 -static-libgcc -static-libstdc++ 编译选项. 必要 算法源码. 可重入 (可在同一线程内反复调用而不会出现数据初始化错误或内存泄漏). 可并发 (可在同一进程内的多个线程同时运行多个算法求解实例而互不干扰, 满足此要求一般不能有全局的非只读变量). 可伸缩 (数据结构可以根据算例规模动态申请内存, 而非根据预先指定的编译期常量进行内存分配). 可选 算法在各算例上的运行情况概要, 至少包括以下几项信息 (仅在无法成功调用算法输出可通过检查程序的解时作为参考). 算例名. 颜色数. 计算耗时. 可选 算法在各算例上求得的颜色数最少的解文件 (仅在无法成功调用算法输出可通过检查程序的解时作为参考). 若成功提交, 在收到邮件时以及测试完成后系统均会自动发送邮件反馈提交情况. 若测试结果较优, 可在排行榜页面看到自己的运行情况 (https://gitee.com/suzhouxing/npbenchmark.data/tree/data/GCP). 其他说明参考 (SmartLab Challenge - ReadMe). 例如: 12345678910111213苏宙行-华科-计科.zip| gc.exe| results.csv|+---src| main.cpp| algorithm.cpp| algorithm.h|+---results DSJC125.1.txt DSJC125.5.txt ... 算例清单 下载地址: https://gitee.com/suzhouxing/npbenchmark.data/tree/data/GCP/Instance 算例规模从小到大依次为 (求解难度不一定随规模增加, 但 DSJC500.5 以前的算例应该都很容易求解): DSJC0125.1 DSJC0125.5 DSJC0125.9 DSJC0250.1 DSJC0250.5 DSJC0250.9 DSJC0500.1 DSJC0500.5 DSJC0500.9 DSJC1000.1 DSJC1000.5 DSJC1000.9","categories":[{"name":"算法挑战","slug":"算法挑战","permalink":"http://suzhouxing.github.io/techive/categories/算法挑战/"}],"tags":[{"name":"Challenge","slug":"Challenge","permalink":"http://suzhouxing.github.io/techive/tags/Challenge/"},{"name":"算法挑战","slug":"算法挑战","permalink":"http://suzhouxing.github.io/techive/tags/算法挑战/"},{"name":"组合优化","slug":"组合优化","permalink":"http://suzhouxing.github.io/techive/tags/组合优化/"}]},{"title":"用 Gitea 搭建自己的 Git 服务器","slug":"SetupGitServerWithGitea","date":"2019-10-17T06:18:36.000Z","updated":"2022-06-05T03:11:54.626Z","comments":true,"path":"2019/10/17/SetupGitServerWithGitea/","link":"","permalink":"http://suzhouxing.github.io/techive/2019/10/17/SetupGitServerWithGitea/","excerpt":"","text":"","categories":[{"name":"技术","slug":"技术","permalink":"http://suzhouxing.github.io/techive/categories/技术/"}],"tags":[{"name":"技术","slug":"技术","permalink":"http://suzhouxing.github.io/techive/tags/技术/"},{"name":"Git","slug":"Git","permalink":"http://suzhouxing.github.io/techive/tags/Git/"},{"name":"Gitea","slug":"Gitea","permalink":"http://suzhouxing.github.io/techive/tags/Gitea/"}]},{"title":"组合优化 (五) 数学规划进阶","slug":"Opt-AdvancedMathematicalProgramming","date":"2019-01-13T03:14:59.000Z","updated":"2022-02-24T09:35:24.294Z","comments":true,"path":"2019/01/13/Opt-AdvancedMathematicalProgramming/","link":"","permalink":"http://suzhouxing.github.io/techive/2019/01/13/Opt-AdvancedMathematicalProgramming/","excerpt":"","text":"虽然目前最顶尖的商业求解器已经非常高效, 直接求解完整的问题模型往往比普通人自己实现算法性能更好, 但是面对特定的问题, 仍然有改进空间. 另一方面, 先贤们告诉我们要站在巨人的肩膀上, 要重用前人的优秀成果. 于是, 我们可以得到一个在完全自行设计算法和完全使用通用求解器之间的折中的方案, 发挥多种方法各自的优势, 更好地解决问题. 线性规划与混合整数规划 (进阶技巧) 非线性表达式 可以转化为线性表达式的非线性表达式 最大值最小值 绝对值 分段线性函数 ... 可以较高效求解的非线性表达式 Quadratic Program (QP) Special Ordered Set (SOS) Mixed Integer Program (MIP) ... 详见 [1.5] 线性化非线性表达式.docx. 最小化最大值 使用一个辅助变量限制决策变量的界 约束的可行区域应与优化方向 \"相反\" 最小化一个表达式 \\(l = f(x)\\), 应该确定 \\(l\\) 的下界, 即 \\(g(x) \\le l \\le +\\infty\\) 最大化一个表达式 \\(u = f(x)\\), 如果只约束其下界, 将导致目标无限增大 最小化最小值 最小值的下界? 让较大的值都可以忽略 Big-M (充分大的 M) 课堂练习 最大化最大值? 最大化绝对值? 多目标 线性加权模式 简单, 本质上就是单目标 各目标量纲不同时难以确定权重系数 优先级模式 高优先级对低优先级有压倒性优势 高优先级目标有一定的绝对/相对容差范围 实现优先级模式 使用线性加权模式模拟 难以确定各目标的取值范围以形成隔离 目标过多容易溢出或者产生巨大的数值误差 迭代求解 按优先级逐个优化 每个目标算到最优解后根据容差范围添加约束限制目标函数的取值 求解性能依赖热启动 (warm start) 效果 约束类型 类型 特征 最优性 完整性 检查时间 被忽略 user cut 排除显然不可能最优的解向量 不改变最优解 不影响模型的完整性 可能在任意时刻被检查 可能 lazy constraint 最优解不太可能违反的约束 会改变最优解 影响模型的完整性 仅在找到解时才被检查 不会 constraint 容易与优化目标产生冲突的约束 会改变最优解 影响模型的完整性 在任意时刻都会被检查 不会 注: 在 MIP 中, 整数解才是原始问题的解, 故在找到松弛的实数解时不会触发惰性约束. 以下为 CPLEX 对惰性约束和用户割平面的介绍: In contrast to the cuts that IBM ILOG CPLEX may automatically add while solving a problem, user cuts are those cuts that a user defines based on information already implied about the problem by the constraints; user cuts may not be strictly necessary to the problem, but they tighten the model. Lazy constraints are constraints that the user knows are unlikely to be violated, and in consequence, the user wants them applied lazily, that is, only as necessary or not before needed. User cuts can be grouped together in a pool of user cuts. Likewise, lazy constraints can also be grouped into a pool of lazy constraints. Cuts may resemble ordinary constraints, but are conventionally defined to mean those which can change the feasible space of the continuous relaxation but do not rule out any feasible integer solution that the rest of the model permits. A collection of cuts, therefore, involves an element of freedom: whether or not to apply them, individually or collectively, during the optimization of a MIP model; the formulation of the model remains correct whether or not the cuts are included. This degree of freedom means that if valid and necessary constraints are mis-identified by the user and passed to CPLEX as user cuts, unpredictable and possibly incorrect results could occur. By contrast, lazy constraints represent simply one portion of the constraint set, and the model would be incomplete (and possibly would deliver incorrect answers) in their absence. CPLEX always makes sure that lazy constraints are satisfied before producing any solution to a MIP model. Needed lazy constraints are also kept in effect after the MIP optimization terminates, for example, when you change the problem type to fixed-integer and re-optimize with a continuous optimizer. Another important difference between pools of user cuts and pools of lazy constraints lies in the timing by which these pools are applied. CPLEX may check user cuts for violation and apply them at any stage of the optimization. Conversely, it does not guarantee to check them at the time an integer-feasible solution candidate has been identified. Lazy constraints are only (and always) checked when an integer-feasible solution candidate has been identified, and of course, any of these constraints that turn out to be violated will then be applied to the full model. Cuts that are based on optimality and that remove integer feasible solutions without removing all optimal solutions are known as optimality-based cuts. Optimality-based cuts do not fit the definition of either a user cut nor a lazy constraint. For example, symmetry-breaking constraints are sometimes known as optimality-based cuts because symmetry-breaking constraints can remove integer feasible solutions without removing all optimal solutions. Symmetry-breaking constraints are not user cuts in the sense addressed here. Symmetry-breaking constraints are not necessarily lazy constraints either. However, CPLEX can support optimality-based cuts as lazy constraints. If you add an optimality-based cut as a lazy constraint in your model, you can also add it to the user cut pool. This practice of adding an optimality-based cut as a lazy constraint and simultaneously adding it to the user cut pool makes sure that CPLEX checks the optimality-based cut at each node relaxation as well as when CPLEX finds an integer feasible solution. Another way of comparing these two types of pools is to note that the user designates constraints as lazy in the strong hope and expectation that they will not need to be applied, thus saving computation time by their absence from the working problem. In practice, it is relatively costly (for a variety of reasons) to apply a lazy constraint after a violation is identified, and so the user should err on the side of caution when deciding whether a constraint should be marked as lazy. In contrast, user cuts may be more liberally added to a model because CPLEX is not obligated to use any of them and can apply its own rules to govern their efficient use. user cut 与约束编程 (Constraint Programming) 中的 surrogate constraints 功能类似: Since constraint propagation decreases the size of the search space by reducing the domains of variables, it is obviously important to express all necessary constraints. In some cases, it is even a good idea to introduce implicit constraints to reduce the size of the search space by supplementary propagation. Processing supplementary constraints inevitably slows down execution. However, this slowing down may be negligible in certain problems when it is compared with the efficiency gained from reducing the size of the search space. A surrogate constraint makes explicit a property that satisfies a solution implicitly. Such a constraint should not change the nature of the solution, but its propagation should delimit the general shape of the solution more quickly. Of course, there is no need to express grossly obvious redundant constraints since the highly optimized algorithms that CP Optimizer uses to insure arc consistency already work well enough. For example, given this system of equations: \\(x = y + z\\) \\(z = a + b\\) no efficiency whatsoever is gained by adding this constraint: \\(x = y + a + b\\) However, in any case where an implicit property makes good sense, or derives from experience, or satisfies formal computations, its explicit implementation as a surrogate constraint can be beneficial. Consider the problem of the magic sequence. Assume that there are n+1 unknowns, namely, \\(x_0, x_1, . . . , x_n\\). These \\(x_i\\) must respect the following constraints: 0 appears \\(x_0\\) times in the solution. 1 appears \\(x_1\\) times. In general, \\(i\\) appears \\(x_i\\) times. \\(n\\) appears \\(x_n\\) times. The constraint of this problem can easily be written, using the specialized distribute constraint. However, the search for a solution can be greatly accelerated by introducing the following surrogate constraint that expresses the fact that \\(n+1\\) numbers are counted. \\(1*x_1 + 2*x_2 + . . . + n*x_n = n+1\\). 列生成 (Column Generation) 如果说 TSP 中经典的子回路消除 (割平面法) 是一种逐步添加惰性约束的 \"行生成\" 算法, 那么其对偶算法就是逐步添加决策变量的 \"列生成\" 算法. 前者适用于原始问题约束非常多, 但是真正对限制最优解的取值发挥作用的重要约束很少的情况; 后者则恰好相反, 适用于决策变量非常多, 但大多数决策变量的子集的取值组合不可能出现在最优解中的情况. 原理 给定主问题及其对偶问题的线性规划模型 \\[ \\begin{align} \\min &amp; &amp; \\mathbf{c}^{T} \\mathbf{x} &amp; &amp; &amp; &amp; \\max &amp; &amp; \\mathbf{y}^{T} \\mathbf{b}\\\\ s.t. &amp; &amp; \\mathbf{A} \\mathbf{x} \\ge \\mathbf{b} &amp; &amp; \\Leftrightarrow &amp; &amp; s.t. &amp; &amp; \\mathbf{y}^{T} \\mathbf{A} \\le \\mathbf{c}^{T}\\\\ &amp; &amp; \\mathbf{x} \\ge \\mathbf{0} &amp; &amp; &amp; &amp; &amp; &amp; \\mathbf{y} \\ge \\mathbf{0} \\end{align} \\] 令 \\(\\mathbf{x}^{T} = [\\mathbf{x}^{T}_{B}, \\mathbf{x}^{T}_{N}]\\), 其中 \\(\\mathbf{x}_{B}\\) 表示基向量, \\(\\mathbf{x}_{N}\\) 表示非基变量. 对应地, \\(\\mathbf{A} = [\\mathbf{B}, \\mathbf{N}]\\), \\(\\mathbf{c} = [\\mathbf{c}_{B}, \\mathbf{c}_{N}]\\). 对约束进行如下等价变换 \\[ \\mathbf{A} \\mathbf{x} \\ge \\mathbf{b} ~~\\Leftrightarrow~~ \\mathbf{B} \\mathbf{x}_{B} + \\mathbf{N} \\mathbf{x}_{N} \\ge \\mathbf{b} ~~\\Leftrightarrow~~ \\mathbf{x}_{B} \\ge \\mathbf{B}^{-1} \\mathbf{b} - \\mathbf{B}^{-1} \\mathbf{N} \\mathbf{x}_{N} \\] 将上式代入目标函数 \\[ \\mathbf{c}^{T} \\mathbf{x} ~~=~~ \\mathbf{c}^{T}_{B} \\mathbf{x}_{B} + \\mathbf{c}^{T}_{N} \\mathbf{x}_{N} ~~\\ge~~ \\mathbf{c}^{T}_{B} (\\mathbf{B}^{-1} \\mathbf{b} - \\mathbf{B}^{-1} \\mathbf{N} \\mathbf{x}_{N}) + \\mathbf{c}^{T}_{N} \\mathbf{x}_{N} ~~=~~ \\mathbf{c}^{T}_{B} \\mathbf{B}^{-1} \\mathbf{b} + (\\mathbf{c}^{T}_{N} - \\mathbf{c}^{T}_{B} \\mathbf{B}^{-1} \\mathbf{N}) \\mathbf{x}_{N} \\] 定义目标函数中非基变量的系数 Reduced Cost 为 \\[ \\mathbf{r} = \\mathbf{c}^{T}_{N} - \\mathbf{c}^{T}_{B} \\mathbf{B}^{-1} \\mathbf{N} \\] 若 \\(\\exist \\mathbf{N}_{i} \\in \\mathbf{N}\\) 满足 \\(\\mathbf{r}_{i} &lt; 0\\), 则可通过增加非基变量 \\(\\mathbf{x}_{i}\\) 的值实现降低目标函数值. 若不存在这样的项, 即 \\(\\forall \\mathbf{N}_{i} \\in \\mathbf{N}, \\mathbf{c}^{T}_{i} - \\mathbf{c}^{T}_{B} \\mathbf{B}^{-1} \\mathbf{N}_{i} \\ge 0\\), 则 \\([\\mathbf{x}_{B}, \\mathbf{0}]\\) 为最优解. 由 Complementary Slackness 定理可知 \\(\\mathbf{y}^{T} = \\mathbf{c}^{T}_{B} \\mathbf{B}^{-1}\\), 由此可得 \\(\\mathbf{r} = \\mathbf{c}^{T}_{N} - \\mathbf{y}^{T} \\mathbf{N}\\). 则寻找可最大程度改进当前解的非基变量的子问题目标函数为 \\(\\min \\mathbf{c}^{T}_{N} - \\mathbf{y}^{T} \\mathbf{N}\\). \\(~~~~\\) (本节内容基于 https://zhuanlan.zhihu.com/p/55424545 整理) 附: Complementary Slackness 定理证明过程 (可能有问题): 令 \\(\\mathbf{y}^{T} = \\mathbf{c}^{T}_{B} \\mathbf{B}^{-1}\\), 对于限制主问题的最优解 \\(\\mathbf{x}\\), 有 \\(\\mathbf{x}_{N} = \\mathbf{0}\\), 以及 \\(\\mathbf{c}^{T}_{B} \\mathbf{B}^{-1} \\mathbf{N} \\le \\mathbf{c}^{T}_{N}\\), 可得 \\[ \\mathbf{y}^{T} \\mathbf{A} ~~=~~ \\mathbf{c}^{T}_{B} \\mathbf{B}^{-1} \\mathbf{A} ~~=~~ \\mathbf{c}^{T}_{B} \\mathbf{B}^{-1} [\\mathbf{B}, \\mathbf{N}] ~~=~~ [\\mathbf{c}^{T}_{B}, \\mathbf{c}^{T}_{B} \\mathbf{B}^{-1} \\mathbf{N}] ~~\\le~~ [\\mathbf{c}^{T}_{B}, \\mathbf{c}^{T}_{N}] ~~=~~ \\mathbf{c}^{T} \\] \\[ \\mathbf{y}^{T} \\mathbf{b} ~~=~~ \\mathbf{c}^{T}_{B} \\mathbf{B}^{-1} \\mathbf{b} ~~=~~ \\mathbf{c}^{T}_{B} \\mathbf{x}_{B} ~~=~~ \\mathbf{c}^{T} \\mathbf{x} \\] 即 \\(\\mathbf{y}^{T}\\) 为限制对偶问题的最优解. 线性分数规划 (Linear-Fractional Programming) 目标函数为分数形式. 可以转换成线性规划.","categories":[{"name":"组合优化","slug":"组合优化","permalink":"http://suzhouxing.github.io/techive/categories/组合优化/"}],"tags":[{"name":"组合优化","slug":"组合优化","permalink":"http://suzhouxing.github.io/techive/tags/组合优化/"},{"name":"优化","slug":"优化","permalink":"http://suzhouxing.github.io/techive/tags/优化/"},{"name":"技术","slug":"技术","permalink":"http://suzhouxing.github.io/techive/tags/技术/"},{"name":"建模","slug":"建模","permalink":"http://suzhouxing.github.io/techive/tags/建模/"},{"name":"数学","slug":"数学","permalink":"http://suzhouxing.github.io/techive/tags/数学/"}]},{"title":"组合优化 (四) 算法工程","slug":"Opt-SoftwareEngineering","date":"2019-01-13T03:14:16.000Z","updated":"2022-02-24T09:34:38.304Z","comments":true,"path":"2019/01/13/Opt-SoftwareEngineering/","link":"","permalink":"http://suzhouxing.github.io/techive/2019/01/13/Opt-SoftwareEngineering/","excerpt":"","text":"算法研发和常规软件开发十分相似, 但也有很多区别. 大多数工程项目往往更注重正确性, 为了提升代码的健壮性与可维护性, 可以适当牺牲性能. 而设计精妙的高效而复杂算法代码往往具有极高的耦合度, 难以进行系统的单元测试. 此外, 算法面临的需求往往不那么简单直接, 不是梳理清楚了业务逻辑就能欢快地敲代码了的. 算法研发真的这么任性吗? 软件工程 文档 需求分析 相关技术调研 自然语言描述 基本概念定义 建模四要素 输入输出数据约定 用户手册 概要设计 接口定义 功能覆盖 算法设计 技术规范 模块划分 处理流程 测试分析 测试环境 测试用例 测试结果 正确性分析 优度分析 速度分析 算例设计 格式要求 自文档 跨平台 推荐格式: protobuf, json 结构和规模可控 拓扑设计 特殊结构: 树形, 窄总线型, 宽总线型, 关键节点, 局部密度高整体密度低, 有向无环图 部分边权重特别大 (出现整数上溢) 算法工程 相关工具 版本控制工具 git (主流) svn mercurial 适合与版本控制工具配合使用的文档撰写工具 Markdown 一种功能非常精简的标记语言 https://guides.github.com/features/mastering-markdown/ LaTeX 功能强大的标记语言 同样适用于科技论文写作 数学规划求解器 -- 完成需求分析即完成项目! Gurobi 目前最高效的求解器 支持免费学术许可证申请 CPLEX IBM旗下的\"行业标准\" SCIP 号称最快的开源求解器 Coin-OR 功能繁多的开源运筹学工具包 开发 代码可读性 使用版本控制减少被注释掉的代码 (文档性注释不受该要求影响) 使用有具体意义的单词作为标识符以减少臃肿的注释 使用自动排版工具调整代码格式 合理的功能模块划分和封装以避免过长的函数 (但是有时真的无法避免) 自动化测试 使用配置文件 方案选择 (使用配置文件将导致代码过于臃肿时可以考虑预处理语句) 参数设置 算例选择 建议使用json文件格式 自动批量测试 计算结果合法性检验 计算结果目标函数值正确性检验 独立重复运行 多个算例 多个配置 多线程 (注意写同一个日志文件时应加入互斥机制) 运行日志 原始日志 能够评价每次运行的时空开销与解的质量 能够还原求解过程和结果 (随机种子, 运行时间, 迭代次数, 宏开关状态, 参数设置...) 建议使用csv文件进行组织 初步加工 多阶段问题整合各阶段的数据得到整个周期的结果 举例 结果分析 初步统计 极值, 均值, 方差, 耗时... ClosedXML编辑xlsx文件 对比分析 在所有算例上的综合评价方案/参数好坏的策略 Excel条件格式, 排序, Excel录制宏 举例 算法工程模块清单 通用 验证程序 合法性 目标函数值计算正确 日志记录 统计分析 求解器 数学模型 编程实现 启发式 初始解 随机 贪心 局部搜索 邻域评估 增量评估 邻域动作目标函数增量缓存 邻域动作优先队列 邻域动作选择 邻域动作执行 禁忌策略 禁忌表 解禁策略 扰动策略","categories":[{"name":"组合优化","slug":"组合优化","permalink":"http://suzhouxing.github.io/techive/categories/组合优化/"}],"tags":[{"name":"组合优化","slug":"组合优化","permalink":"http://suzhouxing.github.io/techive/tags/组合优化/"},{"name":"技术","slug":"技术","permalink":"http://suzhouxing.github.io/techive/tags/技术/"},{"name":"软件工程","slug":"软件工程","permalink":"http://suzhouxing.github.io/techive/tags/软件工程/"}]},{"title":"组合优化 (三) 算法简介","slug":"Opt-AlgorithmDesign","date":"2019-01-13T03:13:02.000Z","updated":"2022-02-24T09:35:11.555Z","comments":true,"path":"2019/01/13/Opt-AlgorithmDesign/","link":"","permalink":"http://suzhouxing.github.io/techive/2019/01/13/Opt-AlgorithmDesign/","excerpt":"","text":"由于生产实践中面临的绝大多数具有实际意义的组合优化问题都已经在理论上被证明属于难以使用可接受的计算资源在可接受的时间内求解的 NP-Hard 问题, 其求解算法不像 P 问题一样存在标准答案. 此外, 在实际的工业应用中, 由于未来的不确定性以及评价指标常常无法完美量化等问题, 耗费大量计算资源和时间精确求出最优解几乎没有实际意义. 所以, 组合优化算法的设计往往是在优度与速度之间寻找平衡点. 算法设计 预处理 (Preprocess) 缩减问题规模 (Reduction) 参考文献: Polynomial-time data reduction for dominating set 加载用户参数与算法默认参数 初始化辅助数据结构 精确算法 (Exact Algorithms) 分支限界 (Branch and Bound) 分支策略 (Branching) 深度优先 (Depth-First Search) 广度优先 (Breadth-First Search) 优度优先 (Best-First Search) 剪枝策略 (Pruning) 可行性剪枝 (Feasibility Pruning) 上下界剪枝 (Bound Pruning) (最小化问题) 当前目标函数值 + 剩余部分下界 &lt; 上界 A* 算法实质上是该策略在特定问题上的一种高效实现 支配性剪枝 (Dominance Pruning) 动态规划实质上是将该策略发挥到了极致 参考文献: On an exact method for the constrained shortest path problem 线性规划与混合整数规划求解算法 (Mathematical Programming) 单纯形法 (Simplex Method) 内点法 (Interior Point Method, Barrier Method) 分支切割/割平面法 (Branch and Cut, Cutting Plane Method) 分支定价/列生成 (Branch and Price, Column Generation) 动态规划 (Dynamic Programming) 递推函数 (Recursive Formulation) 重叠子问题/最优子结构 (Overlapping Subproblem, Optimal Substructure) 其他经典算法 最大流 (Maximum Flow) 最小费用流 (Minimum-Cost Flow) 完美匹配/最大匹配 (Perfect Matching, Maximum Matching, Assignment Problem) 参考文献 http://theory.stanford.edu/~amitp/GameProgramming/ https://www.redblobgames.com/pathfinding/a-star/introduction.html https://www.redblobgames.com/pathfinding/a-star/implementation.html 元启发式算法 (Metaheuristics) 概述 分类 基本思想 在 系统地探索整个解空间 和 盲目地探索邻近的解空间 之间寻找平衡点 集中性 (Intensification) 与 疏散性 (Diversification) 的平衡 也称为 探索 (Exploration) 与 利用 (Exploitation) 的平衡 时空开销 (Complexity) 与 求解质量 (Quality) 的平衡 邻域动作 (Neighborhood Move): 尝试对解向量做微小的改变 在一次迭代中每一个决策变量都可以改变: 精确算法 在一次迭代中仅改变一个决策变量: 原子邻域动作 寻找两者的平衡点: 集中性与疏散性的平衡 迭代禁忌搜索过程 使用贪心算法或随机生成一个初始解 每次从当前解移动到某个邻居解 (Neighboring Solution), 直至一定步数不能改进 然后进行扰动, 贪心或随机地对更改部分解向量, 重复上述过程 元启发式算法框架 算法层为整个程序的框架, 比如迭代局部搜索, 遗传算法, 混合进化算法等. 算法层决定了使用那些搜索策略, 搜索策略之间以什么次序出现, 各搜索策略的初始解, 各搜索策略的停止策略参数控制 (停止条件), 整个算法的停止条件等. 搜索层是具体的搜索算法, 执行一次搜索会产生一条搜索路径 (Trajectory). 随机游走, 模拟退火, 局部搜索, 禁忌搜索等都是搜索层的组件. 从广义上来说, 构造初始解, 迭代局部搜索中的扰动过程, 遗传算法中的交叉算子都是搜索层的组件. 在搜索过程中, 要考虑的主要问题是每次迭代选择什么邻域结构进行探索, 以及决定停止搜索的策略. 比如TS的停止策略是一定步数未改进就停止, 而停止条件是一个特定的最大未改进步数具体取值. 邻域动作选择一般是搜索过程中对算法性能影响最大的模块. 它通过循环调用邻域动作评估层的组件对考虑范围之内的邻域动作对目标函数值的改变情况进行评估, 然后按照某种策略挑选其中的一个动作. 最常见的挑选策略有 首次改进 (First Improvement) 和 最优改进 (Best Improvement). 此外, 还可以有导向性地或者随机地在整个邻域中挑选一部分邻域动作进行评估. 邻域动作评估可以是结合特殊的数据结构进行增量评估或者全部重算. 在绝大多数情况下增量评估的速度会远快于全部重算. 邻域动作的执行比较简单, 主要有更新解向量, 更新辅助数据结构, 更新禁忌表, 更新缓存和更新历史最优解等操作. 其中更新历史最优主要是处理目标函数值相同的情况, 可以随机选择, 也可以设计辅助目标函数进行处理. 邻域动作举例 Boolean Satisfiability Problem (SAT) Graph Coloring Problem P-Center Problem Personnel Scheduling Prblem Traveling Salesman Problem 常用算法 提升算法 (Trajectory-Based Methods) 迭代禁忌搜索 模拟退火 (类似 Epsilon-Greedy 策略) 拍卖算法/地貌调整/格局检测 (Auction Algorithm, Landscape Adjustment, Configuration Checking) 提升反复出现的惩罚项在目标函数中的权重实现 \"软\" 禁忌 例如图着色中令 反复出现的 或者 局部最优解中的 冲突边的计 1.01 条冲突边 种群算法 (Population-Based Methods) 混合进化算法/模因算法 (Hybrid Evolutionary Algorithm, Memetic Algorithm), 遗传算法 (Genetic Algorithm) 蚁群, 蜂群, 粒子群 (与强化学习十分相似) 初始解 (Initial Solution Generation) 贪心 (Greedy) 有利于快速收敛 (Fast Convergence) 不利于初始解的多样性 随机 (Random) 禁忌搜索 (Tabu Search) 邻域结构 (Neighborhood Structure) 设计 原子邻域动作 添加, 删除, 更换, 交换, 移动, ... 复合邻域动作 块交换, 块移动 大邻域搜索 (Large Neighborhood Search) 弹射链 (Ejection Chain) 邻域评估 (Neighborhood Evaluation): 目标函数值改进量计算 增量评估 (Incremental Evaluation): 因为仅对解向量做了微小的改变, 所以目标函数中大多数项目并未改变 邻域缓存 (Cache): 在邻域动作执行后, 大多数邻域动作与被改变的决策变量并不相关, 其增量无需重新计算, 故可以将其缓存起来 主动更新 (Active Update): 每次执行邻域动作后更新所有相关动作的增量 惰性更新 (Lazy Update): 使用标记位记录缓存是否失效, 需要比较相关动作的增量时再更新 启用了邻域精简或抽样策略时才有惰性更新的必要 邻域动作选择策略 单个邻域 (直接选择邻域动作) 首次改进 (First Improvement) 记录上一轮的评估进度直接从下一个动作开始, 循环评估所有动作 每次从随机位置开始依次评估所有邻域动作 最大改进 (Best Improvement) 多个目标函数增量相同的最优动作随机选择一个 在线选择 (Online Selection): 水塘抽样 (Reservoir Sampling) 邻域精简/候选动作集 (Neiborhood Reduction, Candidate Set) 根据特定策略筛选排除显然没有改进潜力的动作 邻域近似评估 (Neihborhood Estimation, Approximate Evaluation) 根据其他辅助指标快速对所有动作排序, 仅对排名靠前的若干动作进行精确评估 邻域抽样 (Neighborhood Sampling) 多邻域 (先选出邻域结构再选择动作) 评估所有邻域的所有动作 可以结合邻域抽样随机挑选部分动作 变邻域搜索 (Variable Neighborhood Search) 根据适应性选择最合适的邻域 根据历史改进情况调整各邻域权重, 然后采用轮盘赌 (Roulette Wheel) 选择其中一个 等概率随机选择 优先队列优化: 避免遍历整个邻域, 直接在 O(1) 时间内挑选最优动作 一般使用桶队列 (Bucket Queue) 等基于基数排序 (Radix Sort) 的优先队列实现 (而非基于比较的树状优先队列) 往往与邻域缓存结合使用, 实现惰性更新优先队列中的键值对 禁忌策略 禁忌表 如果一个邻域动作被执行则禁止其逆操作在短时间内被选中 刚增加则禁止马上被删除 刚交换防止马上被换回来 禁忌步长 (Tabu Tenure) 可能与问题规模, 禁忌表大小, 目标函数值, 邻域动作出现次数相关 一般需要加上随机成分 具体实现时将禁忌多久转换为什么时候解禁 解禁策略/特赦准则 (Aspiration Criteria) 如果被禁忌的邻域动作是当前邻域的最优动作且能够改进历史最优解则允许其被执行 扰动 (Perturbation) 重新构造初始解 (Random Restart) 需要初始解生成程序具有一定的随机性 与之前的搜索完全无关, 无法利用已有的搜索结果 贪心或随机地更改解向量中的部分元素 随机执行邻域动作 (Random Walk) 交叉算符 (Crossover Operator) 将多个解向量中较优的子结构进行组合 图着色禁忌搜索算法总结 重新统计每个邻域动作的改进量代价太大 改变一个节点的颜色在稀疏图上对整体格局影响很小 =&gt; 记录个节点各种颜色的相邻节点的数量 (即变成各种颜色引入的冲突数量) 使用新颜色相邻节点数减去旧颜色相邻节点数快速计算改进量 每次遍历所有动作中挑选最优动作代价太大 大多数动作显然不可能产生改进 =&gt; 仅评估有冲突的节点 使用优先队列每次直接取出最优动作 非禁忌优先队列 + 禁忌优先队列 + 待解禁循环队列 使用相邻颜色表校验出队动作实现惰性更新优先队列 混合整数规划 (Mixed-Integer Programming) 概述 对于一组给定的自变量, 确定其取值, 使其在满足给定不等式组的前提下, 给定的函数取到最小值 决策变量的定义域可以是实数 (连续变量) 也可以是整数 (离散变量) 编程范式与原理简介 http://www.gurobi.com/resources/getting-started/lp-basics http://www.gurobi.com/resources/getting-started/mip-basics 不同的表现形式 线形规划模型的标准形式 图形表示 矩阵表示 使用方法 使用专门的建模语言 https://www.gurobi.com/documentation/6.5/refman/model_file_formats.html 举例: coin &amp; qafiro 使用命令行接口 使用应用程序接口 添加决策变量 添加目标函数 添加约束 求解 获取决策变量取值 贪心算法与近似算法 (Approximate Algorithm) 贪心算法可视为不回溯的优度优先搜索 近似算法是一类特殊的贪心算法 近似比 (Approximation Ratio): 最坏情况下贪心解离最优解的差距 算法运行模式对比 树搜索 动态规划 局部搜索 树搜索与局部搜索 局部搜索虽然名字里有 \"局部\", 但是从某种意义上来说反而很全局——可以对解向量的任意位置进行修改. 以最小化问题为例, 局部搜索关注上界, 是真实可行的解的目标函数值, 更适合实际应用. 树搜索关注下界, 是理论上最优的解的目标函数值, 更适合理论分析. 更宏观的算法设计 简化问题模型, 将其转换为可高效 (精确) 求解的经典问题, 获得较好格局后再修复细节. 固定部分决策. 类比: 导师提出求解思路, 学生只需顺着思路实现, 比自己从头设计算法更容易出成果. 松弛部分约束. 类比: 两个城市之间的通勤时间与直线距离除以交通工具的速度差别不大. 忽略部分目标函数成份. 类比: 地表附近计算重力无需考虑万有引力甚至相对论效应.","categories":[{"name":"组合优化","slug":"组合优化","permalink":"http://suzhouxing.github.io/techive/categories/组合优化/"}],"tags":[{"name":"组合优化","slug":"组合优化","permalink":"http://suzhouxing.github.io/techive/tags/组合优化/"},{"name":"优化","slug":"优化","permalink":"http://suzhouxing.github.io/techive/tags/优化/"},{"name":"技术","slug":"技术","permalink":"http://suzhouxing.github.io/techive/tags/技术/"},{"name":"建模","slug":"建模","permalink":"http://suzhouxing.github.io/techive/tags/建模/"},{"name":"数学","slug":"数学","permalink":"http://suzhouxing.github.io/techive/tags/数学/"}]},{"title":"组合优化 (二) 数学建模基础","slug":"Opt-MathematicalProgramming","date":"2019-01-13T03:10:16.000Z","updated":"2022-02-24T09:34:53.334Z","comments":true,"path":"2019/01/13/Opt-MathematicalProgramming/","link":"","permalink":"http://suzhouxing.github.io/techive/2019/01/13/Opt-MathematicalProgramming/","excerpt":"","text":"面对一个复杂的组合优化问题, 把它描述清楚本身就不是一个简单的问题. 常规开发往往允许模棱两可的描述, 需求修修补补虽然很烦, 但往往只是工作量的问题. 而算法研发由于其专用性, 细微的需求变化可能导致一个算法完全失效, 除非重新设计整个框架不然无法解决新的问题. 所以, 严谨的需求分析或问题描述对于算法研发格外重要. 对于一个组合优化问题, 我们一般使用数学规划的形式化语言对其进行无二义性的定义, 作为算法工程中的需求分析文档. 需求分析 为什么要做需求分析 研究一个课题的目的: 实现一个好的系统 什么样的系统是好系统: 按事先制定的标准进行评价 标准从哪里来: 需求分析 如何评价一个系统的好坏 任务完成质量 (又快又好) 完成速度 完成效果 建设成本 运营成本 安全性 不受外部因素干扰 从错误中恢复 稳定性 (今天好, 明天也好; 这组数据好, 那组也好) 代码逻辑正确性 算法对各种场景的兼容性 静态多样性 动态随机性 简化问题 优度和速度的平衡不仅可以在问题求解的过程中, 还可以在问题定义时 简化问题会影响结果的正确性和优度 举例 宏观低速时使用经典力学而不是相对论 同时处理多个业务简化为分多次每次处理一个业务 减小负载和提升安全性转换为不重复经过节点 组合优化问题的需求分析 按形式化描述语言分类 数学规划 (Mathematical Programming) 线性规划 (Linear Programming) 混合整数规划 (Mixed-Integer Programming) QP, QCP, SOCP, LFP 约束编程 (Constraint Programming) 布尔表达式可满足性问题 (Boolean Satisfiability Problem) SAT Encoding MAX-SAT Encoding 规约 (Reduction) Karp's 21 NP-complete problems 动态规划 按应用场景分类 静态模型 随机规划 (Stochastic Programming) 鲁棒优化 (Robust Optimization) 线性规划与混合整数规划 思维方式 已知 约束和目标中的系数 决策 确定哪些可控因素需要做决策 定义域 布尔 / 整数 / 实数 上界 / 下界 从最根本的需求开始 显示决策 (根本需求) 隐式决策 (客户不关心但十分重要) 辅助决策 (将非线性约束转化为线性约束) 不够用再返回来补充 思考问题的角度影响决策变量的设置 图着色问题 每个节点染什么颜色 每种颜色的节点集合包含了哪些节点 每两个节点是否染了相同的颜色 旅行销售员问题 每个节点的第几个被访问 第几个被访问的节点是哪个节点 路径包含哪些边 布尔表达式可满足性问题 保证每个布尔变量在所有子句中取值一致，最大化为真的子句数量 保证每个子句均为真，最大化布尔变量的一致性 约束 决策变量组成的表达式满足的关系 等式或不等式 \\(f(x) ? g(x)\\) 下标的取值范围 \\(\\forall i \\in V\\) 可以和目标对调顺序, 谁简单先考虑谁 如何验证约束是否完备? 经验? 详尽的测试? ... 目标 不同决策变量取值组合产生的后果的优劣度量 冗余约束 (Redundant Constraints) 图着色问题的对称性消除 (Symmetric Breaking) 参考文献: A cutting plane algorithm for graph coloring 优化版本 O1 一个颜色至少被一个节点使用时才会被选中 \\[ y_{c} \\le \\sum_{n \\in N} x_{nc}, \\quad \\forall c \\in C \\] O2 编号更小的颜色未被选中时禁止选中编号更大的颜色 \\[ y_{c&#39;} \\ge y_{c}, \\quad \\forall c, c&#39; \\in C, c&#39; = c - 1 \\] 判定版本 D1 使用编号更小的颜色的节点数不小于使用编号更大的颜色的节点数 (使用某种颜色的节点数随颜色编号的增长单调变化) \\[ \\sum_{n \\in N} x_{nc&#39;} \\ge \\sum_{n \\in N} x_{nc}, \\quad \\forall c, c&#39; \\in C, c&#39; = c - 1 \\] D1 包含 O2 D2 节点不允许使用比其编号更大的颜色 \\[ x_{nc} = 0, \\quad \\forall n \\in N, c \\in C, n &lt; c \\] D3 编号更小的颜色未被编号更小的节点使用时禁止使用编号更大的颜色 (使用某种颜色的节点集中最小的节点编号随颜色编号的增长单调变化) \\[ \\sum_{n&#39; \\in [0, n)} x_{n&#39;c&#39;} \\ge x_{nc}, \\quad \\forall n \\in N, \\forall c, c&#39; \\in C, c&#39; = c - 1 \\] 与 D2 配合使用时, 将固定为 0 的项代入可化简为 \\[ \\sum_{n&#39; \\in [c&#39;, n)} x_{n&#39;c&#39;} \\ge x_{nc}, \\quad \\forall n \\in N, \\forall c, c&#39; \\in C, c&#39; = c - 1, n \\ge c \\] D3 与 D1 冲突 编程实现 求解器选择 Gurobi 目前最高效的线性规划/混合整数规划求解器 支持免费学术许可证申请 CPLEX IBM旗下的 \"行业标准\" SCIP 号称最快的开源求解器 COIN-OR 功能繁多的开源运筹学工具包 OR-Tools 开源经典组合优化算法库 提供统一的接口调用各大常见求解器 接口选择 编程语言接口 开发中最常用的接口 提供更高层次的抽象 更快的模型构建速度 C / C++ / Java / C# / Python / Matlab / R 模型文件接口 需要自己将模型展开为线性规划的标准型 文件 I/O 速度较慢 交互式命令行接口 (Gurobi) 类似于解释型的脚本语言 OPLIDE (CPLEX) 介于命令式语言与建模语言之间 Excel 插件 ... 使用编程语言接口的求解过程 (Gurobi) 参考自带的示例工程 diet, facility, mip1. 基本流程如下. 初始化环境 GRBEnv() 许可证检测 其他全局参数与数据初始化 初始化模型 GRBModel() 添加决策变量 GRBModel::addVar() 按照一定规律组织决策变量 使用额外的数据结构将决策变量与用户变量绑定 更新模型 GRBModel::update() 惰性更新提升效率 (最新版已无需手动调用该函数) CPLEX 不需要此步骤 设置目标 GRBModel::setObjective() 添加约束 GRBModel::addConstr() 设置其他参数 GRBModel::set(), GRBEnv::set() 运行时间 输出日志 求解 GRBModel::optimize() 检查求解状态 GRBModel::get(GRB_IntAttr_Status) 获取目标函数值 GRBModel::get(GRB_DoubleAttr_ObjVal) 获取解向量 GRBVar::get() 使用模型文件接口的求解过程 (Gurobi) 参考自带的示例工程 lp. 基本流程如下. 准备好 .mps 或 .lp 等模型文件 GRBModel::write() 一般由另外的程序输出 读取模型文件 GRBModel(), GRBModel::read() 求解并输出","categories":[{"name":"组合优化","slug":"组合优化","permalink":"http://suzhouxing.github.io/techive/categories/组合优化/"}],"tags":[{"name":"组合优化","slug":"组合优化","permalink":"http://suzhouxing.github.io/techive/tags/组合优化/"},{"name":"优化","slug":"优化","permalink":"http://suzhouxing.github.io/techive/tags/优化/"},{"name":"技术","slug":"技术","permalink":"http://suzhouxing.github.io/techive/tags/技术/"},{"name":"建模","slug":"建模","permalink":"http://suzhouxing.github.io/techive/tags/建模/"},{"name":"数学","slug":"数学","permalink":"http://suzhouxing.github.io/techive/tags/数学/"}]},{"title":"组合优化 (一) 简介","slug":"Opt-CombinatorialOptimization","date":"2019-01-13T03:07:22.000Z","updated":"2022-02-24T09:34:22.921Z","comments":true,"path":"2019/01/13/Opt-CombinatorialOptimization/","link":"","permalink":"http://suzhouxing.github.io/techive/2019/01/13/Opt-CombinatorialOptimization/","excerpt":"","text":"组合优化也叫离散优化, 是运筹优化的重要组成部分, 其中 \"组合\" 是排列组合的组合. 从字面上理解这个名词, 组合优化是要从呈组合数复杂度爆炸式增长的解空间中, 寻找最优的解向量, 即制定最优决策方案. 组合优化问题涉及了分配, 调度, 指挥, 路由等众多类型的问题. 作为人工智能的重要分支, 组合优化与时下大热的统计学习存在着千丝万缕的联系. 统计学习更侧重于预测和单步决策, 比如预测出了某件商品的销量, 就可以知道需要进多少货; 预测出了某个区域的人流量, 就可以知道需要分配多少保安巡逻; 检测出患者有某种疾病, 就可以知道要开什么药. 相比之下, 组合优化更注重涉及多方的, 全局的, 系统性的序列决策. 与此同时, 部分统计学习种的模型训练算法与求解组合优化问题的方法往往有异曲同工之妙, 因为离散优化与连续优化在思想上有很多相通之处. 组合优化基础 组合优化包含哪些问题 路由问题: 用开销最小的路径覆盖所有目的地 车辆路由 数据流量路由 指派问题: 在有限的时间和空间中合理使用软硬件资源创造更多的收益 时间指派 先后序调度 单机作业调度 车间流水线调度 时间槽分配 航班与列车时刻表 人员排班表 选修课表 空间指派 哪个背包装哪些物品: 背包问题 哪个处理器处理作业: 多机作业调度 哪个中心服务哪些客户: 中心选址 ... NP 完全 (NP-Complete) 问题可以在多项式时间内相互规约 如何定义一个问题 基本要素 已知: 输入数据 决策: 输出结果 约束: 输出结果可行还是不可行 目标: 输出结果好还是坏 观察问题的不同角度举例 图着色问题 每个节点染什么颜色 每种颜色的节点集合包含了哪些节点 布尔表达式可满足性问题 保证每个布尔变量在所有子句中取值一致, 最大化为真的子句数量 保证每个子句均为真, 最大化布尔变量的一致性 基本求解方法分类 贪心算法: 在保证求解速度的前提下提升优度 部分可以保证最优性的贪心算法往往也可以归类为动态规划 (例如 Dijkstra 最短路算法) 近似算法: 离最优解的差距有保障的贪心算法 精确算法: 在确保最优性的前提下降低复杂度 深度/广度/优度优先树搜索 动态规划 混合整数规划的求解算法 启发式算法: 在优度和复杂度之间寻找平衡点 基于邻域动作: 元启发式算法 单个解 (Trajectory): 局部搜索 多个解 (Population): 种群算法 基于树搜索 A* 启发函数可接受 (Admissible) 时为精确算法 向前看树搜索 (Lookahead Tree Search) 线搜索 (Beam Search) 蒙特卡洛树搜索 (Monte-Carlo Tree Search) 问题归约与转换 经典问题到现实问题 图着色 寄存器分配 寄存器 =&gt; 颜色 变量 =&gt; 节点 两个变量生命周期有交集 =&gt; 不能使用同一个寄存器 =&gt; 不能染同一种颜色 =&gt; 两个节点间有一条边 多业务波长分配 波长 =&gt; 颜色 路径 =&gt; 节点 两条路径有交集 =&gt; 不能使用同一个波长 =&gt; 不能染同一种颜色 =&gt; 两个节点间有一条边 停机位分配 停机位 =&gt; 颜色 飞机 =&gt; 节点 两架飞机过站时间有交集 =&gt; 不能停在同一停机位 =&gt; 不能染同一种颜色 =&gt; 两个节点间有一条边 宿舍分配 宿舍 =&gt; 颜色 学生 =&gt; 节点 两个学生作息规律差异很大 =&gt; 不能住同一间宿舍 =&gt; 不能然同一种颜色 =&gt; 两个节点间有一条边 旅行销售员 快递与外卖配送 物资采购 人类基因组计划 经典问题相互转换 独立集 &lt;=&gt; 最大团 &lt;=&gt; 顶点覆盖 =&gt; 支配集 &lt;=&gt; 集合覆盖 &lt;= 中心选址 . 非对称旅行商 &lt;=&gt; 对称旅行商 . 必经点最短简单路 =&gt; 非对称旅行商 &lt;=&gt; 最短简单路 &lt;=&gt; 最长简单路 必经点最短路 =&gt; 非对称旅行商 基本思路 增加一条无代价的旁路让所有非必经点能够通过该旁路被访问 从起点出发, 经过最短路上的实际节点序列, 到达终点, 到达旁路起点, 通过旁路依次经过不在最短路上的实际节点 具体实现 假设起点为 \\(s\\), 终点为 \\(t\\), 共有 \\(k\\) 个非必经节点 \\(n_{1}, n_{2}, ..., n_{k}\\) 增加 \\(k + 1\\) 个虚拟节点 \\(v_{0}, v_{1}, ..., v_{k}\\) 增加以下有向边 \\(t \\rightarrow v_{k}\\) \\(v_{i} \\rightarrow v_{i-1}, \\quad \\forall i \\in [1, k]\\) \\(v_{i} \\rightarrow n_{i}, \\quad \\forall i \\in [1, k]\\) \\(n_{i} \\rightarrow v_{i-1}, \\quad \\forall i \\in [1, k]\\) \\(v_{0} \\rightarrow s\\) 上述有向边应满足 \\(cost(v_{i} \\rightarrow v_{i-1}) = cost(v_{i} \\rightarrow n_{i}) + cost(n_{i} \\rightarrow v_{i-1})\\) \\(cost(t \\rightarrow v_{k}) = cost(v_{0} \\rightarrow s) = 0\\) 经典问题分解 图着色 = 集合覆盖 + 独立集 .","categories":[{"name":"组合优化","slug":"组合优化","permalink":"http://suzhouxing.github.io/techive/categories/组合优化/"}],"tags":[{"name":"组合优化","slug":"组合优化","permalink":"http://suzhouxing.github.io/techive/tags/组合优化/"},{"name":"优化","slug":"优化","permalink":"http://suzhouxing.github.io/techive/tags/优化/"},{"name":"技术","slug":"技术","permalink":"http://suzhouxing.github.io/techive/tags/技术/"},{"name":"建模","slug":"建模","permalink":"http://suzhouxing.github.io/techive/tags/建模/"},{"name":"数学","slug":"数学","permalink":"http://suzhouxing.github.io/techive/tags/数学/"}]},{"title":"理想的编程测试","slug":"IdealCodingTest","date":"2018-06-09T02:41:02.000Z","updated":"2018-07-01T03:11:17.815Z","comments":true,"path":"2018/06/09/IdealCodingTest/","link":"","permalink":"http://suzhouxing.github.io/techive/2018/06/09/IdealCodingTest/","excerpt":"","text":"以下观点仅针对博士招聘或者高级职位的招聘, 如果只是想招个码农一丝不苟地完成编码任务, 可以忽略此文... 最近参加某公司的博士特招, 收到了的一封邮件说让我做个编程测试. 与普通校招不同, 这封邮件并没有让我去 OJ 平台做题, 而是直接在邮件正文中给了 3 道题让我几天内做完并回复邮件. 这种新颖的形式让我眼前一亮, 虽然最后招聘人员的回复让我发现我想多了, 但是还是想分享一下自己的思考. 这种编程测试有以下几个特点: 问题描述模糊 有常规求解方法 (有可能在 ACM 比赛中短时间内实现) 有高级求解方法 线下完成且时间宽裕 这种开放性的命题其实可以考察很多内容. 首先, 因为问题描述存在不严谨的地方, 沟通会非常重要, 换句话说, 这是一种需求分析的意识和能力. 其次, 因为没有限制输入输出数据格式, 需要自己定义接口, 自己确定代码框架. 写出来的代码要足够模块化以适应需求的变更, 包括问题定义的改变和性能要求的提升, 同时接口定义合理方便在其他地方复用. 然后, 没有给定输入输出数据格式肯定更不会给测试用例, 需要自己编写测试用例并且有测试相关的代码, 同时也是使用接口的示例代码. 最后, 编码风格也是可以需要注意的因素之一, 比如命名统一规范且足够自文档, 对功能复杂的模块有适当的注释等等. 举个例子, 这样一道题目 \"对一个字符串进行词频统计, 按词频降序排序输出 (word, count)\", 你在 OJ 上刷题时会怎么做? 在工作中遇到会怎么做? 这个问题其实给得非常模糊, 如果是我至少会想到以下几个问题: 字符串长度是否超过内存容量限制? 文件是否只包含 ASCII 码且按照拉丁语系的书写习惯组织词法语法? 文件是否包含空白字符以外的非字母字符 (如数字和标点)? 如果包含, 是否仍然严格以空白字符为分隔符分词? 单词是否区分大小写? 不同单词数量规模有多大? 是否可能超出 int 最大范围? 每个单词的出现频率是否超出 int 最大范围? 两个单词词频相同怎么办? 对于最复杂的情况, 比如需要做中文分词, 外部排序, 甚至分布式处理, 可能需要用到各种开源库, 代码量甚至可以达到成千上万行... 也许你会说, 理想很丰满现实很骨感. 上面这些好处大家都懂, 但是只要你是一种考核, 就会有针对性的应试技巧. 在线编程测试时间那么短, 可以在一定程度上杜绝抄袭, 但是弄成离线的测试放宽时间限制, 根本不理解算法的人也可以复制粘贴搞出一份代码提交. 首先能敲出代码的人不一定自己真的理解了算法, 甚至觉得自己理解了算法的人也不一定是真的理解了, 很多人对算法的理解并没有达到能证明其正确性和最优性的地步. 其次这种测试考察的是各方面的综合能力, 而不是某个具体问题的解法. 靠死记硬背做出一道题, 换个问题可能就不会做了 (当然, 我们必须承认反复训练可以提升设计算法的感觉). 但是遇到问题先仔细分析需求, 然后从可复用性和可扩展性考虑规划代码架构, 最后进行系统的测试的能力, 是可以在每个项目中发挥作用的. 至于同时参加编程测试的人互相抄袭的问题, 现在应该已经有自动代码查重的工具了. 而且题库丰富起来之后, 给可能相互认识的求职者 (比如同一个研究所) 分发不同的题目即可. 当然, 这种模式也有缺点, 就是在现有技术水平下只能人工判卷, 且评判结果主观性太强, 无法适应大规模的招聘.","categories":[{"name":"技术","slug":"技术","permalink":"http://suzhouxing.github.io/techive/categories/技术/"}],"tags":[{"name":"技术","slug":"技术","permalink":"http://suzhouxing.github.io/techive/tags/技术/"},{"name":"编程","slug":"编程","permalink":"http://suzhouxing.github.io/techive/tags/编程/"},{"name":"招聘","slug":"招聘","permalink":"http://suzhouxing.github.io/techive/tags/招聘/"},{"name":"求职","slug":"求职","permalink":"http://suzhouxing.github.io/techive/tags/求职/"}]},{"title":"数据库中的搜索, 组合优化问题的搜索, 统一建模语言与通用求解器","slug":"SearchingInDatabaseOrOptimization","date":"2018-06-07T02:50:41.000Z","updated":"2021-09-04T06:46:28.971Z","comments":true,"path":"2018/06/07/SearchingInDatabaseOrOptimization/","link":"","permalink":"http://suzhouxing.github.io/techive/2018/06/07/SearchingInDatabaseOrOptimization/","excerpt":"","text":"最近遇到了一个小问题, 大致是已知一块玻璃上有些瑕疵, 如何切割出一块给定大小的矩形区域, 让它的位置尽量靠近左下角, 但是不与任何瑕疵重合. 虽然原始问题要求的是不与任何瑕疵重合, 但是对于一个给定的格局, 比如已知一些瑕疵会同时被覆盖, 有些瑕疵显然是不需要考虑的, 我们称其为 \"被支配\" 的瑕疵. 所以其实我们只需要避开没有 \"被支配\" 的瑕疵, 如下图中红色的点, 而绿色的点显然是不需要考虑的. 矩形装配 这个问题给我的第一反应是它和多目标优化的一种实现方式很像, 即帕累托最优性 (Pareto Optimality). 对于在帕累托前沿 (Pareto Frontier) 上的点, 找不到这样一个点, 在各个维度 (目标) 上都比他们数值更大 (目标函数值更优). 反之, 通俗地说, 就是存在一个点在各个维度上都能碾压某个不在 Pareto Frontier 上的点. 在搜索引擎里搜了下, 想找找有没有高效的求解方案, 找到了下面几个网页: https://en.wikipedia.org/wiki/Pareto_efficiency#Computation https://en.wikipedia.org/wiki/Multi-objective_optimization https://en.wikipedia.org/wiki/Skyline_operator 其中令人惊讶的是, 这个问题居然跟数据库有关, 甚至 SQL 里面还有个专门的算子用来实现这个功能! 突然想起前段时间一位在国内某 500 强企业数据库部门的师叔来实验室交流时, 对通用求解器的讨论. 数据库和组合优化都是在一个有限的解空间内搜索满足条件的数据. 而数据库有个很大的优点, 就是有一个统一的描述语言, SQL, 来定义一切对数据的查询和修改操作. 在多年的不断改进和优化之下, 使用数据管理系统已经能比绝大多数人自行编写代码完成数据管理更加高效了. 但是对于组合优化问题, 无论是学术界还是工业界, 都还在以手工打造为主的阶段. 以 Gurobi 和 CPLEX 为首的基于线性规划的通用求解器存在各种各样的限制, 比如只支持混合整数规划和特殊形式的二次规划, 而且求解速度往往慢于针对性的启发式算法或精确算法. 其他的基于约束编程 (Constraint Programming) 的求解器, 或者基于启发式的 LocalSolver 等求解器提供了更丰富而强大的建模语言, 但表达能力仍然有限, 且求解效果尚不如 Gurobi. 更进一步, 将问题编码成布尔表达式可满足性问题 (SAT 或 MAX-SAT) 也是一个很有意思的方案, 但是如果说前两种得到了广泛应用的方案是用 C++ 编程, 这个方案简直就是在用汇编甚至设计电路. 这样看来, 打造一个更加通用更加高效的求解器似乎是一个很有吸引力的研究方向. 然而, 即使在 \"大数据\" 时代, PB 甚至 EB 级的数据量仍然是十分有限的, 跟几乎无穷无尽的组合优化问题的解空间相比, 实在是太渺小了. 简单机械地将问题拆分成多个子问题逐层求解的方式听起来前途十分渺茫. 因此, 要实现这个设想的难度也是十分巨大的. 附: 开篇问题的严谨定义 令 A(d) 表示矩形区域的左侧边缘与瑕疵 d 的右侧边缘存在重合的部分; B(d) 表示矩形区域的下侧边缘与瑕疵 d 的上侧边缘存在重合的部分; C(x) 和 C(y) 分别表示矩形区域的下侧边缘和左侧边缘与 x 轴和 y 轴重合. 其中边缘均为不包括矩形区域顶点的线段. 则矩形区域的放置位置需要满足以下约束: 存在 d != d', 使 (A(d) &amp;&amp; C(x)) || (B(d) &amp;&amp; C(y) || (A(d) &amp;&amp; B(d')) 为真, 同时矩形区域内不存在任何瑕疵. 求矩形区域所有可能的放置位置.","categories":[{"name":"技术","slug":"技术","permalink":"http://suzhouxing.github.io/techive/categories/技术/"}],"tags":[{"name":"运筹优化","slug":"运筹优化","permalink":"http://suzhouxing.github.io/techive/tags/运筹优化/"},{"name":"技术","slug":"技术","permalink":"http://suzhouxing.github.io/techive/tags/技术/"},{"name":"建模","slug":"建模","permalink":"http://suzhouxing.github.io/techive/tags/建模/"},{"name":"通用求解器","slug":"通用求解器","permalink":"http://suzhouxing.github.io/techive/tags/通用求解器/"},{"name":"数据库","slug":"数据库","permalink":"http://suzhouxing.github.io/techive/tags/数据库/"},{"name":"多目标","slug":"多目标","permalink":"http://suzhouxing.github.io/techive/tags/多目标/"}]},{"title":"组合优化问题的数学建模资料整理","slug":"ModelingInCombinatorialOptimization","date":"2018-04-01T02:31:21.000Z","updated":"2018-07-01T03:11:17.816Z","comments":true,"path":"2018/04/01/ModelingInCombinatorialOptimization/","link":"","permalink":"http://suzhouxing.github.io/techive/2018/04/01/ModelingInCombinatorialOptimization/","excerpt":"","text":"给实验室的新生和实习生培训用的资料. 组合优化问题的数学建模.pptx 线性化非线性表达式.pdf","categories":[{"name":"技术","slug":"技术","permalink":"http://suzhouxing.github.io/techive/categories/技术/"}],"tags":[{"name":"优化","slug":"优化","permalink":"http://suzhouxing.github.io/techive/tags/优化/"},{"name":"技术","slug":"技术","permalink":"http://suzhouxing.github.io/techive/tags/技术/"},{"name":"建模","slug":"建模","permalink":"http://suzhouxing.github.io/techive/tags/建模/"},{"name":"数学","slug":"数学","permalink":"http://suzhouxing.github.io/techive/tags/数学/"}]},{"title":"欧美的优化算法公司在中国的水土不服","slug":"DifferentWayOfThinking","date":"2018-01-31T13:45:46.000Z","updated":"2021-09-16T05:40:29.993Z","comments":true,"path":"2018/01/31/DifferentWayOfThinking/","link":"","permalink":"http://suzhouxing.github.io/techive/2018/01/31/DifferentWayOfThinking/","excerpt":"","text":"最近做项目的过程中发现, 甲方使用的系统里据说调用了 Quintiq 的优化算法, 但是甲方表示这个算法求出来的结果完全不能用, 于是这个功能长期处于闲置状态. 突然想起之前听说中石油中石化都买了 Aspen 的系统, 但是成品油配送基本上也没用系统自带的算法, 还是在由调度员人工调度. 此外, 还听说上海交大的某教授二十年前刚从国外回来的时候, 去找东航说要帮他们做航线规划的算法, 结果东航说就那么点飞机, 人调度就够了, 不需要什么算法. 如果上面的几个故事是普遍现象的话, 那么欧美工业界的成功案例在国内确实是水土不服. 但是受限于个人眼界的狭窄, 以及获取信息的渠道有限, 上面的见闻既不可靠, 也不能反映整体情况. 工业界到底有怎样的内幕是不得而知了, 不过也许从学术界的研究中可以看出些端倪. 下面将以几个经典的问题为例, 对比一下学术论文中研究的问题和在国内遇到的实际情况. 停机位分配 机位初始分配 欧美一般是在近机位上下客, 如果过站时间较长可能会中途把飞机拖到远机位起飞前又拖回近机位 国内一般是不调整停机位, 近机位停满了就停到远机位, 用摆渡车把乘客拉到远机位登机 发生延误时的机位调整 欧美一般不变更停机位, 后继航班在空中或滑行道上等待 国内一般是直接将后继航班分配至同区域的近机位或远机位, 并通知乘客变更登机门 国内似乎是人跟着飞机跑, 而欧美似乎是飞机围着人转. 当然, 欧美也是个很大的概念, 包含了太多国家和地区, 不能一概而论. 而且论文作者也不见得和机场有深入的沟通, 研究的问题也许只是假想的应用场景. 排课表 选修课 欧美一般是学生先根据自己的兴趣选课, 由选课系统来确定课程的时间地点以最小化学生不同课程之间的时间冲突 国内一般是选课系统提前把每门课的时间地点确定好, 由学生选择想上哪些课程时自行解决时间冲突 必修课 欧美一般是根据课时需求统一规划上课时间和教室分配 国内一般是先排好校级公共课时间, 然后各学院分别确定专业课时间, 最后汇总协调教室分配 在选修课方面, 国内是非常具有中国特色的超大规模人肉并行计算, 而欧美则相对自由一点 (当然, 每个课堂还是有的容量限制, 不可能完全做到根据兴趣选课). 而必修课方面, 国内采用的是分而治之的方案, 后期需要花费较多精力在各学院之间协调, 而欧美直接从全局的角度考虑, 对算法性能要求很高. 护士排班 欧美一般是提前提出上班时间的偏好, 然后排班系统在考虑特殊需求的情况下均衡总工作量和工作强度等指标 国内一般是按照简单的规则排出很规整的排班表, 如果有特殊情况需要调整上班时间自行跟其他人协商调班 国内的医护人员往往十分紧缺, 相对来说都是全职全能型的, 不像欧美有那么多余地可以选择不同的合同. 正因为大家的职能差别不大, 所以复杂的排班算法确实没有用武之地, 调度来调度去并没有太大差别. 而有特殊情况时私下跟他人协商临时调班也是一种人肉并行计算, 既然统一规划众口难调, 那就大家各管各饱.","categories":[{"name":"技术","slug":"技术","permalink":"http://suzhouxing.github.io/techive/categories/技术/"}],"tags":[{"name":"运筹优化","slug":"运筹优化","permalink":"http://suzhouxing.github.io/techive/tags/运筹优化/"},{"name":"技术","slug":"技术","permalink":"http://suzhouxing.github.io/techive/tags/技术/"},{"name":"建模","slug":"建模","permalink":"http://suzhouxing.github.io/techive/tags/建模/"},{"name":"需求分析","slug":"需求分析","permalink":"http://suzhouxing.github.io/techive/tags/需求分析/"}]},{"title":"二分法与黄金分割法的区别","slug":"IntervalEliminationMethod","date":"2018-01-14T01:19:00.000Z","updated":"2018-07-01T03:11:17.815Z","comments":true,"path":"2018/01/14/IntervalEliminationMethod/","link":"","permalink":"http://suzhouxing.github.io/techive/2018/01/14/IntervalEliminationMethod/","excerpt":"","text":"高中数学选修课学过区间消去法, 用于求解简单的单变量无约束的优化问题. 其中的典型有二分法和黄金分割法 (0.618法), 后来还知道黄金分割法其实是斐波那契法的简化. 而很多人似乎并不清楚这两种方法的区别和适用场景. 读研之后一直在做运筹学相关的问题, 遇到的优化问题都是上百万维的多约束多目标的组合优化问题. 偶然间遇到了一个简单的一维的情况, 突然来了一种莫名的自信觉得自己可以比当时的高中数学老师讲得更清楚... 二分法主要用于寻找阶跃函数的突变点. 阶跃函数 例如二分查找, 定义比待查找元素小的元素目标函数值为 0, 比待查找元素大的元素目标函数值为 1, 则待查找元素为目标函数的突变点. 黄金分割法和斐波那契法用于寻找单峰函数的极值点. 单峰函数 例如确定药物的最佳剂量, 定义治疗效果和副作用为目标函数, 则用量比最佳剂量大或者小时综合效果都更差.","categories":[{"name":"数学","slug":"数学","permalink":"http://suzhouxing.github.io/techive/categories/数学/"}],"tags":[{"name":"优化","slug":"优化","permalink":"http://suzhouxing.github.io/techive/tags/优化/"},{"name":"数学","slug":"数学","permalink":"http://suzhouxing.github.io/techive/tags/数学/"},{"name":"高中","slug":"高中","permalink":"http://suzhouxing.github.io/techive/tags/高中/"}]},{"title":"科学是什么","slug":"WhatIsScience","date":"2017-10-05T01:37:51.000Z","updated":"2021-09-01T13:05:33.219Z","comments":true,"path":"2017/10/05/WhatIsScience/","link":"","permalink":"http://suzhouxing.github.io/techive/2017/10/05/WhatIsScience/","excerpt":"","text":"科学是一种描述世界运转的方法, 不能解释任何现象的成因. 人类的科学是一套建立在少数 \"显然成立\" 的假设之上的知识体系, \"力\" 就是一种假设存在的相互作用关系. 给定一个初始状态, 科学也许可以预测状态的转移, 或者说现象. 可能其中会用到一些复杂的理论, 而这些复杂的理论可以用更简单的理论解释. 但是如果你要追根溯源, 找到现象的本质, 那么科学是做不到的. 科学首先要自洽, 其次要精确. 但不幸的是, 绝对的科学也许是不存在的, 在可预见的未来中, 科学将一直是个相对的概念. 与经典力学相比, 量子力学是更科学的理论体系. 与传统中医比, 现代医学是更科学的知识体系. 题外话: 这么说来, 被很多学者诟病的机器学习其实本质上也是一种科学, 根据观察结果拟合出一个模型来描述发展趋势. 只不过其假设基础不那么显然, 预测结果也不那么精确. 结合我的研究方向, 可以进行一个类比: 科学就是建模, 技术就是求解. 模型定义什么是可行的, 什么是不可行的, 什么是好的/系统会趋近的状态, 什么是差的/系统会避离得状态. 技术解决如何在满足所有限制条件的情况下, 让系统进入对人最有利的状态.","categories":[{"name":"科学","slug":"科学","permalink":"http://suzhouxing.github.io/techive/categories/科学/"}],"tags":[{"name":"日常","slug":"日常","permalink":"http://suzhouxing.github.io/techive/tags/日常/"},{"name":"科学","slug":"科学","permalink":"http://suzhouxing.github.io/techive/tags/科学/"}]},{"title":"如何咨询技术类问题","slug":"HowToAskQuestions","date":"2017-10-02T06:14:37.000Z","updated":"2018-07-01T03:11:17.814Z","comments":true,"path":"2017/10/02/HowToAskQuestions/","link":"","permalink":"http://suzhouxing.github.io/techive/2017/10/02/HowToAskQuestions/","excerpt":"","text":"每当有人发来一张出错提示框的截图来问我怎么办的时候, 我的内心都是崩溃的. 对于这种让人摸不着头脑的提问方式, 我真想说: \"你把这个问题发到 StackOverflow 上, 两天内没被维护者关闭的话把链接发给我\". 在这里汇总一下技术类提问指南, 免得不会问问题的提问者又来问我为什么我在 StackOverflow 上发的问题被关闭了. [1] https://stackoverflow.com/help/how-to-ask [2] https://stackoverflow.com/help/mcve [3] https://ericlippert.com/2014/03/05/how-to-debug-small-programs/ How do I ask a good question? We'd love to help you. To improve your chances of getting an answer, here are some tips: Search, and research ...and keep track of what you find. Even if you don't find a useful answer elsewhere on the site, including links to related questions that haven't helped can help others in understanding how your question is different from the rest. Write a title that summarizes the specific problem The title is the first thing potential answerers will see, and if your title isn't interesting, they won't read the rest. So make it count: Pretend you're talking to a busy colleague and have to sum up your entire question in one sentence: what details can you include that will help someone identify and solve your problem? Include any error messages, key APIs, or unusual circumstances that make your question different from similar questions already on the site. Spelling, grammar and punctuation are important! Remember, this is the first part of your question others will see - you want to make a good impression. If you're not comfortable writing in English, ask a friend to proof-read it for you. If you're having trouble summarizing the problem, write the title last - sometimes writing the rest of the question first can make it easier to describe the problem. Examples: Bad: C# Math Confusion Good: Why does using float instead of int give me different results when all of my inputs are integers? Bad: [php] session doubt Good: How can I redirect users to different pages based on session data in PHP? Bad: android if else problems Good: Why does str == \"value\" evaluate to false when str is set to \"value\"? Introduce the problem before you post any code In the body of your question, start by expanding on the summary you put in the title. Explain how you encountered the problem you're trying to solve, and any difficulties that have prevented you from solving it yourself. The first paragraph in your question is the second thing most readers will see, so make it as engaging and informative as possible. Help others reproduce the problem Not all questions benefit from including code. But if your problem is with code you've written, you should include some. But don't just copy in your entire program! Not only is this likely to get you in trouble if you're posting your employer's code, it likely includes a lot of irrelevant details that readers will need to ignore when trying to reproduce the problem. Here are some guidelines: Include just enough code to allow others to reproduce the problem. For help with this, read How to create a Minimal, Complete, and Verifiable example. If it is possible to create a live example of the problem that you can link to (for example, on http://sqlfiddle.com/ or http://jsbin.com/) then do so - but also include the code in your question itself. Not everyone can access external sites, and the links may break over time. Include all relevant tags Try to include a tag for the language, library, and specific API your question relates to. If you start typing in the tags field, the system will suggest tags that match what you've typed - be sure and read the descriptions given for them to make sure they're relevant to the question you're asking! See also: What are tags, and how should I use them? Proof-read before posting! Now that you're ready to ask your question, take a deep breath and read through it from start to finish. Pretend you're seeing it for the first time: does it make sense? Try reproducing the problem yourself, in a fresh environment and make sure you can do so using only the information included in your question. Add any details you missed and read through it again. Now is a good time to make sure that your title still describes the problem! Post the question and respond to feedback After you post, leave the question open in your browser for a bit, and see if anyone comments. If you missed an obvious piece of information, be ready to respond by editing your question to include it. If someone posts an answer, be ready to try it out and provide feedback! Look for help asking for help In spite of all your efforts, you may find your questions poorly-received. Don't despair! Learning to ask a good question is a worthy pursuit, and not one you'll master overnight. Here are some additional resources that you may find useful: Writing the perfect question How do I ask and answer homework questions? How to debug small programs Meta discussions on asking questions How to ask questions the smart way — long but good advice. How to create a Minimal, Complete, and Verifiable example When asking a question about a problem caused by your code, you will get much better answers if you provide code people can use to reproduce the problem. That code should be… …Minimal – Use as little code as possible that still produces the same problem …Complete – Provide all parts needed to reproduce the problem …Verifiable – Test the code you're about to provide to make sure it reproduces the problem Minimal The more code there is to go through, the less likely people can find your problem. Streamline your example in one of two ways: Restart from scratch. Create a new program, adding in only what is needed to see the problem. This can be faster for vast systems where you think you already know the source of the problem. Also useful if you can't post the original code publicly for legal or ethical reasons. Divide and conquer. When you have a small amount of code, but the source of the problem is entirely unclear, start removing code a bit at a time until the problem disappears – then add the last part back. Minimal and readable Minimal does not mean terse – don't sacrifice communication to brevity. Use consistent naming and indentation, and include comments if needed to explain portions of the code. Most code editors have a shortcut for formatting code – find it, and use it!Also, don't use tabs – they may look good in your editor, but they'll just make a mess on Stack Overflow. Complete Make sure all information necessary to reproduce the problem is included: Some people might be prepared to load the parts up, and actually try them to test the answer they're about to post. The problem might not be in the part you suspect it is, but another part entirely. If the problem requires some server-side code as well as an XML-based configuration file, include them both. If a web page problem requires HTML, some JavaScript and a stylesheet, include all three. Verifiable To help you solve your problem, others will need to verify that it exists: Describe the problem. \"It doesn't work\" is not a problem statement. Tell us what the expected behavior should be. Tell us what the exact wording of the error message is, and which line of code is producing it. Put a brief summary of the problem in the title of your question. Eliminate any issues that aren't relevant to the problem. If your question isn't about a compiler error, ensure that there are no compile-time errors. Use a program such as JSLint to validate interpreted languages. Validate any HTML or XML. Ensure that the example actually reproduces the problem! If you inadvertently fixed the problem while composing the example but didn't test it again, you'd want to know that before asking someone else to help. It might help to shut the system down and restart it, or transport the example to a fresh machine to confirm it really does provide an example of the problem. For more information on how to debug your program so you can create a minimal example, Eric Lippert has a fantastic blog post on the subject: How to debug small programs. You may have been told to include an MCVE by some helpful commentary, or perhaps even an MVCE if they were rushed; sorry for the initialisms, this is what they were referring to. How to debug small programs Posted on March 5, 2014 One of the most frequent categories of bad questions I see on StackOverflow is: I wrote this program for my assignment and it doesn't work. [20 lines of code]. And... that's it. If you're reading this, odds are good it's because I or someone else linked here from your StackOverflow question shortly before it was closed and deleted. (If you're reading this and you're not in that position, consider leaving your favourite tips for debugging small programs in the comments.) StackOverflow is a question-and-answer site for specific questions about actual code; \"I wrote some buggy code that I can't fix\" is not a question, it's a story, and not even an interesting story. \"Why does subtracting one from zero produce a number that is larger than zero, causing my comparison against zero on line 12 to incorrectly become true?\" is a specific question about actual code. So you're asking the Internet to debug a broken program that you wrote. You've probably never been taught how to debug a small program, because let me tell you, what you're doing now is not an efficient way to get that problem solved. Today is a good day to learn how to debug things for yourself, because StackOverflow is not about to debug your programs for you. I'm going to assume that your program actually compiles but its action is wrong, and that moreover, you have a test case that shows that it is wrong. Here's how to find the bug. First, turn on all compiler warnings. There is no reason why a 20 line program should produce even a single warning. Warnings are the compiler telling you \"this program compiles but does not do what you think it does\", and since that is precisely the situation you are in, it behooves you to pay attention to those warnings. Read them very carefully. If you don't understand why a warning is being produced, that's a good question for StackOverflow because it is a specific question about actual code. Be sure to post the exact text of the warning, the exact code that produces it, and the exact version of the compiler you're using. If your program still has a bug, obtain a rubber duck. Or if a rubber duck is unavailable, get another computer science undergraduate, it's much the same. Explain to the duck using simple words why each line of each method in your program is obviously correct. At some point you will be unable to do so, either because you don't understand the method you wrote, or because it's wrong, or both. Concentrate your efforts on that method; that's probably where the bug is. Seriously, rubber duck debugging works. And as legendary programmer Raymond Chen points out in a comment below, if you can't explain to the duck why you're executing a particular statement, maybe that's because you started programming before you had a plan of attack. Once your program compiles cleanly and the duck doesn't raise any major objections, if there's still a bug then see if you can break your code up into smaller methods, each of which does exactly one logical operation. A common error amongst all programmers, not just beginners, is to make methods that try to do multiple things and do them poorly. Smaller methods are easier to understand and therefore easier for both you and the duck to see the bugs. While you're refactoring your methods into smaller methods, take a minute to write a technical specification for each method. Even if it is just a sentence or two, having a specification helps. The technical specification describes what the method does, what legal inputs are, what expected outputs are, what error cases are, and so on. Often by writing a specification you'll realize that you forgot to handle a particular case in a method, and that's the bug. If you've still got a bug then first double check that your specifications contain all the preconditions and postconditions of every method. A precondition is a thing that has to be true before a method body can work correctly. A postcondition is a thing that has to be true when a method has completed its work. For example, a precondition might be \"this argument is a valid non-null pointer\" or \"the linked list passed in has at least two nodes\", or \"this argument is a positive integer\", or whatever. A postcondition might be \"the linked list has exactly one fewer item in it than it had on entry\", or \"a certain portion of the array is now sorted\", or whatever. A method that has a precondition violated indicates a bug in the caller. A method that has a postcondition violated even when all its preconditions are met indicates a bug in the method. Often by stating your preconditions and postconditions, again, you'll notice a case that you forgot in the method. If you've still got a bug then learn how to write assertions that verify your preconditions and postconditions. An assertion is like a comment that tells you when a condition is violated; a violated condition is almost always a bug. In C# you can say using System.Diagnostics; at the top of your program and then Debug.Assert(value != null);or whatever. Every language has a mechanism for assertions; get someone to teach you how to use them in your language. Put the precondition assertions at the top of the method body and the postconditions before the method returns. (Note that this is easiest to do if every method has a single point of return.) Now when you run your program, if an assertion fires you will be alerted to the nature of the problem, and it won't be so hard to debug. Now write test cases for each method that verify that it is behaving correctly. Test each part independently until you have confidence in it. Test a lot of simple cases; if your method sorts lists, try the empty list, a list with one item, two items, three items that are all the same, three items that are in backwards order, and a few long lists. Odds are good that your bug will show up in a simple case, which makes it easier to analyze. Finally, if your program still has a bug, write down on a piece of paper the exact action you expect the program to take on every line of the program for the broken case. Your program is only twenty lines long. You should be able to write down everything that it does. Now step through the code using a debugger, examining every variable at every step of the way, and line for line verify what the program does against your list. If it does anything that's not on your list then either your list has a mistake, in which case you didn't understand what the program does, or your program has a mistake, in which case you coded it wrong. Fix the thing that is wrong. If you don't know how to fix it, at least now you have a specific technical question you can ask on StackOverflow! Either way, iterate on this process until the description of the proper execution of the program and the actual execution of the program match. While you are running the code in the debugger I encourage you to listen to small doubts. Most programmers have a natural bias to believe their program works as expected, but you are debugging it because that assumption is wrong! Very often I've been debugging a problem and seen out of the corner of my eye the little highlight show up in Visual Studio that means \"a memory location was just modified\", and I know that memory location has nothing to do with my problem. So then why was it modified? Don't ignore those nagging doubts; study the odd behaviour until you understand why it is either correct or incorrect. If this sounds like a lot of work, that's because it is. If you can't do these techniques on twenty line programs that you wrote yourself you are unlikely to be able to use them on two million line programs written by someone else, but that's the problem that developers in industry have to solve every day. Start practicing! And the next time you write an assignment, write the specification, test cases, preconditions, postconditions and assertions for a method before you write the body of the method! You are much less likely to have a bug, and if you do have a bug, you are much more likely to be able to find it quickly. This methodology will not find every bug in every program, but it is highly effective for the sort of short programs that beginner programmers are assigned as homework. These techniques then scale up to finding bugs in non-trivial programs.","categories":[{"name":"技术","slug":"技术","permalink":"http://suzhouxing.github.io/techive/categories/技术/"}],"tags":[{"name":"技术","slug":"技术","permalink":"http://suzhouxing.github.io/techive/tags/技术/"},{"name":"提问","slug":"提问","permalink":"http://suzhouxing.github.io/techive/tags/提问/"}]},{"title":"原来如此","slug":"ThereAreReasons","date":"2017-09-04T15:36:25.000Z","updated":"2022-04-16T08:06:06.015Z","comments":true,"path":"2017/09/04/ThereAreReasons/","link":"","permalink":"http://suzhouxing.github.io/techive/2017/09/04/ThereAreReasons/","excerpt":"","text":"总有些很简单的事情, 自己已经习以为常了, 别人突然问起为什么反而一下解释不清. 最近写论文, 导师在修改时问到, 为什么你的测试分析里面总是测了 8 次 16 次之类的, 正常人不是应该用整十数吗? 我一下子竟然没想到原因, 于是说程序员比较喜欢 2 的整数次幂一点. 后来过了好几天才想起来, 因为实验室的服务器都是 8 核或 64 核的... 又想起以前去面试, 突然一下卡住, 说不记得 true 是 0 还是 1 了. 还说自己经常用 0 表示结果没问题. 感觉对面心里肯定在想, 连这点基本常识都没有, 你到底亲自动手写过几行代码? 后来才想起来, 因为运行正常往往只有一个状态, 但是出错可能千奇百怪...","categories":[{"name":"日常","slug":"日常","permalink":"http://suzhouxing.github.io/techive/categories/日常/"}],"tags":[{"name":"技术","slug":"技术","permalink":"http://suzhouxing.github.io/techive/tags/技术/"},{"name":"日常","slug":"日常","permalink":"http://suzhouxing.github.io/techive/tags/日常/"},{"name":"面试","slug":"面试","permalink":"http://suzhouxing.github.io/techive/tags/面试/"},{"name":"论文","slug":"论文","permalink":"http://suzhouxing.github.io/techive/tags/论文/"}]},{"title":"Hexo 中使用数学公式","slug":"HexoMathSupport","date":"2017-09-03T02:29:59.000Z","updated":"2018-07-01T03:11:17.813Z","comments":true,"path":"2017/09/03/HexoMathSupport/","link":"","permalink":"http://suzhouxing.github.io/techive/2017/09/03/HexoMathSupport/","excerpt":"","text":"为了在 Hexo 生成的网站里面显示 LaTeX 书写风格的数学公式, 尝试了不少方法. 比如官方的 hexo-math, 还有别人提到的 hexo-renderer-mathjax, 以及 hexo-renderer-pandoc. 但是始终不能正确显示数学公式. 最后用安装 hexo-renderer-pandoc 并在每个用到了数学公式的 markdown 文件里添加 123&lt;script type=\"text/javascript\" async src=\"https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/MathJax.js?config=TeX-MML-AM_CHTML\"&gt;&lt;/script&gt; 的方式实现了数学公式的渲染. 但是这个方案显然难以令人满意, 我还是更希望有个自动化的方法. 定位问题 折腾了半天, 最后发现是 hexo-inject 的问题. 不知道是因为 hexo-inject 的 bug 还是其他原因, 生成的 html 代码里面会出现一些 &lt;!-- hexo-inject:begin --&gt;&lt;!-- hexo-inject:end --&gt;. 在其他地方出现都没什么问题, 因为这段代码在 html 中是注释, 但是在 &lt;script&gt;&lt;/script&gt; 中出现时就会被当成无法解析的 javascript 代码. 于是渲染数学公式时就悲剧了. 另外, 嵌入 Google Analytic 的代码好像也会出现类似的问题, 但是很奇怪百度统计居然没问题. 后来在 hexo-math 和 hexo-inject 的 issue 里看到 hexo 的维护者说 hexo-inject 跟 hexo-renderer-jade 冲突了. 解决方案 删除有 bug 的插件 执行以下命令删除 hexo-inject 插件, 并默默祈祷没有别的插件或者主题依赖这个插件. 1npm uninstall hexo-inject --save 嵌入 MathJax 的代码 在 themes/maupassant/layout/_partial/head.jade 的末尾添加以下代码. 1script(type=&apos;text/javascript&apos;, src=&quot;https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/MathJax.js?config=TeX-MML-AM_CHTML&quot;, async) 其中 maupassant 的位置填你自己选择的主题名字. head.jade 是嵌入上面的脚本的位置, 不一定非要在 head 里, 而且后缀可能不同主题的不一样 (使用了不同的引擎). 我这里选择了和主题原有文件一致的后缀, 因为主题已经声明了其依赖的插件, 不用担心无法解析的问题. 结果 下面是配置成功之后的显示效果: 123$$\\min \\sum_&#123;i=0&#125;^&#123;+\\infty&#125; \\frac&#123;\\exp&#123;x^2&#125;&#125;&#123;\\sqrt&#123;y&#125;&#125;$$ \\[ \\min \\sum_{i=0}^{+\\infty} \\frac{\\exp{x^2}}{\\sqrt{y}} \\] 总结 值得一提的是, hexo-math 所依赖的插件 hexo-inject 似乎已经被作者废弃了, 感觉 hexo-math 也因此成了坑. 而且就算 hexo-inject 的 bug 修复了, hexo-math 还有下标需要给下划线加反斜杠转义的问题, 仍然不能和 LaTeX 公式无缝对接. hexo-renderer-mathjax 作者也多年没有更新, 现在 MathJax 的 CDN 已经不再提供服务, 但是作者一直没有更新可用的地址. hexo-renderer-pandoc 还依赖第三方软件, 不能使用 npm 统一管理, 确实麻烦了一点. 但是作为一个经常用 Markdown 写初稿或者项目文档, 最后再用 LaTeX 整理论文的人, Typora 和 Pandoc 之类的工具基本上是装机必备, 好像没啥影响. 最后还是不得不感慨开源项目的最大缺点, 就是很难保证可持续性 -- 依赖的工具更新了它可能不能及时更新已适应新版本, 或者用户发现了 bug 也很难及时修复. 感觉还是有大企业的维护开源项目才能产出最良心最好用的软件. 参考资料 [1] https://blog.yuanbin.me/posts/2014/05/play-mathjax-with-pandoc.html","categories":[{"name":"Hexo","slug":"Hexo","permalink":"http://suzhouxing.github.io/techive/categories/Hexo/"}],"tags":[{"name":"技术","slug":"技术","permalink":"http://suzhouxing.github.io/techive/tags/技术/"},{"name":"Bug","slug":"Bug","permalink":"http://suzhouxing.github.io/techive/tags/Bug/"},{"name":"博客","slug":"博客","permalink":"http://suzhouxing.github.io/techive/tags/博客/"},{"name":"Hexo","slug":"Hexo","permalink":"http://suzhouxing.github.io/techive/tags/Hexo/"},{"name":"数学公式","slug":"数学公式","permalink":"http://suzhouxing.github.io/techive/tags/数学公式/"},{"name":"MathJax","slug":"MathJax","permalink":"http://suzhouxing.github.io/techive/tags/MathJax/"},{"name":"LaTeX","slug":"LaTeX","permalink":"http://suzhouxing.github.io/techive/tags/LaTeX/"}]},{"title":"《黑客帝国》中最大的 bug 的合理解释","slug":"FixBugInTheMovieMatrix","date":"2017-09-02T03:07:07.000Z","updated":"2018-07-01T03:11:17.812Z","comments":true,"path":"2017/09/02/FixBugInTheMovieMatrix/","link":"","permalink":"http://suzhouxing.github.io/techive/2017/09/02/FixBugInTheMovieMatrix/","excerpt":"","text":"黑客帝国中最大的 bug, 莫过于 AI 为啥没有把人类统统消灭, 而是用 Matrix 把人类圈养起来了. 如果没有这个背景设定, 电影中的所有故事就都不会发生. 对此, 电影中的解释是 AI 需要利用人类的生物电/热能, 而人类只有被接入虚拟世界才能无公害地稳定供能, 否则会搞破坏或者死亡. 这个理由显然是站不住脚的 -- 人类释放能量, 首先要通过食物吸收更多的能量... 不过我们可以有另一种解释, 在目前的科技水平下看来稍微合理一点点. 首先要沿用电影的背景, AI 和人类的战争使地球表面被烟雾覆盖, 无法获取太阳能, 自然也不会有水能和风能. 然后在延伸一下, AI 经过计算得出了在当前体系结构下地球上的剩余能源 (核能/地热能等) 将在其发展为星际文明之前耗尽的结论, 为了续命必须省吃俭用节约能源. 人脑是高度集成, 高度并发且高度节能的 \"三高\" 处理器, AI 希望利用生物计算提高自己的能效. 但是因为硅基生物对碳基生物的研究还不够完善, 体外培养的一大坨神经元并不能像人脑一样完成复杂的计算任务; 而体内的大脑如果没有适当的来自感受器官的刺激会迅速萎缩或者进入类似深度睡眠的抑制状态, 无法提供可接受的运算能力. 因此 AI 不得不模拟一个虚拟世界, 不断给予人脑恰到好处的刺激, 然后利用剩余的脑力运行程序.","categories":[{"name":"异想天开","slug":"异想天开","permalink":"http://suzhouxing.github.io/techive/categories/异想天开/"}],"tags":[{"name":"异想天开","slug":"异想天开","permalink":"http://suzhouxing.github.io/techive/tags/异想天开/"},{"name":"电影","slug":"电影","permalink":"http://suzhouxing.github.io/techive/tags/电影/"},{"name":"黑客帝国","slug":"黑客帝国","permalink":"http://suzhouxing.github.io/techive/tags/黑客帝国/"},{"name":"Bug","slug":"Bug","permalink":"http://suzhouxing.github.io/techive/tags/Bug/"}]},{"title":"Hexo 多主题切换","slug":"HexoSwitchThemes","date":"2017-09-02T03:00:00.000Z","updated":"2018-07-01T03:11:17.813Z","comments":true,"path":"2017/09/02/HexoSwitchThemes/","link":"","permalink":"http://suzhouxing.github.io/techive/2017/09/02/HexoSwitchThemes/","excerpt":"","text":"因为是第一次用 Hexo, 一下子尝试了很多主题. 不断尝试新主题时还挺正常, 但是试得差不多了准备回头选一个自己满意的主题时, 奇葩的事情发生了: 页面显示突然变得非常混乱, 而且有很多之前用过的主题的痕迹. 搜索 hexo switch theme mess 什么结果都没有. 然后在整个工程目录里面找, 看什么文件被我改乱了. 找着找着发现 db.json 文件里面存了好多东西, 而且里面出现了很多字符串出现了其他主题的名字. 但是看它名字里写着个 \"db\" 不敢随便删. 搜索这个文件发现有人提到这个文件在 .gitignore 里面被设置了忽略, 看来是个随时可以重新生成的缓存文件了. 果然, 删除 db.json 文件之后就好了. 后来沉下心来一点一点看官方文档, 看到了一条快速入门教程里没提到的命令: 1$ hexo clean 前面直接删 db.json 的方式可能会导致部署的站点时有些多余的文件没被清理掉, 用这个命令就比较彻底了. 突然想起来最开始尝试的主题还不多时自己也切换过很多次, 但是没发现大问题, 只是有时会发现归档和关于的页面路径不正确, 不知道会不会也是缓存的问题.","categories":[{"name":"Hexo","slug":"Hexo","permalink":"http://suzhouxing.github.io/techive/categories/Hexo/"}],"tags":[{"name":"技术","slug":"技术","permalink":"http://suzhouxing.github.io/techive/tags/技术/"},{"name":"Bug","slug":"Bug","permalink":"http://suzhouxing.github.io/techive/tags/Bug/"},{"name":"博客","slug":"博客","permalink":"http://suzhouxing.github.io/techive/tags/博客/"},{"name":"Hexo","slug":"Hexo","permalink":"http://suzhouxing.github.io/techive/tags/Hexo/"},{"name":"主题","slug":"主题","permalink":"http://suzhouxing.github.io/techive/tags/主题/"},{"name":"缓存","slug":"缓存","permalink":"http://suzhouxing.github.io/techive/tags/缓存/"}]}]}