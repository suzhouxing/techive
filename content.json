{"meta":{"title":"Techive","subtitle":"An Archive for Technologies","description":"An Archive for Technologies by Zhouxing Su","author":"Zhouxing Su","url":"http://suzhouxing.github.io/techive"},"pages":[{"title":"About Me","date":"2017-09-02T11:25:24.000Z","updated":"2018-07-01T03:11:17.818Z","comments":true,"path":"about/index.html","permalink":"http://suzhouxing.github.io/techive/about/index.html","excerpt":"","text":"我就是我."}],"posts":[{"title":"SmartLab Challenge 2021 - Vehicle Routing Problem with Time Windows","slug":"Contest-2021VRP","date":"2021-09-27T01:47:34.000Z","updated":"2021-09-29T13:03:39.399Z","comments":true,"path":"2021/09/27/Contest-2021VRP/","link":"","permalink":"http://suzhouxing.github.io/techive/2021/09/27/Contest-2021VRP/","excerpt":"","text":"带时间窗的车辆路由问题是交通运输与物流配送等领域中的重要问题, 其应用场景在生产生活中随处可见. 带时间窗的车辆路由问题主要研究如何确定一系列从同一个仓库出发的车辆的行驶路径, 在每辆车均不超载且每个客户都在给定时间窗内被访问的前提下, 最小化所有车辆的行驶时间之和. 比如快递配送过程中, 配送员能携带的物品重量有限, 同时每个客户只在特定的时段内有空收件, 快递公司需要调度配送员用最短的工时完成所有配送任务. 相反地, 在物流公司提供上门取件服务时, 揽件人员也会面临同样的优化问题. 因此, 高效的带时间窗的车辆路由问题的求解算法在理论上与实践上均意义重大. 带时间窗的车辆路由算法训练 问题概述 给定一个有向完全图, 图中包含一个仓库节点和若干客户节点. 每个客户节点都对应一个配送请求, 需要一个在指定的时间窗内将给定重量的物品一次性送达, 交接过程花费固定的时间. 此外, 每辆车的最大载重量相同且均需从仓库出发最后回到仓库, 同时任意两点间的最短行驶时间已知 (超时视为到达节点后原地等待). 请确定使用几辆车参与配送, 并给出每辆车依次访问的有序节点列表, 使得所有车辆的总行驶时间最短. 参考文献. [1] M. M. Solomon, “Algorithms for the Vehicle Routing and Scheduling Problems with Time Window Constraints,” Operations Research, vol. 35, no. 2, pp. 254–265, 1987, doi: 10.1287/opre.35.2.254. [2] Y. Nagata and O. Bräysy, “A powerful route minimization heuristic for the vehicle routing problem with time windows,” Operations Research Letters, vol. 37, no. 5, pp. 333–338, 2009, doi: 10.1016/j.orl.2009.04.006. [3] Y. Nagata, O. Bräysy, and W. Dullaert, “A penalty-based edge assembly memetic algorithm for the vehicle routing problem with time windows,” Computers &amp; Operations Research, vol. 37, no. 4, pp. 724–737, 2010, doi: 10.1016/j.cor.2009.06.022. [4] R. Baldacci, A. Mingozzi, and R. Roberti, “New Route Relaxation and Pricing Strategies for the Vehicle Routing Problem,” Operations Research, vol. 59, no. 5, pp. 1269–1283, 2011, doi: 10.1287/opre.1110.0975. [5] http://dimacs.rutgers.edu/programs/challenge/vrp/vrptw [6] http://dimacs.rutgers.edu/files/7616/3155/5530/VRPTW_Competition_Rules.pdf [7] https://www.sintef.no/projectweb/top/vrptw/homberger-benchmark/200-customers 命令行参数 请大家编写程序时支持两个命令行参数, 依次为运行时间上限 (单位为秒) 和随机种子 (0-65535). 算例文件已重定向至标准输入 stdin/cin, 标准输出 stdout/cout 已重定向至解文件 (如需打印调试信息, 请使用标准错误输出 stderr/cerr). 例如, 在控制台运行以下命令表示调用可执行文件 vrptw.exe 在限时 300 秒, 随机种子为 12345 的情况下求解路径为 ../data/solomon.c101.txt 的算例, 解文件输出至 sln.solomon.c101.txt: 1vrptw.exe 300 123456 &lt;../data/solomon.c101.txt &gt;sln.solomon.c101.txt 运行时间上限. 超出运行时间上限后测试程序会强行终止算法, 请确保在此之前已输出解 (最好还能自行正常退出). 随机种子设置. 使用 C 语言随机数生成器请用 srand. 使用 C++ 随机数生成器 (如 mt19937) 请在构造时传参或调用 seed() 方法设置. 输入的算例文件格式 所有算例的节点和车辆分别从 0 开始连续编号, 所有节点分布于平面直角坐标系中. 节点 0 为仓库, 即车辆的起点和终点, 其物品重量, 最短停留时间, 时间窗开始时间均为 0. 第一行给出两个由空白字符分隔的整数, 分别表示节点数 N, 最大可用车辆数 K, 以及各车辆的载重量上限 M. 接下来连续 N 行, 每行包含 6 个由空白字符分隔的整数, 第 i 行的 6 个整数依次表示第 i 个节点的 x 坐标, y 坐标, 物品重量, 最短停留时间 (服务时间), 最早到达时间, 最晚到达时间. 例如, 以下算例文件表示有 4 个节点和 3 辆车, 每辆车的容量为 10; 其中, 节点 0 的坐标为 (1, 5), 物品重量为 0, 最短停留时间为 0, 时间窗开始和结束时间分别为 0 和 8; 节点 1 的坐标为 (2, 1), 物品重量为 6, 最短停留时间为 3, 时间窗开始和结束时间分别为 4 和 5; 节点 2 的坐标为 (3, 7), 物品重量为 2, 最短停留时间为 4, 时间窗开始和结束时间分别为 5 和 6; 节点 3 的坐标为 (8, 8), 物品重量为 9, 最短停留时间为 5, 时间窗开始和结束时间分别为 6 和 7: 123454 3 101 5 0 0 0 82 1 6 3 4 53 7 2 4 5 68 8 9 5 6 7 注意, 本问题所用算例集中假设行驶时间等于两点间的距离, 目前的距离计算遵循文献与 DIMACS 竞赛中的约定, 使用截断保留一位小数的欧氏距离 (\\(t = \\lfloor 10 d \\rfloor / 10\\)), 具体计算方式以 SDK 中的代码为准. 输出的解文件格式 输出 V 行整数表示 V 辆车 (V &lt; K) 的行驶路径, 第 i 行第 j 个整数表示第 i 辆车经过的第 j 个客户节点. 例如, 以下解文件表示 2 辆车的行驶路径; 其中, 车辆 0 从仓库 0 出发后依次经过节点 3, 最后回到仓库 0; 车辆 1 从仓库 0 出发后依次经过节点 1 和 2, 最后回到仓库 0: 1231 2 提交要求 发送至邮箱 szx@duhe.tech. 邮件标题格式为 \"Challenge2021VRPTW2d-姓名-学校-专业\". 邮件附件为单个压缩包, 文件名为 \"姓名-学校-专业\", 其内包含下列文件. 必要 算法的可执行文件 (Windows 平台). 建议基于官方 SDK 开发 (https://gitee.com/suzhouxing/npbenchmark/tree/main/SDK.VRPTW2d). 用 g++ 的同学编译时请静态链接, 即添加 -static-libgcc -static-libstdc++ 编译选项. 必要 算法源码. 可重入 (可在同一线程内反复调用而不会出现数据初始化错误或内存泄漏). 可并发 (可在同一进程内的多个线程同时运行多个算法求解实例而互不干扰, 满足此要求一般不能有全局的非只读变量). 可伸缩 (数据结构可以根据算例规模动态申请内存, 而非根据预先指定的编译期常量进行内存分配). 可选 算法在各算例上的运行情况概要, 至少包括以下几项信息 (仅在无法成功调用算法输出可通过检查程序的解时作为参考). 算例名. 使用的车辆数. 所有车辆的行驶时长总和. 计算耗时. 可选 算法在各算例上求得的路径总长度最短的解文件 (仅在无法成功调用算法输出可通过检查程序的解时作为参考). 若成功提交, 在收到邮件时以及测试完成后系统均会自动发送邮件反馈提交情况. 若测试结果较优, 可在排行榜页面看到自己的运行情况 (https://gitee.com/suzhouxing/npbenchmark/tree/data). 例如: 12345678910111213苏宙行-华科-计科.zip| vrptw2d.exe| results.csv|+---src| main.cpp| algorithm.cpp| algorithm.h|+---results solomon.c101.n101v25c200.txt solomon.c102.n101v25c200.txt ... 算例清单 下载地址: https://gitee.com/suzhouxing/npbenchmark/tree/data/VRPTW2d/Instance solomon.c101.n101v25c200 solomon.c102.n101v25c200 solomon.c103.n101v25c200 solomon.c104.n101v25c200 solomon.c105.n101v25c200 solomon.c106.n101v25c200 solomon.c107.n101v25c200 solomon.c108.n101v25c200 solomon.c109.n101v25c200 solomon.c201.n101v25c700 solomon.c202.n101v25c700 solomon.c203.n101v25c700 solomon.c204.n101v25c700 solomon.c205.n101v25c700 solomon.c206.n101v25c700 solomon.c207.n101v25c700 solomon.c208.n101v25c700 solomon.r101.n101v25c200 solomon.r102.n101v25c200 solomon.r103.n101v25c200 solomon.r104.n101v25c200 solomon.r105.n101v25c200 solomon.r106.n101v25c200 solomon.r107.n101v25c200 solomon.r108.n101v25c200 solomon.r109.n101v25c200 solomon.r110.n101v25c200 solomon.r111.n101v25c200 solomon.r112.n101v25c200 solomon.r201.n101v25c1000 solomon.r202.n101v25c1000 solomon.r203.n101v25c1000 solomon.r204.n101v25c1000 solomon.r205.n101v25c1000 solomon.r206.n101v25c1000 solomon.r207.n101v25c1000 solomon.r208.n101v25c1000 solomon.r209.n101v25c1000 solomon.r210.n101v25c1000 solomon.r211.n101v25c1000 solomon.rc101.n101v25c200 solomon.rc102.n101v25c200 solomon.rc103.n101v25c200 solomon.rc104.n101v25c200 solomon.rc105.n101v25c200 solomon.rc106.n101v25c200 solomon.rc107.n101v25c200 solomon.rc108.n101v25c200 solomon.rc201.n101v25c1000 solomon.rc202.n101v25c1000 solomon.rc203.n101v25c1000 solomon.rc204.n101v25c1000 solomon.rc205.n101v25c1000 solomon.rc206.n101v25c1000 solomon.rc207.n101v25c1000 solomon.rc208.n101v25c1000 homberger.c10201.n201v50c200 homberger.c10202.n201v50c200 homberger.c10203.n201v50c200 homberger.c10204.n201v50c200 homberger.c10205.n201v50c200 homberger.c10206.n201v50c200 homberger.c10207.n201v50c200 homberger.c10208.n201v50c200 homberger.c10209.n201v50c200 homberger.c10210.n201v50c200 homberger.c10401.n401v100c200 homberger.c10402.n401v100c200 homberger.c10403.n401v100c200 homberger.c10404.n401v100c200 homberger.c10405.n401v100c200 homberger.c10406.n401v100c200 homberger.c10407.n401v100c200 homberger.c10408.n401v100c200 homberger.c10409.n401v100c200 homberger.c10410.n401v100c200 homberger.c10601.n601v150c200 homberger.c10602.n601v150c200 homberger.c10603.n601v150c200 homberger.c10604.n601v150c200 homberger.c10605.n601v150c200 homberger.c10606.n601v150c200 homberger.c10607.n601v150c200 homberger.c10608.n601v150c200 homberger.c10609.n601v150c200 homberger.c10610.n601v150c200 homberger.c10801.n801v200c200 homberger.c10802.n801v200c200 homberger.c10803.n801v200c200 homberger.c10804.n801v200c200 homberger.c10805.n801v200c200 homberger.c10806.n801v200c200 homberger.c10807.n801v200c200 homberger.c10808.n801v200c200 homberger.c10809.n801v200c200 homberger.c10810.n801v200c200 homberger.c11001.n1001v250c200 homberger.c11002.n1001v250c200 homberger.c11003.n1001v250c200 homberger.c11004.n1001v250c200 homberger.c11005.n1001v250c200 homberger.c11006.n1001v250c200 homberger.c11007.n1001v250c200 homberger.c11008.n1001v250c200 homberger.c11009.n1001v250c200 homberger.c11010.n1001v250c200 homberger.c20201.n201v50c700 homberger.c20202.n201v50c700 homberger.c20203.n201v50c700 homberger.c20204.n201v50c700 homberger.c20205.n201v50c700 homberger.c20206.n201v50c700 homberger.c20207.n201v50c700 homberger.c20208.n201v50c700 homberger.c20209.n201v50c700 homberger.c20210.n201v50c700 homberger.c20401.n401v100c700 homberger.c20402.n401v100c700 homberger.c20403.n401v100c700 homberger.c20404.n401v100c700 homberger.c20405.n401v100c700 homberger.c20406.n401v100c700 homberger.c20407.n401v100c700 homberger.c20408.n401v100c700 homberger.c20409.n401v100c700 homberger.c20410.n401v100c700 homberger.c20601.n601v150c700 homberger.c20602.n601v150c700 homberger.c20603.n601v150c700 homberger.c20604.n601v150c700 homberger.c20605.n601v150c700 homberger.c20606.n601v150c700 homberger.c20607.n601v150c700 homberger.c20608.n601v150c700 homberger.c20609.n601v150c700 homberger.c20610.n601v150c700 homberger.c20801.n801v200c700 homberger.c20802.n801v200c700 homberger.c20803.n801v200c700 homberger.c20804.n801v200c700 homberger.c20805.n801v200c700 homberger.c20806.n801v200c700 homberger.c20807.n801v200c700 homberger.c20808.n801v200c700 homberger.c20809.n801v200c700 homberger.c20810.n801v200c700 homberger.c21001.n1001v250c700 homberger.c21002.n1001v250c700 homberger.c21003.n1001v250c700 homberger.c21004.n1001v250c700 homberger.c21005.n1001v250c700 homberger.c21006.n1001v250c700 homberger.c21007.n1001v250c700 homberger.c21008.n1001v250c700 homberger.c21009.n1001v250c700 homberger.c21010.n1001v250c700 homberger.r10201.n201v50c200 homberger.r10202.n201v50c200 homberger.r10203.n201v50c200 homberger.r10204.n201v50c200 homberger.r10205.n201v50c200 homberger.r10206.n201v50c200 homberger.r10207.n201v50c200 homberger.r10208.n201v50c200 homberger.r10209.n201v50c200 homberger.r10210.n201v50c200 homberger.r10401.n401v100c200 homberger.r10402.n401v100c200 homberger.r10403.n401v100c200 homberger.r10404.n401v100c200 homberger.r10405.n401v100c200 homberger.r10406.n401v100c200 homberger.r10407.n401v100c200 homberger.r10408.n401v100c200 homberger.r10409.n401v100c200 homberger.r10410.n401v100c200 homberger.r10601.n601v150c200 homberger.r10602.n601v150c200 homberger.r10603.n601v150c200 homberger.r10604.n601v150c200 homberger.r10605.n601v150c200 homberger.r10606.n601v150c200 homberger.r10607.n601v150c200 homberger.r10608.n601v150c200 homberger.r10609.n601v150c200 homberger.r10610.n601v150c200 homberger.r10801.n801v200c200 homberger.r10802.n801v200c200 homberger.r10803.n801v200c200 homberger.r10804.n801v200c200 homberger.r10805.n801v200c200 homberger.r10806.n801v200c200 homberger.r10807.n801v200c200 homberger.r10808.n801v200c200 homberger.r10809.n801v200c200 homberger.r10810.n801v200c200 homberger.r11001.n1001v250c200 homberger.r11002.n1001v250c200 homberger.r11003.n1001v250c200 homberger.r11004.n1001v250c200 homberger.r11005.n1001v250c200 homberger.r11006.n1001v250c200 homberger.r11007.n1001v250c200 homberger.r11008.n1001v250c200 homberger.r11009.n1001v250c200 homberger.r11010.n1001v250c200 homberger.r20201.n201v50c1000 homberger.r20202.n201v50c1000 homberger.r20203.n201v50c1000 homberger.r20204.n201v50c1000 homberger.r20205.n201v50c1000 homberger.r20206.n201v50c1000 homberger.r20207.n201v50c1000 homberger.r20208.n201v50c1000 homberger.r20209.n201v50c1000 homberger.r20210.n201v50c1000 homberger.r20401.n401v100c1000 homberger.r20402.n401v100c1000 homberger.r20403.n401v100c1000 homberger.r20404.n401v100c1000 homberger.r20405.n401v100c1000 homberger.r20406.n401v100c1000 homberger.r20407.n401v100c1000 homberger.r20408.n401v100c1000 homberger.r20409.n401v100c1000 homberger.r20410.n401v100c1000 homberger.r20601.n601v150c1000 homberger.r20602.n601v150c1000 homberger.r20603.n601v150c1000 homberger.r20604.n601v150c1000 homberger.r20605.n601v150c1000 homberger.r20606.n601v150c1000 homberger.r20607.n601v150c1000 homberger.r20608.n601v150c1000 homberger.r20609.n601v150c1000 homberger.r20610.n601v150c1000 homberger.r20801.n801v200c1000 homberger.r20802.n801v200c1000 homberger.r20803.n801v200c1000 homberger.r20804.n801v200c1000 homberger.r20805.n801v200c1000 homberger.r20806.n801v200c1000 homberger.r20807.n801v200c1000 homberger.r20808.n801v200c1000 homberger.r20809.n801v200c1000 homberger.r20810.n801v200c1000 homberger.r21001.n1001v250c1000 homberger.r21002.n1001v250c1000 homberger.r21003.n1001v250c1000 homberger.r21004.n1001v250c1000 homberger.r21005.n1001v250c1000 homberger.r21006.n1001v250c1000 homberger.r21007.n1001v250c1000 homberger.r21008.n1001v250c1000 homberger.r21009.n1001v250c1000 homberger.r21010.n1001v250c1000 homberger.rc10201.n201v50c200 homberger.rc10202.n201v50c200 homberger.rc10203.n201v50c200 homberger.rc10204.n201v50c200 homberger.rc10205.n201v50c200 homberger.rc10206.n201v50c200 homberger.rc10207.n201v50c200 homberger.rc10208.n201v50c200 homberger.rc10209.n201v50c200 homberger.rc10210.n201v50c200 homberger.rc10401.n401v100c200 homberger.rc10402.n401v100c200 homberger.rc10403.n401v100c200 homberger.rc10404.n401v100c200 homberger.rc10405.n401v100c200 homberger.rc10406.n401v100c200 homberger.rc10407.n401v100c200 homberger.rc10408.n401v100c200 homberger.rc10409.n401v100c200 homberger.rc10410.n401v100c200 homberger.rc10601.n601v150c200 homberger.rc10602.n601v150c200 homberger.rc10603.n601v150c200 homberger.rc10604.n601v150c200 homberger.rc10605.n601v150c200 homberger.rc10606.n601v150c200 homberger.rc10607.n601v150c200 homberger.rc10608.n601v150c200 homberger.rc10609.n601v150c200 homberger.rc10610.n601v150c200 homberger.rc10801.n801v200c200 homberger.rc10802.n801v200c200 homberger.rc10803.n801v200c200 homberger.rc10804.n801v200c200 homberger.rc10805.n801v200c200 homberger.rc10806.n801v200c200 homberger.rc10807.n801v200c200 homberger.rc10808.n801v200c200 homberger.rc10809.n801v200c200 homberger.rc10810.n801v200c200 homberger.rc11001.n1001v250c200 homberger.rc11002.n1001v250c200 homberger.rc11003.n1001v250c200 homberger.rc11004.n1001v250c200 homberger.rc11005.n1001v250c200 homberger.rc11006.n1001v250c200 homberger.rc11007.n1001v250c200 homberger.rc11008.n1001v250c200 homberger.rc11009.n1001v250c200 homberger.rc11010.n1001v250c200 homberger.rc20201.n201v50c1000 homberger.rc20202.n201v50c1000 homberger.rc20203.n201v50c1000 homberger.rc20204.n201v50c1000 homberger.rc20205.n201v50c1000 homberger.rc20206.n201v50c1000 homberger.rc20207.n201v50c1000 homberger.rc20208.n201v50c1000 homberger.rc20209.n201v50c1000 homberger.rc20210.n201v50c1000 homberger.rc20401.n401v100c1000 homberger.rc20402.n401v100c1000 homberger.rc20403.n401v100c1000 homberger.rc20404.n401v100c1000 homberger.rc20405.n401v100c1000 homberger.rc20406.n401v100c1000 homberger.rc20407.n401v100c1000 homberger.rc20408.n401v100c1000 homberger.rc20409.n401v100c1000 homberger.rc20410.n401v100c1000 homberger.rc20601.n601v150c1000 homberger.rc20602.n601v150c1000 homberger.rc20603.n601v150c1000 homberger.rc20604.n601v150c1000 homberger.rc20605.n601v150c1000 homberger.rc20606.n601v150c1000 homberger.rc20607.n601v150c1000 homberger.rc20608.n601v150c1000 homberger.rc20609.n601v150c1000 homberger.rc20610.n601v150c1000 homberger.rc20801.n801v200c1000 homberger.rc20802.n801v200c1000 homberger.rc20803.n801v200c1000 homberger.rc20804.n801v200c1000 homberger.rc20805.n801v200c1000 homberger.rc20806.n801v200c1000 homberger.rc20807.n801v200c1000 homberger.rc20808.n801v200c1000 homberger.rc20809.n801v200c1000 homberger.rc20810.n801v200c1000 homberger.rc21001.n1001v250c1000 homberger.rc21002.n1001v250c1000 homberger.rc21003.n1001v250c1000 homberger.rc21004.n1001v250c1000 homberger.rc21005.n1001v250c1000 homberger.rc21006.n1001v250c1000 homberger.rc21007.n1001v250c1000 homberger.rc21008.n1001v250c1000 homberger.rc21009.n1001v250c1000 homberger.rc21010.n1001v250c1000","categories":[{"name":"算法挑战","slug":"算法挑战","permalink":"http://suzhouxing.github.io/techive/categories/算法挑战/"}],"tags":[{"name":"组合优化","slug":"组合优化","permalink":"http://suzhouxing.github.io/techive/tags/组合优化/"},{"name":"算法挑战","slug":"算法挑战","permalink":"http://suzhouxing.github.io/techive/tags/算法挑战/"}]},{"title":"运筹优化相关算法竞赛合集","slug":"CompetitionNavigation","date":"2021-09-16T02:00:27.000Z","updated":"2021-09-16T12:57:34.534Z","comments":true,"path":"2021/09/16/CompetitionNavigation/","link":"","permalink":"http://suzhouxing.github.io/techive/2021/09/16/CompetitionNavigation/","excerpt":"","text":"很欣慰地看到, 国家越来越重视竞赛了, 各个教育阶段的升学和考核等政策都在逐步向有竞赛成果的人倾斜. 相比于论文, 大部分竞赛有相对客观的评价标准, 第一只有一个, 很难出现大量无意义的低质量的重复研究. 因此, 后来者无需花费大量时间甄别前人到底尝试过哪些方法, 其中哪些是有效的, 哪些是无用的. 下面将简单列举一下与运筹优化相关的竞赛. 周期性竞赛 计算机科学 CS 电子设计自动化 EDA ICCAD (每年) http://iccad-contest.org ISPD (每年) http://www.ispd.cc/?page=contests EDAAI (每年/随时提交) http://www.eda-ai.org/ 集成电路EDA设计精英挑战赛 (每年) https://eda.icisc.cn/ 逻辑综合 IWLS (每年) https://www.iwls.org/ ReactiveSynthesis (每年) http://www.syntcomp.org/ SyGuS (每年) https://sygus.org/comp/ EDAthon (每年) https://sites.google.com/view/ceda-hk/edathon-2021 静态时序分析 TAU (每年) https://sites.google.com/view/tau-contest-2021/home/past-contests NP 问题通用求解引擎 命题逻辑 SAT (每年) http://www.satcompetition.org/ 历史链接 http://www.maxsat.udl.cat/ MaxSAT (每年) https://maxsat-evaluations.github.io/ 谓词逻辑 SMT (每年) https://smt-comp.github.io/previous.html QBF (每年) http://www.qbflib.org/index_eval.php 约束编程 MiniZinc (每年) https://www.minizinc.org/challenge.html XCSP (每年) http://xcsp.org/competition 可计算性与计算复杂性理论 HWMCC (每年) http://fmv.jku.at/hwmcc20/#history ModelChecking (每年) https://mcc.lip6.fr/ ModelCounting (每年) https://mccompetition.org/past_iterations 人工智能 AI 规划调度 ICAPS (每年) https://www.icaps-conference.org/competitions/ 自动定理证明 CASC (每年) http://www.tptp.org/CASC/ 改写引擎 REC (不规律) http://rec.gforge.inria.fr/ 并行计算 GraphChallenge (每年) https://graphchallenge.mit.edu/challenges 运筹学 OR DIMACS (不规律) http://dimacs.rutgers.edu/programs/challenge/ 历史链接 http://dimacs.rutgers.edu/archive/Challenges/ ROADEF (每一到两年) http://www.roadef.org/challenge VeRoLog (不规律) https://www.euro-online.org/websites/verolog/verolog-solver-challenge/ 生物信息学 BI 蛋白质结构预测 CASP (每两年) https://predictioncenter.org/ 竞赛平台 华为 https://competition.huaweicloud.com/competitions 阿里 https://tianchi.aliyun.com/competition/gameList/activeList kaggle https://www.kaggle.com/competitions AIcrowd https://www.aicrowd.com/challenges Biendata https://biendata.xyz/ 京东 https://jdata.jd.com/html/list.html OPTIL (排行榜) https://www.optil.io/optilion/problems 其他竞赛导航 学术会议或权威机构 PATAT (时刻表调度相关竞赛汇总) https://www.patatconference.org/communityService.html FLoC (逻辑相关竞赛汇总) (每四年) https://floc2022.org/ https://www.floc2018.org/floc-olympic-games/ http://vsl2014.at/olympics/ TACAS (系统构建与分析的算法与工具相关竞赛汇总) https://tacas.info/toolympics.php 个人搜集 HSU (各类竞赛汇总) https://www.hsu-hh.de/logistik/research/challenges 已结束竞赛 ROADEF/EURO 电网检修计划 http://www.roadef.org/challenge/2020/en/index.php 玻璃切割 http://www.roadef.org/challenge/2018/en/index.php 库存路由 http://www.roadef.org/challenge/2016/en/index.php 负载均衡 http://www.roadef.org/challenge/2012/en/index.php GECCO 监控相机布局 http://www.mage.fst.uha.fr/brevilliers/ocp-uscp-benchmark/index.html 历史链接 http://www.mage.fst.uha.fr/brevilliers/gecco-2020-ocp-uscp-competition 历史链接 http://www.mage.fst.uha.fr/brevilliers/gecco-2021-ocp-uscp-competition 京东 库存管理 https://jdata.jd.com/html/detail.html?id=4 车辆路由 https://jdata.jd.com/html/detail.html?id=5 阿里 布料切割 https://tianchi.aliyun.com/competition/entrance/231749/introduction 作业调度 https://tianchi.aliyun.com/competition/entrance/231663/introduction 物流运输 https://tianchi.aliyun.com/competition/entrance/231623/introduction 航班延误恢复 https://tianchi.aliyun.com/competition/entrance/231609/introduction 无人机路径规划 https://tianchi.aliyun.com/competition/entrance/231622/introduction 客流量预测 https://tianchi.aliyun.com/competition/entrance/231588/information 华为 机器分配 2018 年软件精英挑战赛 中心选址流量分发 2017 年软件精英挑战赛 光网络路由 2016 年软件精英挑战赛 滴滴 出租车订单分配 https://biendata.xyz/competition/kdd_didi/ 护士排班 护士排班 https://nrpcompetition.kuleuven-kulak.be/ 多阶段护士排班 http://mobiz.vives.be/inrc2/ CHeSC 跨领域启发式搜索 http://www.asap.cs.nott.ac.uk/external/chesc2011/index.html","categories":[{"name":"算法竞赛","slug":"算法竞赛","permalink":"http://suzhouxing.github.io/techive/categories/算法竞赛/"}],"tags":[{"name":"算法竞赛","slug":"算法竞赛","permalink":"http://suzhouxing.github.io/techive/tags/算法竞赛/"},{"name":"组合优化","slug":"组合优化","permalink":"http://suzhouxing.github.io/techive/tags/组合优化/"},{"name":"运筹优化","slug":"运筹优化","permalink":"http://suzhouxing.github.io/techive/tags/运筹优化/"},{"name":"网址导航","slug":"网址导航","permalink":"http://suzhouxing.github.io/techive/tags/网址导航/"}]},{"title":"再谈统一建模语言与通用求解器","slug":"GeneralSolver","date":"2021-09-01T12:03:58.000Z","updated":"2021-09-16T12:56:57.744Z","comments":true,"path":"2021/09/01/GeneralSolver/","link":"","permalink":"http://suzhouxing.github.io/techive/2021/09/01/GeneralSolver/","excerpt":"","text":"多年以前曾经有过一段与统一建模语言与通用求解器相关的意识流 (数据库中的搜索, 组合优化问题的搜索, 统一建模语言与通用求解器). 最近机缘巧合, 又遇到了这个话题, 于是又做了进一步的思考. 总的来说, 如果能设计一个能与针对特定问题的专用算法相媲美的通用求解器, 无论是精确还是近似, 其实际应用价值不亚于证明 P = NP. 可惜, 天上不会掉馅饼, 一个高价值的问题, 难度往往也不会低. 我们需要什么样的通用求解器? 如果说好奇心驱使人类进行科学探索, 那么, 懒, 则是人类发展技术的动力源泉. \"复用\" 是软件工程的核心思想之一, 说白了就是懒, 不想做别人甚至自己早就做过的工作. 在求解组合优化问题时, 我们当然也希望充分利用现有的研究成果. 算法设计中有很多平衡, 在这里, 我们关注的是算法的开发难度和结果优度之间的平衡, 以及开发效率和运行效率之间的平衡. 通用求解器的美好愿景是, 我们只用向计算机描述我们的问题, 它便能自动求出最优解. 然而, 其最大的问题就是如何向计算机描述我们的需求. 计算机往往只能接受形式化的语言, 即程序设计语言. 相比于命令式的编程语言, 声明式的编程语言更适合用于数学建模. 它们仅用于陈述事实, 所有声明是平行的, 需要被同时满足, 而不像命令式编程语言描述事件和操作的先后顺序. 不幸的是, 用数学语言形式化地描述问题对很多人来说都是一件十分困难的事情. 毕竟, 很多人用自然语言都无法清晰地描述需求, 定义问题. 简洁的建模语言入门容易, 但表达能力往往较弱, 十分考验使用者的经验与技巧. 复杂的建模语言表达能力强, 但学习成本也十分高昂. 如果既简洁又强大的建模语言真的存在, 大概率又会难以绕开自然语言的问题, 即二义性. 另一方面, 通用算法想要识别问题结构, 然后进行针对性处理是非常困难的. 然而, 且不说不同问题, 即使是同一个问题, 面对不同特性的测试用例, 不同算法的性能也有天壤之别. 比如, 拿最短简单路径这种教科书级别的 P 问题来举例: 若所有边权重相同, 则可以直接用广度优先搜索进行求解; 若在平面图上, 可以用欧氏距离作为启发函数使用 A* 算法高效求解; 若在网格上, 可以有更多基于地标和可达范围的加速策略... 如果能给计算机一些提示, 使其能够利用问题结构的信息, 将对求解效率产生十分积极的影响. 几个通用求解器的技术路线 数学规划 以 Gurobi 和 CPLEX 为代表的数学规划求解器, 主要基于线性规划求得线性松弛, 再基于线性松弛进行树搜索. 以个人经验来看, 虽然很多求解器还支持特殊形式的二次规划 (QP), 但其表达能力和求解效果往往不如混合整数规划 (MIP), 故此处仅讨论后者. 数学规划可以适应离散优化与连续优化相结合的场景, 表达能力足以支撑生产生活中绝大多数组合优化问题的建模. 但是, 正如 Harold Hotelling 的 \"名言\", \"But we all know the world is nonlinear\", 大量组合优化问题无法直接用 MIP 等建模语言进行描述. 最简单的情形便是 \"逻辑或\" 的关系, MIP 要求所有约束同时满足, 即 \"逻辑与\" 的关系, 所有约束对应的超平面将解空间切成一个单纯形 (凸多胞形) 构成可行解空间, \"逻辑或\" 会使可行解空间产生凹陷. 我们需要添加布尔类型的辅助变量进行升维, 使用 Big-M 的技巧, 将线性不可分的解空间转换为线性可分的, 将逻辑约束转述为代数约束. 进行上述处理后, 问题结构往往变得高度非线性, 不同的转换方式会不同程度地丢失问题的结构信息, 导致求解效果不够理想, 以至于最短路径或最小生成树之类的 P 问题求解速度往往也难以接受. SAT/MaxSAT/SMT 以 MiniSAT 及其衍生出的众多开源求解器为代表的通用求解器, 主要基于问题之间普遍存在可以相互归约/转换的关系, 通过一定的编码技巧将各类约束统一表达为布尔表达式. 与数学规划方法基于代数理论以连续优化为切入点不同, SAT/MaxSAT/SMT 方法的重心在逻辑推理, 直接面向离散优化. 由于 NP 完全问题之间普遍存在的可归约性, SAT 问题作为第一个 NP 完全问题, 其求解器理论上可以求解所有 NP 完全问题. 然而, NP 完全问题只是所有组合优化问题中一个很小的子集, 即使扩展到了 MaxSAT, 表达能力也十分有限而充满技巧性. 例如, 在数学规划中十分基础的 \\(a + b \\le c\\) 的约束, 要编码成 SAT 算例甚至类似于设计一个包含加法器和比较器的电路. 当然, 更进一步发展到 Satisfiability Modulo Theories (SMT) 之后, 表达能力产生了质的飞跃, 但从其目前的受欢迎程度来看 (我并没有使用过 SMT), 求解效率似乎也随之发生了质的跌落... 约束编程 以 MiniZinc 为代表的约束编程求解器, 其实现主要基于树搜索算法. 约束编程中各式各样的约束类型十分丰富, 表达能力很强, 乍一看好像和 SMT 很接近, 但是由于研究不多, 在此不做过多评价. 个人感觉约束编程中对很多常见的约束类型进行了封装或者模板化, 在简化调用代码的同时可以完整地呈现问题结构, 而不是以被使用者打散的状态出现. 做个不恰当的类比, 我们在描述一块砖的受到的重力时, 正常人都是用整块砖的质量乘以地表重力加速度, 而不是考虑砖里面每个原子的受到的万有引力以及原子间的相互作用. 比如在排序问题中, 我们需要给每个元素安排一个序号, 所有序号互不相同, 学过排序算法的都知道, 我们每次只交换两个元素就不会违反这个互不相同 (all-different) 约束. 但是如果使用者给出了 \\(n^{2}\\) 条约束, 告诉求解器任意两个元素的序号不相等, 那么求解器就需要经过一系列约束推理 (传播) 才能发现, 修改了 A 的序号之后, 必须把另一个元素的序号改成 A 原来的序号才行. 如果建模语言直接支持一类 all-different 约束, 则可以保留这种结构信息. 当然, 与其丰富的特性相对应地, 其学习成本也不见得比学习一门编程语言以及启发式算法的基本思想低多少. 有意思的是, 物理学家们努力在寻找大统一理论来解释所有相互作用, 虽然似乎目前进展不太顺利. 局部搜索 以 LocalSolver 为代表的基于局部搜索的通用求解器. 局部搜索算法与人的求解过程十分相似, 都是从初始解出发, 不断对当前解进行修改, 只对搜索路径或上下文信息进行有限的记录. 对于约束较少的优化问题, 局部搜索具有极高的适应性. 例如, 以最小化问题为例, 局部搜索关注上界, 是真实可行的解的目标函数值, 因此更符合实际需求. 而树搜索为了确保最优性, 关注的往往是下界, 是理论上最优解的目标函数值, 其实努力方向稍微有点走偏了. 然而, 局部搜索算法的设计是高度依赖问题结构的, 算法性能的关键一方面是邻域动作, 即每次如何修改当前解, 另一方面是邻域范围, 即每次评估哪些邻域动作. 如果只是对解向量进行任意的修改, 可能会浪费大量时间在无效的动作上. 以前面的 all-different 约束为例, 改变一个元素的序号后, 下一步可以把 n 个元素的序号更改为 1 到 n 中的任意一个, 共有 \\(n^{2}\\) 个动作, 但其实只有一个能得到可行解. 因此, 个人对于基于局部搜索的 \"傻瓜式\" \"即开即用\" 的通用求解器持相对悲观的态度, 不进行定制化将难以发挥局部搜索算法的强大威力. 算法库 以 COIN-OR 和 dlib 为代表的算法库. 主要基于问题之间普遍存在可以分解/组合的关系, 由算法设计者对各种子算法进行组合形成完整问题的求解算法. 使用算法库与基于 SAT/MaxSAT/SMT 构建通用求解器在思路上十分相似, 但从另一个角度看又是两个极端. 算法库几乎将算法设计的压力全部扔给了使用者, 甚至可以说这条技术路线完全没有超出软件工程的范畴. 而已知算法庞大的数量将极大地限制其可用性, 屠龙勇士最终往往会成为新的恶龙. 我已经有过类似的经历, 需要使用一个经典算法时, 发现很多第三方库中都有, 但是为了用一个简单的算法, 需要把整个庞大的工程集成到我的代码中, 感觉十分繁琐. 同时, 这些算法为了支持多种多样的应用场景往往会有很复杂的参数控制算法的行为, 即使我只需要最基础的功能, 我也得花大量时间仔细研究使用说明. 于是我决定自己重新实现一下, 并在以后的使用中日积月累, 功能越来越强大. 直到有一天, 我向学弟学妹们推销我那瑞士军刀般的算法库时, 大家都望而却步, 我才发现, 我的 \"杰作\" 已经成为了自己曾经不屑一顾的东西... 当然我们也不必过于悲观, 在特定领域中算法库应该还是有其用武之地的. 事实上, 基于数学规划的方法为我们提供了一些思路, 比如行生成 (惰性约束) 和列生成 (分支定价) 框架就是典型案例, 其子问题往往是个很简单的 P 问题, 可以由算法库提供支撑. 更通用地, 我们可以用函数式的编程范式对算法进行组合, 例如, 上层问题每找到一个可行解 (大格局), 就调用回调函数进行下层问题的求解 (完整解), 然后将完整解的可行性和优度反馈给上层, 上层根据反馈结果开展进一步搜索. 算法框架 以 SCIP 和 EasyLocal 为代表的算法框架. 说白了还是软件工程, 提取算法中公共的重复的部分, 将需要定制化的部分开放出来 (当然也可以提供默认的实现以提高易用性), 可以用于任何方法学. 对现有的框架了解不多, 自己设想的框架还在规划中, 在此不展开讨论. 能够指导求解的统一建模语言 前面反复提到 \"问题结构\" 这个词, 它到底是个什么东西? 到底能为求解带来多大的好处? 其实我自己也没想清楚, 只有两个模糊的思路. 一方面, 如果我们按某种策略对解空间进行探索, 那么有些约束将自然满足, 根本不用考虑, 不用专门添加约束加以限制. 比如对于 SAT 问题, 我们默认同一个变元在所有子句中的取值是完全一致的, 就是一种很自然的约束, 在满足这个约束的基础上去寻找满足所有子句的变元取值. 事实上, 我们还可以进行完全不同的建模, 比如要求所有子句必须都满足, 然后最大化同一变元在不同子句中的一致性, 其求解效果可能有天壤之别, 但求解器很难知道还有另一个等价的可以高效求解的模型. 另一方面, 如果我们按某种策略对解空间进行探索, 一旦探索过某些特定的子结构, 则可以排除一部分解空间包含更优解的可能性. 这个思路在 P 问题的求解中应用尤为广泛, 在 NP 问题中也较为常见, 比如动态规划的最优子结构, 树搜索的剪枝策略等等. 我是研究元启发式算法的, 下面我还是以我的老本行为切入点, 探讨一下在建模层面为求解算法提供指导的可能性. 前面提到, 影响局部搜索算法求解效果最关键的两个因素是邻域动作和邻域范围, 除此之外, 如何高效地增量评估邻居解的目标函数值, 以及如何近似评估目标函数值, 都是局部搜索中的重要问题. 指导求解的统一建模语言, 至少可以从这几个方面入手. 邻域动作 \"启发式\" 的含义即借鉴人与自然的经验. 局部搜索其实十分自然, 就像人在解决问题一样, 先做个差不多的方案, 然后左调调右调调, 看看能不能改出一个更好的方案. 因此, 定义邻域动作其实并不比数学规划或约束编程复杂. 而合理的邻域动作定义, 可以充分利用问题结构, 省略部分十分自然的约束. 比如集合覆盖, 如果邻域动作是交换两个集合的选中状态, 则无需添加选中集合数量约束. 用形式化的语言描述, 令所有子集的集合为 \\(S\\), 选中的子集集合为 \\(X\\), 交换邻域动作可以定义为 \\(M = \\{ X \\leftarrow X \\cup \\{ p \\} \\setminus \\{ q \\} | p \\in S \\setminus X, q \\in X \\}\\). 邻域范围 定义邻域范围其实也只涉及简单的集合定义, 甚至没有超出高中数学的范畴. 合理的邻域范围定义, 可以充分利用问题结构, 避免评估毫无希望的邻域动作, 或者适当缩小邻域对单位评估改进量 (评估的邻域解数量 / 最优邻域动作目标函数值改进量) 进行平衡. 比如作业车间调度, 相比于任意调整同机器上两个工序的先后顺序, 高效的邻域范围往往会针对关键路径上的工序, 因为其他工序的顺序调整无法直接缩短完工时间. 再次以集合覆盖为例, 每个交换动作中新增子集时, 相比于从所有未选中集合中挑选一个, 高效的邻域范围可以是随机选中一个未覆盖元素, 尝试添加一个能够覆盖该元素的集合. 用形式化的语言描述, 令所有子集的集合为 \\(S\\), 选中的子集集合为 \\(X\\), 子集 \\(s\\) 可覆盖的元素集合为 \\(C_{s}\\), 可覆盖元素 \\(e\\) 的子集集合为 \\(B_{e}\\), 未覆盖元素集合 \\(U(X) = \\bigcup_{s \\in S} C_{s} \\setminus \\bigcup_{s \\in X} C_{s}\\). 精简的交换邻域可以定义为 \\(N = \\{ X \\leftarrow X \\cup \\{ p \\} \\setminus \\{ q \\} | \\exists e \\in U(X), \\forall p \\in B_{e}, \\forall q \\in X \\}\\). 注意, 这里的符号使用可能不太严谨, 我们用存在量词 \\(\\exists\\) 表示从集合中随机选取一个元素, 还应进一步规范化. 增量评估 通用的增量评估虽然可行, 但其效率往往难以达到极致. 很多时候我们需要在更新代价和查询代价之间进行平衡, 往往需要一个中间数据结构实现辅助计算. 我们可以定义辅助查找表, 定义每轮迭代时目标函数如何通过这个查找表进行计算, 然后执行完邻域动作后查找表中的相关数据如何更新, 来提高评估效率. 近似评估 对于相对复杂的问题, 往往增量评估的代价都十分巨大, 此时我们需要使用近似评估策略, 筛选出若干较有潜力的解, 然后对其进行精确评估选出真正的最优动作. 近似评估其实于邻域范围有些许重叠, 邻域范围相当于可以在 O(1) 时间内完成的近似评估, 直接筛掉没有改进潜力的动作. 当然, 近似评估除了由人根据经验定义, 也完全有可能实现通用化和智能化, 即使用机器学习的技术, 进行函数逼近, 自动学习出一个开销很小的函数来模拟真实的目标函数. 总结 通用求解器是一个美好的愿景, 基于局部搜索的通用求解器更是十分有吸引力的方向. 而局部搜索的优势在于其对问题结构的把握, 丧失了问题结构的指引, 局部搜索的效果必然大打折扣. 因此, 个人认为, 我们在统一建模语言的基础上, 适当加入算法设计的提示信息, 对算法进行合理引导, 应该是比较有前景的技术路线.","categories":[{"name":"技术","slug":"技术","permalink":"http://suzhouxing.github.io/techive/categories/技术/"}],"tags":[{"name":"技术","slug":"技术","permalink":"http://suzhouxing.github.io/techive/tags/技术/"},{"name":"运筹优化","slug":"运筹优化","permalink":"http://suzhouxing.github.io/techive/tags/运筹优化/"},{"name":"建模","slug":"建模","permalink":"http://suzhouxing.github.io/techive/tags/建模/"},{"name":"通用求解器","slug":"通用求解器","permalink":"http://suzhouxing.github.io/techive/tags/通用求解器/"}]},{"title":"SmartLab Challenge 2021 - Rectangle Packing","slug":"Contest-2021RectPacking","date":"2021-07-10T09:21:42.000Z","updated":"2021-09-30T12:49:27.444Z","comments":true,"path":"2021/07/10/Contest-2021RectPacking/","link":"","permalink":"http://suzhouxing.github.io/techive/2021/07/10/Contest-2021RectPacking/","excerpt":"","text":"矩形装箱问题是物流运输, 芯片制造与游戏开发等领域中的重要问题, 应用场景十分广泛. 矩形装箱问题主要研究如何将一系列矩形块不重叠地摆放至矩形容器中, 使得容器最的面积最小的问题. 比如玻璃制造过程中, 要在原料 (大矩形) 上进行切割得到一系列成品 (小矩形). 比如在集成电路的物理设计中, 需要用最小的面积排布大量宏单元和标准单元以节约成本. 比如在游戏贴图加载时, 需要将若干矩形图片拼合成大块的矩形图像以充分发挥显存性能. 因此, 高效的矩形装箱问题的求解算法具有极其重要的理论与应用价值. 矩形装箱算法训练 问题概述 给定一系列长宽固定的矩形块, 可以旋转 0 或 90 度, 请确定每个矩形块的左下角坐标, 使得在所有矩形块不重叠的情况下, 包络所有矩形块的矩形区域面积最小. 参考文献. [1] L. Wei, W.-C. Oon, W. Zhu, and A. Lim, “A skyline heuristic for the 2D rectangular packing and strip packing problems,” European Journal of Operational Research, vol. 215, no. 2, pp. 337–346, 2011, doi: 10.1016/j.ejor.2011.06.022. [2] L. Wei, T. Tian, W. Zhu, and A. Lim, “A block-based layer building approach for the 2D guillotine strip packing problem,” European Journal of Operational Research, vol. 239, no. 1, pp. 58–69, 2014, doi: 10.1016/j.ejor.2014.04.020. [3] K. He, P. Ji, and C. Li, “Dynamic reduction heuristics for the rectangle packing area minimization problem,” European Journal of Operational Research, vol. 241, no. 3, pp. 674–685, 2015, doi: 10.1016/j.ejor.2014.09.042. [4] L. Wei, Q. Hu, S. C. H. Leung, and N. Zhang, “An improved skyline based heuristic for the 2D strip packing problem and its efficient implementation,” Computers &amp; Operations Research, vol. 80, pp. 113–127, 2017, doi: 10.1016/j.cor.2016.11.024. [5] K. He, H. Yang, Y. Jin, Q. Hu, and P. Ji, “The Orthogonal Packing and Scheduling Problem: Model, Heuristic, and Benchmark,” IEEE Transactions on Systems, Man, and Cybernetics: Systems, vol. 50, no. 4, pp. 1372–1383, Apr. 2020, doi: 10.1109/TSMC.2017.2768072. [6] P. Ji, K. He, Z. Wang, Y. Jin, and J. Wu, “A Quasi-Newton-based Floorplanner for fixed-outline floorplanning,” Computers &amp; Operations Research, vol. 129, p. 105225, 2021, doi: 10.1016/j.cor.2021.105225. 命令行参数 请大家编写程序时支持两个命令行参数, 依次为运行时间上限 (单位为秒) 和随机种子 (0-65535). 算例文件已重定向至标准输入 stdin/cin, 标准输出 stdout/cout 已重定向至解文件 (如需打印调试信息, 请使用标准错误输出 stderr/cerr). 例如, 在控制台运行以下命令表示调用可执行文件 packing.exe 在限时 300 秒, 随机种子为 12345 的情况下求解路径为 ../data/gsrc.b10a221679.txt 的算例, 解文件输出至 sln.gsrc.b10a221679.txt: 1packing.exe 300 123456 &lt;../data/gsrc.b10a221679.txt &gt;sln.gsrc.b10a221679.txt 运行时间上限. 超出运行时间上限后测试程序会强行终止算法, 请确保在此之前已输出解 (最好还能自行正常退出). 随机种子设置. 使用 C 语言随机数生成器请用 srand. 使用 C++ 随机数生成器 (如 mt19937) 请在构造时传参或调用 seed() 方法设置. 输入的算例文件格式 所有算例的矩形块均从 0 开始连续编号. 第一行给出一个整数 N, 表示矩形块的数量. 接下来连续 N 行, 每行包含两个由空白字符分隔的整数, 表示矩形块的长和宽 (不发生旋转的情况下，长度对应横坐标，宽度对应纵坐标). 例如, 以下算例文件表示需放置 4 个矩形块; 其中, 矩形块 0 的长为 1 宽为 3; 矩形块 1 的长为 3 宽为 1; 矩形块 2 的长为 2 宽为 2; 矩形块 3 的长为 2 宽为 2: 1234541 33 12 22 2 输出的解文件格式 输出 N 行整数表示 N 个矩形块的放置情况, 第 i 行表示第 i 个矩形块的左下角坐标和旋转情况. 每行第一个整数为第 i 个矩形块的左下角横坐标, 第二个整数为第 i 个矩形块的左下角纵坐标, 第三个整数为第 i 个矩形块的旋转度数 (必须为 0 或 90). 例如, 以下解文件表示 4 个矩形块的放置情况; 其中, 矩形块 0 的左下角坐标为 (0, 0), 不旋转; 矩形块 1 的左下角坐标为 (1, 0), 旋转 90 度; 矩形块 2 的左下角坐标为 (2, 0), 不旋转; 矩形块 3 的左下角坐标为 (2, 2), 不旋转: 12340 0 01 0 902 0 02 2 0 提交要求 发送至邮箱 szx@duhe.tech. 邮件标题格式为 \"Challenge2021RPP-姓名-学校-专业\". 邮件附件为单个压缩包 (文件大小 2M 以内), 文件名为 \"姓名-学校-专业\", 其内包含下列文件. 必要 算法的可执行文件 (Windows 平台). 建议基于官方 SDK 开发 (https://gitee.com/suzhouxing/npbenchmark/tree/main/SDK.RPP). 用 g++ 的同学编译时请静态链接, 即添加 -static-libgcc -static-libstdc++ 编译选项. 必要 算法源码. 可重入 (可在同一线程内反复调用而不会出现数据初始化错误或内存泄漏). 可并发 (可在同一进程内的多个线程同时运行多个算法求解实例而互不干扰, 满足此要求一般不能有全局的非只读变量). 可伸缩 (数据结构可以根据算例规模动态申请内存, 而非根据预先指定的编译期常量进行内存分配). 可选 算法在各算例上的运行情况概要, 至少包括以下几项信息 (可选, 仅在无法成功调用算法输出可通过检查程序的解时作为参考). 算例名. 剩余未覆盖元素数. 计算耗时. 可选 算法在各算例上求得的完全覆盖的解文件 (可选, 仅在无法成功调用算法输出可通过检查程序的解时作为参考). 若成功提交, 在收到邮件时以及测试完成后系统均会自动发送邮件反馈提交情况. 若测试结果较优, 可在排行榜页面看到自己的运行情况 (https://gitee.com/suzhouxing/npbenchmark/tree/data). 例如: 12345678910111213苏宙行-华科-计科.zip| packing.exe| results.csv|+---src| main.cpp| algorithm.cpp| algorithm.h|+---results gsrc.b10a221679.txt gsrc.b30a208591.txt ... 算例清单 下载地址: https://gitee.com/suzhouxing/npbenchmark/tree/data/RPP/Instance gsrc.b10a221679 gsrc.b30a208591 gsrc.b50a198579 gsrc.b100a179501 gsrc.b200a175696 gsrc.b300a273170 mcnc.ami33.b33a1156449 mcnc.ami49.b49a35445424 mcnc.apte.b9a46561628 mcnc.hp.b11a8830584 mcnc.xerox.b10a19350296","categories":[{"name":"算法挑战","slug":"算法挑战","permalink":"http://suzhouxing.github.io/techive/categories/算法挑战/"}],"tags":[{"name":"组合优化","slug":"组合优化","permalink":"http://suzhouxing.github.io/techive/tags/组合优化/"},{"name":"算法挑战","slug":"算法挑战","permalink":"http://suzhouxing.github.io/techive/tags/算法挑战/"}]},{"title":"SmartLab Challenge 2021 - Routing and Wavelength Assignment","slug":"Contest-2021RWA","date":"2021-07-10T09:20:58.000Z","updated":"2021-09-29T12:20:46.074Z","comments":true,"path":"2021/07/10/Contest-2021RWA/","link":"","permalink":"http://suzhouxing.github.io/techive/2021/07/10/Contest-2021RWA/","excerpt":"","text":"路由与波长分配问题是通信领域中的重要问题, 具有较高的实际应用价值. 路由与波长分配问题主要研究如何为通信业务规划传输路径并分配波长, 使得所有业务可以在互不干扰的情况下传输. 高效的路由与波长分配问题的求解算法对提高网络的传输效率具有意义重大. 同时, 路由与波长分配问题还与多智能体路径规划以及芯片布线十分相似, 具有重要的理论意义. 路由与波长分配算法训练 问题概述 给定一个有向图, 以及一系列通信业务, 每个通信业务有固定的起点和终点. 请为每个通信业务规划一条传输路径, 并为其分配一个波长, 在确保每条有向边上经过的所有业务波长互不相同的前提下, 最小化使用的波长数. 参考文献. [1] Y. Fang, Z. Lü, Z. Su, Y. Wang, T. Zhang, and Q. Zhang, “Local Search based on a New Neighborhood for Routing and Wavelength Assignment,” in 2020 IEEE International Conference on Systems, Man, and Cybernetics (SMC), 2020, pp. 1123–1128. doi: 10.1109/SMC42975.2020.9283031. 命令行参数 请大家编写程序时支持两个命令行参数, 依次为运行时间上限 (单位为秒) 和随机种子 (0-65535). 算例文件已重定向至标准输入 stdin/cin, 标准输出 stdout/cout 已重定向至解文件 (如需打印调试信息, 请使用标准错误输出 stderr/cerr). 例如, 在控制台运行以下命令表示调用可执行文件 rwa.exe 在限时 300 秒, 随机种子为 12345 的情况下求解路径为 ../data/ATT.n90e274t359.txt 的算例, 解文件输出至 sln.ATT.n90e274t359.txt: 1rwa.exe 300 123456 &lt;../data/ATT.n90e274t359.txt &gt;sln.ATT.n90e274t359.txt 运行时间上限. 超出运行时间上限后测试程序会强行终止算法, 请确保在此之前已输出解 (最好还能自行正常退出). 随机种子设置. 使用 C 语言随机数生成器请用 srand. 使用 C++ 随机数生成器 (如 mt19937) 请在构造时传参或调用 seed() 方法设置. 输入的算例文件格式 所有算例的节点从 0 开始连续编号. 第一行给出三个由空白字符分隔的整数, 分别表示节点数 N, 有向边数 E, 以及通信业务数 T. 接下来连续 E 行, 每行包含两个由空白字符分隔的整数, 第 i 行表示第 i 条有向边的源点和宿点. 接下来连续 T 行, 每行包含两个由空白字符分隔的整数, 第 i 行表示第 i 个通信业务的起点和终点. 例如, 以下算例文件表示在 4 个节点和 5 条有向边的有向图上传输 3 个通信业务; 其中, 有向图包含 0, 1, 2, 3 共 4 个节点以及 0-1, 1-2, 2-3, 3-0, 1-0 共 4 条有向边, 通信业务 0 的起点为 0 终点为 1, 通信业务 1 的起点为 1 终点为 0, 通信业务 2 的起点为 1 终点为 3: 1234567894 5 30 11 22 33 01 00 11 01 3 输出的解文件格式 输出 T 行整数表示 T 个通信业务的传输方案, 第 i 行表示第 i 个通信业务的波长分配和传输路径. 每行第一个整数表示第 i 个通信业务使用的波长, 第二个整数表示传输路径上的节点数, 随后连续 P 个由空白字符分隔的整数表示传输路径上依次经过的节点. 波长可以取 int 范围内任意整数, 检查程序自动统计不同的整数的数量. 传输路径上的节点若不包含通信业务的起点和终点, 检查程序将自动将其添加至路径中. 例如, 以下解文件表示 3 个通信业务的波长分配和传输路径; 其中, 通信业务 0 使用的波长为 1, 依次经过节点 0 和 1; 通信业务 1 使用的波长为 1, 直接从起点 1 到达终点 0; 通信业务 2 使用的波长为 0, 依次经过节点 1 和 2, 最后到达终点 3: 1231 2 0 11 00 2 1 2 提交要求 发送至邮箱 szx@duhe.tech. 邮件标题格式为 \"Challenge2021RWA-姓名-学校-专业\". 邮件附件为单个压缩包 (文件大小 2M 以内), 文件名为 \"姓名-学校-专业\", 其内包含下列文件. 必要 算法的可执行文件 (Windows 平台). 建议基于官方 SDK 开发 (https://gitee.com/suzhouxing/npbenchmark/tree/main/SDK.RWA). 用 g++ 的同学编译时请静态链接, 即添加 -static-libgcc -static-libstdc++ 编译选项. 必要 算法源码. 可重入 (可在同一线程内反复调用而不会出现数据初始化错误或内存泄漏). 可并发 (可在同一进程内的多个线程同时运行多个算法求解实例而互不干扰, 满足此要求一般不能有全局的非只读变量). 可伸缩 (数据结构可以根据算例规模动态申请内存, 而非根据预先指定的编译期常量进行内存分配). 可选 算法在各算例上的运行情况概要, 至少包括以下几项信息 (可选, 仅在无法成功调用算法输出可通过检查程序的解时作为参考). 算例名. 使用的波长数. 计算耗时. 可选 算法在各算例上求得的使用波长数最少的解文件 (可选, 仅在无法成功调用算法输出可通过检查程序的解时作为参考). 若成功提交, 在收到邮件时以及测试完成后系统均会自动发送邮件反馈提交情况. 若测试结果较优, 可在排行榜页面看到自己的运行情况 (https://gitee.com/suzhouxing/npbenchmark/tree/data). 例如: 12345678910111213苏宙行-华科-计科.zip| rwa.exe| results.csv|+---src| main.cpp| algorithm.cpp| algorithm.h|+---results ATT.n90e274t359.txt ATT2.n71e350t2918.txt ... 算例清单 下载地址: https://gitee.com/suzhouxing/npbenchmark/tree/data/RWA/Instance 算例规模从小到大依次为 (求解难度不一定随规模增加, 但除 Z* 以外的算例应该都很容易求解): ATT.n90e274t359 ATT2.n71e350t2918 Brasil.n27e140t1370 EON.n20e78t373 Finland.n31e102t930 NSF-01.n14e42t284 NSF-03.n14e42t285 NSF-12.n14e42t551 NSF-48.n14e42t547 NSF2-01.n14e44t284 NSF2-03.n14e44t285 NSF2-12.n14e44t551 NSF2-48.n14e44t547 Y3-020-1.n100e344t1975 Y3-020-2.n100e368t1961 Y3-020-3.n100e356t2055 Y3-020-4.n100e354t1989 Y3-020-5.n100e350t1975 Y3-040-1.n100e344t3894 Y3-040-2.n100e368t3956 Y3-040-3.n100e356t4012 Y3-040-4.n100e354t3959 Y3-040-5.n100e350t3996 Y3-060-1.n100e344t5967 Y3-060-2.n100e368t5907 Y3-060-3.n100e356t5989 Y3-060-4.n100e354t5932 Y3-060-5.n100e350t5990 Y3-080-1.n100e344t7959 Y3-080-2.n100e368t7911 Y3-080-3.n100e356t7987 Y3-080-4.n100e354t7908 Y3-080-5.n100e350t7924 Y3-100-1.n100e344t9900 Y3-100-2.n100e368t9900 Y3-100-3.n100e356t9900 Y3-100-4.n100e354t9900 Y3-100-5.n100e350t9900 Y4-020-1.n100e440t1975 Y4-020-2.n100e460t1961 Y4-020-3.n100e436t2055 Y4-020-4.n100e442t1989 Y4-020-5.n100e430t1975 Y4-040-1.n100e440t3894 Y4-040-2.n100e460t3956 Y4-040-3.n100e436t4012 Y4-040-4.n100e442t3959 Y4-040-5.n100e430t3996 Y4-060-1.n100e440t5967 Y4-060-2.n100e460t5907 Y4-060-3.n100e436t5989 Y4-060-4.n100e442t5932 Y4-060-5.n100e430t5990 Y4-080-1.n100e440t7959 Y4-080-2.n100e460t7911 Y4-080-3.n100e436t7987 Y4-080-4.n100e442t7908 Y4-080-5.n100e430t7924 Y4-100-1.n100e440t9900 Y4-100-2.n100e460t9900 Y4-100-3.n100e436t9900 Y4-100-4.n100e442t9900 Y4-100-5.n100e430t9900 Y5-020-1.n100e570t1975 Y5-020-2.n100e504t1961 Y5-020-3.n100e582t2055 Y5-020-4.n100e548t1989 Y5-020-5.n100e568t1975 Y5-040-1.n100e570t3894 Y5-040-2.n100e504t3956 Y5-040-3.n100e582t4012 Y5-040-4.n100e548t3959 Y5-040-5.n100e568t3996 Y5-060-1.n100e570t5967 Y5-060-2.n100e504t5907 Y5-060-3.n100e582t5989 Y5-060-4.n100e548t5932 Y5-060-5.n100e568t5990 Y5-080-1.n100e570t7959 Y5-080-2.n100e504t7911 Y5-080-3.n100e582t7987 Y5-080-4.n100e548t7908 Y5-080-5.n100e568t7924 Y5-100-1.n100e570t9900 Y5-100-2.n100e504t9900 Y5-100-3.n100e582t9900 Y5-100-4.n100e548t9900 Y5-100-5.n100e568t9900 Z04x25-020.n100e400t1975 Z04x25-040.n100e400t3894 Z04x25-060.n100e400t5967 Z04x25-080.n100e400t7959 Z04x25-100.n100e400t9900 Z05x20-020.n100e400t1975 Z05x20-040.n100e400t3894 Z05x20-060.n100e400t5967 Z05x20-080.n100e400t7959 Z05x20-100.n100e400t9900 Z06x17-020.n102e408t1975 Z06x17-040.n102e408t3894 Z06x17-060.n102e408t5967 Z06x17-080.n102e408t7959 Z06x17-100.n102e408t10302 Z08x13-020.n104e416t1975 Z08x13-040.n104e416t3894 Z08x13-060.n104e416t5967 Z08x13-080.n104e416t7959 Z08x13-100.n104e416t10712 Z10x10-020.n100e400t1975 Z10x10-040.n100e400t3894 Z10x10-060.n100e400t5967 Z10x10-080.n100e400t7959 Z10x10-100.n100e400t9900","categories":[{"name":"算法挑战","slug":"算法挑战","permalink":"http://suzhouxing.github.io/techive/categories/算法挑战/"}],"tags":[{"name":"组合优化","slug":"组合优化","permalink":"http://suzhouxing.github.io/techive/tags/组合优化/"},{"name":"算法挑战","slug":"算法挑战","permalink":"http://suzhouxing.github.io/techive/tags/算法挑战/"}]},{"title":"SmartLab Challenge 2020 - Flexible Job Shop Scheduling","slug":"Contest-2020FJSP","date":"2021-01-14T02:05:34.000Z","updated":"2021-09-29T12:21:38.832Z","comments":true,"path":"2021/01/14/Contest-2020FJSP/","link":"","permalink":"http://suzhouxing.github.io/techive/2021/01/14/Contest-2020FJSP/","excerpt":"","text":"柔性作业车间调度问题是智能制造与高性能计算等领域中的重要问题, 具有广泛应用场景. 柔性作业车间调度问题主要研究如何调度有限的资源依次执行多项任务, 使得完成所有任务的完工时间最短的问题. 比如芯片代工厂生产芯片时, 每块晶圆需要在不同机台依次完成光刻与蚀刻等多道工序. 比如在某些大规模并行计算场景中, 计算任务间存在依赖关系, 后继任务的输入为前驱任务的输出. 高效的柔性作业车间调度问题的求解算法具有极其重要的理论与应用价值. 柔性作业车间调度算法训练 问题概述 给定若干任务, 每个任务可由若干给定的机器中的任意一台花费给定的时间完成. 每个任务的全部前序任务完工后才能开工, 在不同机器间转移不消耗时间. 每台机器同一时间仅能执行一个任务且不可抢占, 即完成一个任务后才能开始下一个任务. 请确定每个任务何时在哪台机器上开工, 使得最后一个完工的任务最早完工. 柔性作业车间调度问题为上述任务调度问题的特例, 任务依赖拓扑为若干条单链. 即给定若干工件, 每个工件由一系列必须依次完成的工序组成. 参考文献. [1] J. Ding, Z. Lü, C. M. Li, L. Shen, L. Xu, and F. Glover, “A two-individual based evolutionary algorithm for the flexible job shop scheduling problem,” in Proceedings of the AAAI Conference on Artificial Intelligence, Jul. 2019, vol. 33, pp. 2262–2271. doi: 10.1609/aaai.v33i01.33012262. [2] C. Zhang, P. Li, Z. Guan, and Y. Rao, “A tabu search algorithm with a new neighborhood structure for the job shop scheduling problem,” Computers &amp; Operations Research, vol. 34, no. 11, pp. 3229–3242, 2007, doi: 10.1016/j.cor.2005.12.002. [3] M. A. González, C. R. Vela, and R. Varela, “Scatter search with path relinking for the flexible job shop scheduling problem,” European Journal of Operational Research, vol. 245, no. 1, Art. no. 1, Aug. 2015, doi: 10.1016/j.ejor.2015.02.052. 命令行参数 请大家编写程序时支持两个命令行参数, 依次为运行时间上限 (单位为秒) 和随机种子 (0-65535). 算例文件已重定向至标准输入 stdin/cin, 标准输出 stdout/cout 已重定向至解文件 (如需打印调试信息, 请使用标准错误输出 stderr/cerr). 例如, 在控制台运行以下命令表示调用可执行文件 fjsp.exe 在限时 300 秒, 随机种子为 12345 的情况下求解路径为 ../data/jsp.FT06.m6j6c1.txt 的算例, 解文件输出至 sln.jsp.FT06.m6j6c1.txt: 1fjsp.exe 300 123456 &lt;../data/jsp.FT06.m6j6c1.txt &gt;sln.jsp.FT06.m6j6c1.txt 运行时间上限. 超出运行时间上限后测试程序会强行终止算法, 请确保在此之前已输出解 (最好还能自行正常退出). 随机种子设置. 使用 C 语言随机数生成器请用 srand. 使用 C++ 随机数生成器 (如 mt19937) 请在构造时传参或调用 seed() 方法设置. 输入的算例文件格式 所有算例的任务和机器分别从 0 开始连续编号. 第一行给出三个由空白字符分隔的整数, 分别表示任务数 N, 机器数 M, 以及所有任务所有工序的最大的候选机器数 C (若 C = 1 说明该算例为 JSP 算例). 接下来连续 N 行, 第 i 行表示第 i 个任务的信息. 每行第一个整数表示第 i 个任务的工序数 K, 随后连续 K 组由空白字符分隔的数据, 第 j 组数据表示该任务的第 j 道工序的信息. 每组数据第一个整数表示可执行该工序的候选机器数 S, 随后连续 S 个由空白字符分隔的二元组, 二元组 (G, D) 表示该工序可由机器 G 执行且加工时长为 D. 例如, 以下算例文件表示有 2 个任务和 4 台机器, 每个任务至多 2 台候选机器; 其中, 任务 0 由 4 道工序构成, 其工序 0 可由机器 1 花费时长 654 完成, 其工序 1 可由机器 2 花费时长 147 完成, 其工序 2 可由机器 3 花费时长 345 完成, 其工序 3 可由机器 0 花费时长 447 完成; 任务 1 由 3 道工序构成, 其工序 0 可由机器 1 花费时长 321 完成或由机器 0 花费时长 321 完成, 其工序 1 可由机器 2 花费时长 520 完成, 其工序 2 可由机器 3 花费时长 789 完成: 1232 4 24 1 1 654 1 2 147 1 3 345 1 0 4473 2 1 321 0 321 1 2 520 1 3 789 上述算例内数据的分组情况可以更加直观地表示成下面的情况: 1232 4 24 [1 (1 654)] [1 (2 147)] [1 (3 345)] [1 (0 447)]3 [2 (1 321) (0 321)] [1 (2 520)] [1 (3 789)] 为了使算例的数据分组更加直观, 给出的算例可能会按照如下约定: 使用 4 个空格分隔每行的 K 组数据, 使用 2 个空格分隔 S 个二元组. 输出的解文件格式 输出 M 行整数表示 M 台机器的任务分配与排序情况, 第 i 行表示第 i 台机器上执行的工序的有序列表. 每一行第一个整数表示第 i 台机器加工的工序数 E, 随后连续 E 个由空白字符分隔的二元组, 二元组 (J, O) 表示加工了任务 J 的工序 O, 二元组的出现顺序表示第 i 台机器的加工顺序. 例如, 以下解文件表示 2 台机器上的任务分配与排序情况; 其中, 机器 0 执行了 3 道工序, 依次为任务 1 的工序 1, 任务 0 的工序 0, 任务 2 的工序 0; 机器 1 加工了 2 道工序, 依次为任务 0 的工序 1, 任务 1 的工序 0: 123 1 1 0 0 2 02 0 1 1 0 注意上述调度方案存在死锁, 不是可行的调度方案. 提交要求 发送至邮箱 szx@duhe.tech. 邮件标题格式为 \"Challenge2020FJSP-姓名-学校-专业\". 邮件附件为单个压缩包, 文件名为 \"姓名-学校-专业\", 其内包含下列文件. 必要 算法的可执行文件 (Windows 平台). 建议基于官方 SDK 开发 (https://gitee.com/suzhouxing/npbenchmark/tree/main/SDK.FJSP). 用 g++ 的同学编译时请静态链接, 即添加 -static-libgcc -static-libstdc++ 编译选项. 必要 算法源码. 可重入 (可在同一线程内反复调用而不会出现数据初始化错误或内存泄漏). 可并发 (可在同一进程内的多个线程同时运行多个算法求解实例而互不干扰, 满足此要求一般不能有全局的非只读变量). 可伸缩 (数据结构可以根据算例规模动态申请内存, 而非根据预先指定的编译期常量进行内存分配). 可选 算法在各算例上的运行情况概要, 至少包括以下几项信息 (可选, 仅在无法成功调用算法输出可通过检查程序的解时作为参考). 算例名. 所有任务的完工时间. 计算耗时. 可选 算法在各算例上求得的完工时间最短的解文件 (可选, 仅在无法成功调用算法输出可通过检查程序的解时作为参考). 若成功提交, 在收到邮件时以及测试完成后系统均会自动发送邮件反馈提交情况. 若测试结果较优, 可在排行榜页面看到自己的运行情况 (https://gitee.com/suzhouxing/npbenchmark/tree/data). 例如: 12345678910111213苏宙行-华科-计科.zip| fjsp.exe| results.csv|+---src| main.cpp| algorithm.cpp| algorithm.h|+---results fjsp.barnes.mt10c1.m11j10c2.txt fjsp.barnes.mt10cc.m12j10c2.txt ... 算例清单 下载地址: https://gitee.com/suzhouxing/npbenchmark/tree/data/FJSP/Instance fjsp.barnes.mt10c1.m11j10c2 fjsp.barnes.mt10cc.m12j10c2 fjsp.barnes.mt10x.m11j10c2 fjsp.barnes.mt10xx.m12j10c3 fjsp.barnes.mt10xxx.m13j10c4 fjsp.barnes.mt10xy.m12j10c2 fjsp.barnes.mt10xyz.m13j10c2 fjsp.barnes.setb4c9.m11j15c2 fjsp.barnes.setb4cc.m12j15c2 fjsp.barnes.setb4x.m11j15c2 fjsp.barnes.setb4xx.m12j15c3 fjsp.barnes.setb4xxx.m13j15c4 fjsp.barnes.setb4xy.m12j15c2 fjsp.barnes.setb4xyz.m13j15c2 fjsp.barnes.seti5c12.m16j15c2 fjsp.barnes.seti5cc.m17j15c2 fjsp.barnes.seti5x.m16j15c2 fjsp.barnes.seti5xx.m17j15c3 fjsp.barnes.seti5xxx.m18j15c4 fjsp.barnes.seti5xy.m17j15c2 fjsp.barnes.seti5xyz.m18j15c2 fjsp.brandimarte.Mk01.m6j10c3 fjsp.brandimarte.Mk02.m6j10c6 fjsp.brandimarte.Mk03.m8j15c5 fjsp.brandimarte.Mk04.m8j15c3 fjsp.brandimarte.Mk05.m4j15c2 fjsp.brandimarte.Mk06.m15j10c5 fjsp.brandimarte.Mk07.m5j20c5 fjsp.brandimarte.Mk08.m10j20c2 fjsp.brandimarte.Mk09.m10j20c5 fjsp.brandimarte.Mk10.m15j20c5 fjsp.dauzere.01a.m5j10c3 fjsp.dauzere.02a.m5j10c4 fjsp.dauzere.03a.m5j10c5 fjsp.dauzere.04a.m5j10c3 fjsp.dauzere.05a.m5j10c4 fjsp.dauzere.06a.m5j10c5 fjsp.dauzere.07a.m8j15c4 fjsp.dauzere.08a.m8j15c6 fjsp.dauzere.09a.m8j15c8 fjsp.dauzere.10a.m8j15c4 fjsp.dauzere.11a.m8j15c6 fjsp.dauzere.12a.m8j15c8 fjsp.dauzere.13a.m10j20c4 fjsp.dauzere.14a.m10j20c7 fjsp.dauzere.15a.m10j20c10 fjsp.dauzere.16a.m10j20c4 fjsp.dauzere.17a.m10j20c7 fjsp.dauzere.18a.m10j20c10 fjsp.hurink.edata-abz5.m10j10c2 fjsp.hurink.edata-abz6.m10j10c2 fjsp.hurink.edata-abz7.m15j20c3 fjsp.hurink.edata-abz8.m15j20c3 fjsp.hurink.edata-abz9.m15j20c3 fjsp.hurink.edata-car1.m5j11c2 fjsp.hurink.edata-car2.m4j13c2 fjsp.hurink.edata-car3.m5j12c2 fjsp.hurink.edata-car4.m4j14c2 fjsp.hurink.edata-car5.m6j10c2 fjsp.hurink.edata-car6.m9j8c2 fjsp.hurink.edata-car7.m7j7c2 fjsp.hurink.edata-car8.m8j8c2 fjsp.hurink.edata-la01.m5j10c2 fjsp.hurink.edata-la02.m5j10c2 fjsp.hurink.edata-la03.m5j10c2 fjsp.hurink.edata-la04.m5j10c2 fjsp.hurink.edata-la05.m5j10c2 fjsp.hurink.edata-la06.m5j15c2 fjsp.hurink.edata-la07.m5j15c2 fjsp.hurink.edata-la08.m5j15c2 fjsp.hurink.edata-la09.m5j15c2 fjsp.hurink.edata-la10.m5j15c2 fjsp.hurink.edata-la11.m5j20c2 fjsp.hurink.edata-la12.m5j20c2 fjsp.hurink.edata-la13.m5j20c2 fjsp.hurink.edata-la14.m5j20c2 fjsp.hurink.edata-la15.m5j20c2 fjsp.hurink.edata-la16.m10j10c2 fjsp.hurink.edata-la17.m10j10c2 fjsp.hurink.edata-la18.m10j10c2 fjsp.hurink.edata-la19.m10j10c2 fjsp.hurink.edata-la20.m10j10c2 fjsp.hurink.edata-la21.m10j15c3 fjsp.hurink.edata-la22.m10j15c3 fjsp.hurink.edata-la23.m10j15c2 fjsp.hurink.edata-la24.m10j15c3 fjsp.hurink.edata-la25.m10j15c3 fjsp.hurink.edata-la26.m10j20c3 fjsp.hurink.edata-la27.m10j20c3 fjsp.hurink.edata-la28.m10j20c3 fjsp.hurink.edata-la29.m10j20c3 fjsp.hurink.edata-la30.m10j20c3 fjsp.hurink.edata-la31.m10j30c3 fjsp.hurink.edata-la32.m10j30c3 fjsp.hurink.edata-la33.m10j30c2 fjsp.hurink.edata-la34.m10j30c3 fjsp.hurink.edata-la35.m10j30c2 fjsp.hurink.edata-la36.m15j15c3 fjsp.hurink.edata-la37.m15j15c3 fjsp.hurink.edata-la38.m15j15c3 fjsp.hurink.edata-la39.m15j15c3 fjsp.hurink.edata-la40.m15j15c3 fjsp.hurink.edata-mt06.m6j6c2 fjsp.hurink.edata-mt10.m10j10c2 fjsp.hurink.edata-mt20.m5j20c2 fjsp.hurink.edata-orb01.m10j10c2 fjsp.hurink.edata-orb02.m10j10c2 fjsp.hurink.edata-orb03.m10j10c2 fjsp.hurink.edata-orb04.m10j10c2 fjsp.hurink.edata-orb05.m10j10c2 fjsp.hurink.edata-orb06.m10j10c2 fjsp.hurink.edata-orb07.m10j10c2 fjsp.hurink.edata-orb08.m10j10c2 fjsp.hurink.edata-orb09.m10j10c2 fjsp.hurink.edata-orb10.m10j10c2 fjsp.hurink.rdata-abz5.m10j10c3 fjsp.hurink.rdata-abz6.m10j10c3 fjsp.hurink.rdata-abz7.m15j20c3 fjsp.hurink.rdata-abz8.m15j20c3 fjsp.hurink.rdata-abz9.m15j20c3 fjsp.hurink.rdata-car1.m5j11c3 fjsp.hurink.rdata-car2.m4j13c3 fjsp.hurink.rdata-car3.m5j12c3 fjsp.hurink.rdata-car4.m4j14c3 fjsp.hurink.rdata-car5.m6j10c3 fjsp.hurink.rdata-car6.m9j8c3 fjsp.hurink.rdata-car7.m7j7c3 fjsp.hurink.rdata-car8.m8j8c3 fjsp.hurink.rdata-la01.m5j10c3 fjsp.hurink.rdata-la02.m5j10c3 fjsp.hurink.rdata-la03.m5j10c3 fjsp.hurink.rdata-la04.m5j10c3 fjsp.hurink.rdata-la05.m5j10c3 fjsp.hurink.rdata-la06.m5j15c3 fjsp.hurink.rdata-la07.m5j15c3 fjsp.hurink.rdata-la08.m5j15c3 fjsp.hurink.rdata-la09.m5j15c3 fjsp.hurink.rdata-la10.m5j15c3 fjsp.hurink.rdata-la11.m5j20c3 fjsp.hurink.rdata-la12.m5j20c3 fjsp.hurink.rdata-la13.m5j20c3 fjsp.hurink.rdata-la14.m5j20c3 fjsp.hurink.rdata-la15.m5j20c3 fjsp.hurink.rdata-la16.m10j10c3 fjsp.hurink.rdata-la17.m10j10c3 fjsp.hurink.rdata-la18.m10j10c3 fjsp.hurink.rdata-la19.m10j10c3 fjsp.hurink.rdata-la20.m10j10c3 fjsp.hurink.rdata-la21.m10j15c3 fjsp.hurink.rdata-la22.m10j15c3 fjsp.hurink.rdata-la23.m10j15c3 fjsp.hurink.rdata-la24.m10j15c3 fjsp.hurink.rdata-la25.m10j15c3 fjsp.hurink.rdata-la26.m10j20c3 fjsp.hurink.rdata-la27.m10j20c3 fjsp.hurink.rdata-la28.m10j20c3 fjsp.hurink.rdata-la29.m10j20c3 fjsp.hurink.rdata-la30.m10j20c3 fjsp.hurink.rdata-la31.m10j30c3 fjsp.hurink.rdata-la32.m10j30c3 fjsp.hurink.rdata-la33.m10j30c3 fjsp.hurink.rdata-la34.m10j30c3 fjsp.hurink.rdata-la35.m10j30c3 fjsp.hurink.rdata-la36.m15j15c3 fjsp.hurink.rdata-la37.m15j15c3 fjsp.hurink.rdata-la38.m15j15c3 fjsp.hurink.rdata-la39.m15j15c3 fjsp.hurink.rdata-la40.m15j15c3 fjsp.hurink.rdata-mt06.m6j6c3 fjsp.hurink.rdata-mt10.m10j10c3 fjsp.hurink.rdata-mt20.m5j20c3 fjsp.hurink.rdata-orb01.m10j10c3 fjsp.hurink.rdata-orb02.m10j10c3 fjsp.hurink.rdata-orb03.m10j10c3 fjsp.hurink.rdata-orb04.m10j10c3 fjsp.hurink.rdata-orb05.m10j10c3 fjsp.hurink.rdata-orb06.m10j10c3 fjsp.hurink.rdata-orb07.m10j10c3 fjsp.hurink.rdata-orb08.m10j10c3 fjsp.hurink.rdata-orb09.m10j10c3 fjsp.hurink.rdata-orb10.m10j10c3 ##fjsp.hurink.sdata-abz5.m10j10c1 &lt;=&gt; jsp.ABZ05.m10j10c1 ##fjsp.hurink.sdata-abz6.m10j10c1 &lt;=&gt; jsp.ABZ06.m10j10c1 ##fjsp.hurink.sdata-abz7.m15j20c1 &lt;=&gt; jsp.ABZ07.m15j20c1 ##fjsp.hurink.sdata-abz8.m15j20c1 &lt;=&gt; jsp.ABZ08.m15j20c1 ##fjsp.hurink.sdata-abz9.m15j20c1 &lt;=&gt; jsp.ABZ09.m15j20c1 fjsp.hurink.sdata-car1.m5j11c1 fjsp.hurink.sdata-car2.m4j13c1 fjsp.hurink.sdata-car3.m5j12c1 fjsp.hurink.sdata-car4.m4j14c1 fjsp.hurink.sdata-car5.m6j10c1 fjsp.hurink.sdata-car6.m9j8c1 fjsp.hurink.sdata-car7.m7j7c1 fjsp.hurink.sdata-car8.m8j8c1 ##fjsp.hurink.sdata-la01.m5j10c1 &lt;=&gt; jsp.LA01.m5j10c1 ##fjsp.hurink.sdata-la02.m5j10c1 &lt;=&gt; jsp.LA02.m5j10c1 ##fjsp.hurink.sdata-la03.m5j10c1 &lt;=&gt; jsp.LA03.m5j10c1 ##fjsp.hurink.sdata-la04.m5j10c1 &lt;=&gt; jsp.LA04.m5j10c1 ##fjsp.hurink.sdata-la05.m5j10c1 &lt;=&gt; jsp.LA05.m5j10c1 ##fjsp.hurink.sdata-la06.m5j15c1 &lt;=&gt; jsp.LA06.m5j15c1 ##fjsp.hurink.sdata-la07.m5j15c1 &lt;=&gt; jsp.LA07.m5j15c1 ##fjsp.hurink.sdata-la08.m5j15c1 &lt;=&gt; jsp.LA08.m5j15c1 ##fjsp.hurink.sdata-la09.m5j15c1 &lt;=&gt; jsp.LA09.m5j15c1 ##fjsp.hurink.sdata-la10.m5j15c1 &lt;=&gt; jsp.LA10.m5j15c1 ##fjsp.hurink.sdata-la11.m5j20c1 &lt;=&gt; jsp.LA11.m5j20c1 ##fjsp.hurink.sdata-la12.m5j20c1 &lt;=&gt; jsp.LA12.m5j20c1 ##fjsp.hurink.sdata-la13.m5j20c1 &lt;=&gt; jsp.LA13.m5j20c1 ##fjsp.hurink.sdata-la14.m5j20c1 &lt;=&gt; jsp.LA14.m5j20c1 ##fjsp.hurink.sdata-la15.m5j20c1 &lt;=&gt; jsp.LA15.m5j20c1 ##fjsp.hurink.sdata-la16.m10j10c1 &lt;=&gt; jsp.LA16.m10j10c1 ##fjsp.hurink.sdata-la17.m10j10c1 &lt;=&gt; jsp.LA17.m10j10c1 ##fjsp.hurink.sdata-la18.m10j10c1 &lt;=&gt; jsp.LA18.m10j10c1 ##fjsp.hurink.sdata-la19.m10j10c1 &lt;=&gt; jsp.LA19.m10j10c1 ##fjsp.hurink.sdata-la20.m10j10c1 &lt;=&gt; jsp.LA20.m10j10c1 ##fjsp.hurink.sdata-la21.m10j15c1 &lt;=&gt; jsp.LA21.m10j15c1 ##fjsp.hurink.sdata-la22.m10j15c1 &lt;=&gt; jsp.LA22.m10j15c1 ##fjsp.hurink.sdata-la23.m10j15c1 &lt;=&gt; jsp.LA23.m10j15c1 ##fjsp.hurink.sdata-la24.m10j15c1 &lt;=&gt; jsp.LA24.m10j15c1 ##fjsp.hurink.sdata-la25.m10j15c1 &lt;=&gt; jsp.LA25.m10j15c1 ##fjsp.hurink.sdata-la26.m10j20c1 &lt;=&gt; jsp.LA26.m10j20c1 ##fjsp.hurink.sdata-la27.m10j20c1 &lt;=&gt; jsp.LA27.m10j20c1 ##fjsp.hurink.sdata-la28.m10j20c1 &lt;=&gt; jsp.LA28.m10j20c1 ##fjsp.hurink.sdata-la29.m10j20c1 &lt;=&gt; jsp.LA29.m10j20c1 ##fjsp.hurink.sdata-la30.m10j20c1 &lt;=&gt; jsp.LA30.m10j20c1 ##fjsp.hurink.sdata-la31.m10j30c1 &lt;=&gt; jsp.LA31.m10j30c1 ##fjsp.hurink.sdata-la32.m10j30c1 &lt;=&gt; jsp.LA32.m10j30c1 ##fjsp.hurink.sdata-la33.m10j30c1 &lt;=&gt; jsp.LA33.m10j30c1 ##fjsp.hurink.sdata-la34.m10j30c1 &lt;=&gt; jsp.LA34.m10j30c1 ##fjsp.hurink.sdata-la35.m10j30c1 &lt;=&gt; jsp.LA35.m10j30c1 ##fjsp.hurink.sdata-la36.m15j15c1 &lt;=&gt; jsp.LA36.m15j15c1 ##fjsp.hurink.sdata-la37.m15j15c1 &lt;=&gt; jsp.LA37.m15j15c1 ##fjsp.hurink.sdata-la38.m15j15c1 &lt;=&gt; jsp.LA38.m15j15c1 ##fjsp.hurink.sdata-la39.m15j15c1 &lt;=&gt; jsp.LA39.m15j15c1 ##fjsp.hurink.sdata-la40.m15j15c1 &lt;=&gt; jsp.LA40.m15j15c1 ##fjsp.hurink.sdata-mt06.m6j6c1 &lt;=&gt; jsp.FT06.m6j6c1 ##fjsp.hurink.sdata-mt10.m10j10c1 &lt;=&gt; jsp.FT10.m10j10c1 ##fjsp.hurink.sdata-mt20.m5j20c1 &lt;=&gt; jsp.FT20.m5j20c1 ##fjsp.hurink.sdata-orb01.m10j10c1 &lt;=&gt; jsp.ORB01.m10j10c1 ##fjsp.hurink.sdata-orb02.m10j10c1 &lt;=&gt; jsp.ORB02.m10j10c1 ##fjsp.hurink.sdata-orb03.m10j10c1 &lt;=&gt; jsp.ORB03.m10j10c1 ##fjsp.hurink.sdata-orb04.m10j10c1 &lt;=&gt; jsp.ORB04.m10j10c1 ##fjsp.hurink.sdata-orb05.m10j10c1 &lt;=&gt; jsp.ORB05.m10j10c1 ##fjsp.hurink.sdata-orb06.m10j10c1 &lt;=&gt; jsp.ORB06.m10j10c1 ##fjsp.hurink.sdata-orb07.m10j10c1 &lt;=&gt; jsp.ORB07.m10j10c1 ##fjsp.hurink.sdata-orb08.m10j10c1 &lt;=&gt; jsp.ORB08.m10j10c1 ##fjsp.hurink.sdata-orb09.m10j10c1 &lt;=&gt; jsp.ORB09.m10j10c1 ##fjsp.hurink.sdata-orb10.m10j10c1 &lt;=&gt; jsp.ORB10.m10j10c1 fjsp.hurink.vdata-abz5.m10j10c9 fjsp.hurink.vdata-abz6.m10j10c8 fjsp.hurink.vdata-abz7.m15j20c11 fjsp.hurink.vdata-abz8.m15j20c13 fjsp.hurink.vdata-abz9.m15j20c12 fjsp.hurink.vdata-car1.m5j11c5 fjsp.hurink.vdata-car2.m4j13c4 fjsp.hurink.vdata-car3.m5j12c4 fjsp.hurink.vdata-car4.m4j14c3 fjsp.hurink.vdata-car5.m6j10c5 fjsp.hurink.vdata-car6.m9j8c7 fjsp.hurink.vdata-car7.m7j7c6 fjsp.hurink.vdata-car8.m8j8c7 fjsp.hurink.vdata-la01.m5j10c5 fjsp.hurink.vdata-la02.m5j10c5 fjsp.hurink.vdata-la03.m5j10c5 fjsp.hurink.vdata-la04.m5j10c4 fjsp.hurink.vdata-la05.m5j10c5 fjsp.hurink.vdata-la06.m5j15c5 fjsp.hurink.vdata-la07.m5j15c5 fjsp.hurink.vdata-la08.m5j15c5 fjsp.hurink.vdata-la09.m5j15c5 fjsp.hurink.vdata-la10.m5j15c5 fjsp.hurink.vdata-la11.m5j20c5 fjsp.hurink.vdata-la12.m5j20c5 fjsp.hurink.vdata-la13.m5j20c4 fjsp.hurink.vdata-la14.m5j20c5 fjsp.hurink.vdata-la15.m5j20c5 fjsp.hurink.vdata-la16.m10j10c8 fjsp.hurink.vdata-la17.m10j10c9 fjsp.hurink.vdata-la18.m10j10c9 fjsp.hurink.vdata-la19.m10j10c8 fjsp.hurink.vdata-la20.m10j10c8 fjsp.hurink.vdata-la21.m10j15c8 fjsp.hurink.vdata-la22.m10j15c8 fjsp.hurink.vdata-la23.m10j15c8 fjsp.hurink.vdata-la24.m10j15c8 fjsp.hurink.vdata-la25.m10j15c9 fjsp.hurink.vdata-la26.m10j20c9 fjsp.hurink.vdata-la27.m10j20c9 fjsp.hurink.vdata-la28.m10j20c9 fjsp.hurink.vdata-la29.m10j20c9 fjsp.hurink.vdata-la30.m10j20c9 fjsp.hurink.vdata-la31.m10j30c9 fjsp.hurink.vdata-la32.m10j30c9 fjsp.hurink.vdata-la33.m10j30c8 fjsp.hurink.vdata-la34.m10j30c9 fjsp.hurink.vdata-la35.m10j30c9 fjsp.hurink.vdata-la36.m15j15c12 fjsp.hurink.vdata-la37.m15j15c12 fjsp.hurink.vdata-la38.m15j15c12 fjsp.hurink.vdata-la39.m15j15c11 fjsp.hurink.vdata-la40.m15j15c11 fjsp.hurink.vdata-mt06.m6j6c5 fjsp.hurink.vdata-mt10.m10j10c8 fjsp.hurink.vdata-mt20.m5j20c5 fjsp.hurink.vdata-orb01.m10j10c8 fjsp.hurink.vdata-orb02.m10j10c8 fjsp.hurink.vdata-orb03.m10j10c8 fjsp.hurink.vdata-orb04.m10j10c9 fjsp.hurink.vdata-orb05.m10j10c8 fjsp.hurink.vdata-orb06.m10j10c8 fjsp.hurink.vdata-orb07.m10j10c8 fjsp.hurink.vdata-orb08.m10j10c8 fjsp.hurink.vdata-orb09.m10j10c8 fjsp.hurink.vdata-orb10.m10j10c8 jsp.ABZ05.m10j10c1 jsp.ABZ06.m10j10c1 jsp.ABZ07.m15j20c1 jsp.ABZ08.m15j20c1 jsp.ABZ09.m15j20c1 jsp.DMU01.m15j20c1 jsp.DMU02.m15j20c1 jsp.DMU03.m15j20c1 jsp.DMU04.m15j20c1 jsp.DMU05.m15j20c1 jsp.DMU06.m20j20c1 jsp.DMU07.m20j20c1 jsp.DMU08.m20j20c1 jsp.DMU09.m20j20c1 jsp.DMU10.m20j20c1 jsp.DMU11.m15j30c1 jsp.DMU12.m15j30c1 jsp.DMU13.m15j30c1 jsp.DMU14.m15j30c1 jsp.DMU15.m15j30c1 jsp.DMU16.m20j30c1 jsp.DMU17.m20j30c1 jsp.DMU18.m20j30c1 jsp.DMU19.m20j30c1 jsp.DMU20.m20j30c1 jsp.DMU21.m15j40c1 jsp.DMU22.m15j40c1 jsp.DMU23.m15j40c1 jsp.DMU24.m15j40c1 jsp.DMU25.m15j40c1 jsp.DMU26.m20j40c1 jsp.DMU27.m20j40c1 jsp.DMU28.m20j40c1 jsp.DMU29.m20j40c1 jsp.DMU30.m20j40c1 jsp.DMU31.m15j50c1 jsp.DMU32.m15j50c1 jsp.DMU33.m15j50c1 jsp.DMU34.m15j50c1 jsp.DMU35.m15j50c1 jsp.DMU36.m20j50c1 jsp.DMU37.m20j50c1 jsp.DMU38.m20j50c1 jsp.DMU39.m20j50c1 jsp.DMU40.m20j50c1 jsp.DMU41.m15j20c1 jsp.DMU42.m15j20c1 jsp.DMU43.m15j20c1 jsp.DMU44.m15j20c1 jsp.DMU45.m15j20c1 jsp.DMU46.m20j20c1 jsp.DMU47.m20j20c1 jsp.DMU48.m20j20c1 jsp.DMU49.m20j20c1 jsp.DMU50.m20j20c1 jsp.DMU51.m15j30c1 jsp.DMU52.m15j30c1 jsp.DMU53.m15j30c1 jsp.DMU54.m15j30c1 jsp.DMU55.m15j30c1 jsp.DMU56.m20j30c1 jsp.DMU57.m20j30c1 jsp.DMU58.m20j30c1 jsp.DMU59.m20j30c1 jsp.DMU60.m20j30c1 jsp.DMU61.m15j40c1 jsp.DMU62.m15j40c1 jsp.DMU63.m15j40c1 jsp.DMU64.m15j40c1 jsp.DMU65.m15j40c1 jsp.DMU66.m20j40c1 jsp.DMU67.m20j40c1 jsp.DMU68.m20j40c1 jsp.DMU69.m20j40c1 jsp.DMU70.m20j40c1 jsp.DMU71.m15j50c1 jsp.DMU72.m15j50c1 jsp.DMU73.m15j50c1 jsp.DMU74.m15j50c1 jsp.DMU75.m15j50c1 jsp.DMU76.m20j50c1 jsp.DMU77.m20j50c1 jsp.DMU78.m20j50c1 jsp.DMU79.m20j50c1 jsp.DMU80.m20j50c1 jsp.FT06.m6j6c1 jsp.FT10.m10j10c1 jsp.FT20.m5j20c1 jsp.LA01.m5j10c1 jsp.LA02.m5j10c1 jsp.LA03.m5j10c1 jsp.LA04.m5j10c1 jsp.LA05.m5j10c1 jsp.LA06.m5j15c1 jsp.LA07.m5j15c1 jsp.LA08.m5j15c1 jsp.LA09.m5j15c1 jsp.LA10.m5j15c1 jsp.LA11.m5j20c1 jsp.LA12.m5j20c1 jsp.LA13.m5j20c1 jsp.LA14.m5j20c1 jsp.LA15.m5j20c1 jsp.LA16.m10j10c1 jsp.LA17.m10j10c1 jsp.LA18.m10j10c1 jsp.LA19.m10j10c1 jsp.LA20.m10j10c1 jsp.LA21.m10j15c1 jsp.LA22.m10j15c1 jsp.LA23.m10j15c1 jsp.LA24.m10j15c1 jsp.LA25.m10j15c1 jsp.LA26.m10j20c1 jsp.LA27.m10j20c1 jsp.LA28.m10j20c1 jsp.LA29.m10j20c1 jsp.LA30.m10j20c1 jsp.LA31.m10j30c1 jsp.LA32.m10j30c1 jsp.LA33.m10j30c1 jsp.LA34.m10j30c1 jsp.LA35.m10j30c1 jsp.LA36.m15j15c1 jsp.LA37.m15j15c1 jsp.LA38.m15j15c1 jsp.LA39.m15j15c1 jsp.LA40.m15j15c1 jsp.ORB01.m10j10c1 jsp.ORB02.m10j10c1 jsp.ORB03.m10j10c1 jsp.ORB04.m10j10c1 jsp.ORB05.m10j10c1 jsp.ORB06.m10j10c1 jsp.ORB07.m10j10c1 jsp.ORB08.m10j10c1 jsp.ORB09.m10j10c1 jsp.ORB10.m10j10c1 jsp.SWV01.m10j20c1 jsp.SWV02.m10j20c1 jsp.SWV03.m10j20c1 jsp.SWV04.m10j20c1 jsp.SWV05.m10j20c1 jsp.SWV06.m15j20c1 jsp.SWV07.m15j20c1 jsp.SWV08.m15j20c1 jsp.SWV09.m15j20c1 jsp.SWV10.m15j20c1 jsp.SWV11.m10j50c1 jsp.SWV12.m10j50c1 jsp.SWV13.m10j50c1 jsp.SWV14.m10j50c1 jsp.SWV15.m10j50c1 jsp.SWV16.m10j50c1 jsp.SWV17.m10j50c1 jsp.SWV18.m10j50c1 jsp.SWV19.m10j50c1 jsp.SWV20.m10j50c1 jsp.TA01.m15j15c1 jsp.TA02.m15j15c1 jsp.TA03.m15j15c1 jsp.TA04.m15j15c1 jsp.TA05.m15j15c1 jsp.TA06.m15j15c1 jsp.TA07.m15j15c1 jsp.TA08.m15j15c1 jsp.TA09.m15j15c1 jsp.TA10.m15j15c1 jsp.TA11.m15j20c1 jsp.TA12.m15j20c1 jsp.TA13.m15j20c1 jsp.TA14.m15j20c1 jsp.TA15.m15j20c1 jsp.TA16.m15j20c1 jsp.TA17.m15j20c1 jsp.TA18.m15j20c1 jsp.TA19.m15j20c1 jsp.TA20.m15j20c1 jsp.TA21.m20j20c1 jsp.TA22.m20j20c1 jsp.TA23.m20j20c1 jsp.TA24.m20j20c1 jsp.TA25.m20j20c1 jsp.TA26.m20j20c1 jsp.TA27.m20j20c1 jsp.TA28.m20j20c1 jsp.TA29.m20j20c1 jsp.TA30.m20j20c1 jsp.TA31.m15j30c1 jsp.TA32.m15j30c1 jsp.TA33.m15j30c1 jsp.TA34.m15j30c1 jsp.TA35.m15j30c1 jsp.TA36.m15j30c1 jsp.TA37.m15j30c1 jsp.TA38.m15j30c1 jsp.TA39.m15j30c1 jsp.TA40.m15j30c1 jsp.TA41.m20j30c1 jsp.TA42.m20j30c1 jsp.TA43.m20j30c1 jsp.TA44.m20j30c1 jsp.TA45.m20j30c1 jsp.TA46.m20j30c1 jsp.TA47.m20j30c1 jsp.TA48.m20j30c1 jsp.TA49.m20j30c1 jsp.TA50.m20j30c1 jsp.TA51.m15j50c1 jsp.TA52.m15j50c1 jsp.TA53.m15j50c1 jsp.TA54.m15j50c1 jsp.TA55.m15j50c1 jsp.TA56.m15j50c1 jsp.TA57.m15j50c1 jsp.TA58.m15j50c1 jsp.TA59.m15j50c1 jsp.TA60.m15j50c1 jsp.TA61.m20j50c1 jsp.TA62.m20j50c1 jsp.TA63.m20j50c1 jsp.TA64.m20j50c1 jsp.TA65.m20j50c1 jsp.TA66.m20j50c1 jsp.TA67.m20j50c1 jsp.TA68.m20j50c1 jsp.TA69.m20j50c1 jsp.TA70.m20j50c1 jsp.TA71.m20j100c1 jsp.TA72.m20j100c1 jsp.TA73.m20j100c1 jsp.TA74.m20j100c1 jsp.TA75.m20j100c1 jsp.TA76.m20j100c1 jsp.TA77.m20j100c1 jsp.TA78.m20j100c1 jsp.TA79.m20j100c1 jsp.TA80.m20j100c1 jsp.YN01.m20j20c1 jsp.YN02.m20j20c1 jsp.YN03.m20j20c1 jsp.YN04.m20j20c1","categories":[{"name":"算法挑战","slug":"算法挑战","permalink":"http://suzhouxing.github.io/techive/categories/算法挑战/"}],"tags":[{"name":"组合优化","slug":"组合优化","permalink":"http://suzhouxing.github.io/techive/tags/组合优化/"},{"name":"算法挑战","slug":"算法挑战","permalink":"http://suzhouxing.github.io/techive/tags/算法挑战/"}]},{"title":"SmartLab Challenge 2020 - p-Center and Unicost Set Covering","slug":"Contest-2020pCenter","date":"2020-12-22T02:19:15.000Z","updated":"2021-09-29T12:22:03.544Z","comments":true,"path":"2020/12/22/Contest-2020pCenter/","link":"","permalink":"http://suzhouxing.github.io/techive/2020/12/22/Contest-2020pCenter/","excerpt":"","text":"中心选址问题是通信与物流等领域中的重要问题, 其背后的单一成本集合覆盖问题更是用途广泛. 中心选址问题和单一成本集合覆盖问题主要研究如何使用有限的资源提供尽可能高质量的服务的问题. 例如, 移动基站, 消防站, 物流仓库, 数据中心等众多设施的选址都可以建模为中心选址问题. 高效的中心选址或单一成本集合覆盖问题的求解算法具有极其重要的理论与应用价值. 中心选址与单一成本集合覆盖算法训练 问题概述 给定一系列节点, 从中选出若干节点作为中心为其他节点提供服务. 若一个节点由某个中心服务, 则认为其间存在一条服务边. 在确保每个节点至少由一个中心服务的前提下, 使最长的服务边最短. 若固定服务半径 (服务边的最大长度), 该问题等价于集合覆盖问题. 即给定一系列元素与若干子集, 请选择给定数量的子集, 使其并集等于所有元素的全集. 参考文献. [1] Z. Su, Q. Zhang, Z. Lü, C.-M. Li, W. Lin, and F. Ma, “Weighting-based Variable Neighborhood Search for Optimal Camera Placement,” Proceedings of the AAAI Conference on Artificial Intelligence, vol. 35, no. 14, pp. 12400–12408, 2021. [2] Q. Zhang, Z. Lü, Z. Su, C. Li, Y. Fang, and F. Ma, “Vertex Weighting-Based Tabu Search for p-Center Problem,” in Proceedings of the Twenty-Ninth International Joint Conference on Artificial Intelligence, IJCAI-20, 2020, pp. 1481–1487. doi: 10.24963/ijcai.2020/206. 命令行参数 请大家编写程序时支持两个命令行参数, 依次为运行时间上限 (单位为秒) 和随机种子 (0-65535). 算例文件已重定向至标准输入 stdin/cin, 标准输出 stdout/cout 已重定向至解文件 (如需打印调试信息, 请使用标准错误输出 stderr/cerr). 例如, 在控制台运行以下命令表示调用可执行文件 pcenter.exe 在限时 1000 秒, 随机种子为 12345 的情况下求解路径为 ../data/pmed1.n100p5.txt 的算例, 解文件输出至 sln.pmed1.n100p5.txt: 1pcenter.exe 1000 123456 &lt;../data/pmed1.n100p5.txt &gt;sln.pmed1.n100p5.txt 运行时间上限. 超出运行时间上限后测试程序会强行终止算法, 请确保在此之前已输出解 (最好还能自行正常退出). 随机种子设置. 使用 C 语言随机数生成器请用 srand. 使用 C++ 随机数生成器 (如 mt19937) 请在构造时传参或调用 seed() 方法设置. 输入的算例文件格式 所有算例均已根据给定覆盖半径转换为判定问题, 处理为一系列固定集合数的单一成本集合覆盖算例, 并附有逐步缩小半径时新增的无法覆盖的节点的信息. 转换后每个节点都可以覆盖若干节点, 同时也对称地被若干节点覆盖, 故转换后的单一成本集合覆盖算例中集合数等于元素数. 所有算例的元素和集合分别从 0 开始连续编号. 第一行给出两个由空白字符分隔的整数 N 和 P, 分别表示节点数和中心数 (从集合覆盖的角度来看, N 既是集合数又是元素数, P 为可挑选出的集合数). 接下来每两行一组, 连续 N 组给出每个集合的覆盖范围. 每组中第一行为该集合能覆盖的元素数量 C, 第二行为空白字符分隔的 C 个数字, 分别表示该集合能覆盖的元素的编号. 然后给出两个由空白字符分隔的整数 U 和 L, 分别表示覆盖半径边长序号的上界和下界 (其中上界即前面给出的判定问题对应的覆盖半径的边长序号, 下界为估计值). 接下来连续 U - L 行给出每缩小一次覆盖半径新增的无法覆盖的元素的信息 (若 U = L = 0, 说明前面给出的判定问题对应的覆盖半径已经为最优半径, 缩小半径后已不存在可行解). 每行第一个整数 K 表示本次缩小半径将导致 K 个元素不再被某个集合覆盖, 随后连续 K 个由空白字符分隔的整数 S 表示集合 S 将新增一个无法覆盖的元素 (同一个集合可能重复出现多次). 注意, 在前面给出的判定问题数据中, 每个集合可覆盖的元素已按从近到远的顺序排序, 即每次只用将集合 S 可覆盖元素列表末尾的一个元素删除即可. 例如, 以下算例文件表示集合和元素的数量均为 4, 要求挑选出 2 个集合覆盖所有元素; 其中, 集合 0 可以覆盖 2 个元素, 分别为元素 0 和 3; 集合 1 可以覆盖 2 个元素, 分别为元素 1 和 2; 集合 2 可以覆盖 3 个元素, 分别为元素 1, 2 和 3; 集合 3 可以覆盖 2 个元素, 分别为元素 0 和 2; 覆盖半径边长序号的上界为 5 下界为 3; 其中, 半径缩小为第 4 短的边时, 集合 2 无法再覆盖最远的元素 3, 集合 3 无法再覆盖最远的元素 2; 半径缩小为第 3 短的边时, 集合 1 无法再覆盖最远的元素 2, 集合 2 无法再覆盖最远的元素 1: 1234567891011124 220 321 231 2 320 25 32 2 32 1 2 输出的解文件格式 输出 P 个用空白字符 (建议使用换行符) 分隔的整数, 分别表示挑选出的 P 个中心 (集合). 例如, 以下解文件表示选择节点 0 和 2 作为中心 (集合): 1202 提交要求 发送至邮箱 szx@duhe.tech. 邮件标题格式为 \"Challenge2020PCP-姓名-学校-专业\". 邮件附件为单个压缩包 (文件大小 2M 以内), 文件名为 \"姓名-学校-专业\", 其内包含下列文件. 必要 算法的可执行文件 (Windows 平台). 建议基于官方 SDK 开发 (https://gitee.com/suzhouxing/npbenchmark/tree/main/SDK.PCP). 用 g++ 的同学编译时请静态链接, 即添加 -static-libgcc -static-libstdc++ 编译选项. 必要 算法源码. 可重入 (可在同一线程内反复调用而不会出现数据初始化错误或内存泄漏). 可并发 (可在同一进程内的多个线程同时运行多个算法求解实例而互不干扰, 满足此要求一般不能有全局的非只读变量). 可伸缩 (数据结构可以根据算例规模动态申请内存, 而非根据预先指定的编译期常量进行内存分配). 可选 算法在各算例上的运行情况概要, 至少包括以下几项信息 (可选, 仅在无法成功调用算法输出可通过检查程序的解时作为参考). 算例名. 服务半径. 计算耗时. 可选 算法在各算例上求得的完全覆盖的解文件 (可选, 仅在无法成功调用算法输出可通过检查程序的解时作为参考). 若成功提交, 在收到邮件时以及测试完成后系统均会自动发送邮件反馈提交情况. 若测试结果较优, 可在排行榜页面看到自己的运行情况 (https://gitee.com/suzhouxing/npbenchmark/tree/data). 例如: 12345678910111213苏宙行-华科-计科.zip| pcenter.exe| results.csv|+---src| main.cpp| algorithm.cpp| algorithm.h|+---results pmed1.n100p5.txt pmed2.n100p10.txt ... 算例清单 下载地址: https://gitee.com/suzhouxing/npbenchmark/tree/data/PCP/Instance 算例规模从小到大依次为 (求解难度不一定随规模增加, 但除 pcb3038* 以外的算例应该都很容易求解): pmed01.n100p005 pmed02.n100p010 pmed03.n100p010 pmed04.n100p020 pmed05.n100p033 pmed06.n200p005 pmed07.n200p010 pmed08.n200p020 pmed09.n200p040 pmed10.n200p067 pmed11.n300p005 pmed12.n300p010 pmed13.n300p030 pmed14.n300p060 pmed15.n300p100 pmed16.n400p005 pmed17.n400p010 pmed18.n400p040 pmed19.n400p080 pmed20.n400p133 pmed21.n500p005 pmed22.n500p010 pmed23.n500p050 pmed24.n500p100 pmed25.n500p167 pmed26.n600p005 pmed27.n600p010 pmed28.n600p060 pmed29.n600p120 pmed30.n600p200 pmed31.n700p005 pmed32.n700p010 pmed33.n700p070 pmed34.n700p140 pmed35.n800p005 pmed36.n800p010 pmed37.n800p080 pmed38.n900p005 pmed39.n900p010 pmed40.n900p090 u1060p010 u1060p020 u1060p030 u1060p040 u1060p050 u1060p060 u1060p070 u1060p080 u1060p090 u1060p100 u1060p110 u1060p120 u1060p130 u1060p140 u1060p150 rl1323p010 rl1323p020 rl1323p030 rl1323p040 rl1323p050 rl1323p060 rl1323p070 rl1323p080 rl1323p090 rl1323p100 u1817p010 u1817p020 u1817p030 u1817p040 u1817p050 u1817p060 u1817p070 u1817p080 u1817p090 u1817p100 u1817p110 u1817p120 u1817p130 u1817p140 u1817p150 pcb3038p010r729 pcb3038p020r494 pcb3038p030r394 pcb3038p040r337 pcb3038p050r299 pcb3038p100r207 pcb3038p150r165 pcb3038p200r141 pcb3038p250r123 pcb3038p300r116 pcb3038p350r105 pcb3038p400r97 pcb3038p450r89 pcb3038p500r85","categories":[{"name":"算法挑战","slug":"算法挑战","permalink":"http://suzhouxing.github.io/techive/categories/算法挑战/"}],"tags":[{"name":"组合优化","slug":"组合优化","permalink":"http://suzhouxing.github.io/techive/tags/组合优化/"},{"name":"算法挑战","slug":"算法挑战","permalink":"http://suzhouxing.github.io/techive/tags/算法挑战/"}]},{"title":"SmartLab Challenge 2020 - Graph Coloring","slug":"Contest-2020GraphColoring","date":"2020-12-09T02:28:35.000Z","updated":"2021-09-29T12:22:12.535Z","comments":true,"path":"2020/12/09/Contest-2020GraphColoring/","link":"","permalink":"http://suzhouxing.github.io/techive/2020/12/09/Contest-2020GraphColoring/","excerpt":"","text":"图着色问题在众多领域中有广泛的应用, 可以用来对各种各样的组合优化问题进行建模. 图着色问题主要研究独占资源的分配问题. 比如在编译器给变量分配寄存器分配时, 如果两个变量的生命周期有交集, 则不能分配至同一寄存器. 比如在机场分配停机位时, 如果两架飞机的过站时间有交集, 则不能分配至同一停机位. 比如在光纤网络中进行波长分配时, 如果两条光路经过同一条链路, 则不能使用同一波长传输. 比如移动基站进行通讯频率分配时, 如果两个终端设备位于同一组天线的覆盖范围内, 则不能使用同一通讯频率. 比如在学校排课表时, 如果两个班级要上同一位教师的课, 则其上课时间不能相同. 高效的图着色问题求解算法具有极其重要的理论与应用价值. 图着色算法训练 问题概述 给定一个无向图, 请为每个节点染一种颜色, 在任意一条无向边两端的节点颜色不同的情况下, 最小化使用的颜色数. 参考文献. [1] Z. Lü and J.-K. Hao, “A memetic algorithm for graph coloring,” European Journal of Operational Research, vol. 203, no. 1, pp. 241–250, 2010, doi: 10.1016/j.ejor.2009.07.016. [2] L. Moalic and A. Gondran, “Variations on memetic algorithms for graph coloring problems,” Journal of Heuristics, vol. 24, no. 1, pp. 1–24, 2018, doi: 10.1007/s10732-017-9354-9. 命令行参数 请大家编写程序时支持两个命令行参数, 依次为运行时间上限 (单位为秒) 和随机种子 (0-65535). 算例文件已重定向至标准输入 stdin/cin, 标准输出 stdout/cout 已重定向至解文件 (如需打印调试信息, 请使用标准错误输出 stderr/cerr). 例如, 在控制台运行以下命令表示调用可执行文件 gcp.exe 在限时 600 秒, 随机种子为 12345 的情况下求解路径为 ../data/DSJC500.5.txt 的算例, 解文件输出至 sln.dsjc500.5.txt: 1gcp.exe 600 123456 &lt;../data/DSJC500.5.txt &gt;sln.dsjc500.5.txt 运行时间上限. 超出运行时间上限后测试程序会强行终止算法, 请确保在此之前已输出解 (最好还能自行正常退出). 随机种子设置. 使用 C 语言随机数生成器请用 srand. 使用 C++ 随机数生成器 (如 mt19937) 请在构造时传参或调用 seed() 方法设置. 输入的算例文件格式 所有算例的节点从 0 开始连续编号. 第一行给出三个由空白字符分隔的整数, 分别表示节点数 N, 无向边数 E (有向边数为 2E), 以及参考颜色数 C (相对容易求得可行解, 非最优颜色数). 接下来连续 E 行, 每行包含两个由空白字符分隔的整数, 表示一条无向边的两个端点. 例如, 以下算例文件表示节点数为 4, 无向边数为 3, 参考颜色数为 2; 其中: 节点 0 分别与 1, 2, 3 相邻. 12344 3 20 10 23 0 输出的解文件格式 输出 N 个用空白字符 (建议使用换行符) 分隔整数表示 N 个节点的染色情况, 第 i 个整数表示第 i 个节点的颜色. 颜色可以取 int 范围内任意非负整数, 检查程序自动统计不同的非负整数的数量. 例如, 以下解文件表示节点 0 染颜色 0, 节点 1 染颜色 1, 节点 2 染颜色 1, 节点 3 染颜色 1: 12340111 提交要求 发送至邮箱 szx@duhe.tech. 邮件标题格式为 \"Challenge2020GCP-姓名-学校-专业\". 邮件附件为单个压缩包 (文件大小 2M 以内), 文件名为 \"姓名-学校-专业\", 其内包含下列文件. 必要 算法的可执行文件 (Windows 平台). 建议基于官方 SDK 开发 (https://gitee.com/suzhouxing/npbenchmark/tree/main/SDK.GCP). 用 g++ 的同学编译时建议静态链接, 即添加 -static-libgcc -static-libstdc++ 编译选项. 必要 算法源码. 可重入 (可在同一线程内反复调用而不会出现数据初始化错误或内存泄漏). 可并发 (可在同一进程内的多个线程同时运行多个算法求解实例而互不干扰, 满足此要求一般不能有全局的非只读变量). 可伸缩 (数据结构可以根据算例规模动态申请内存, 而非根据预先指定的编译期常量进行内存分配). 可选 算法在各算例上的运行情况概要, 至少包括以下几项信息 (可选, 仅在无法成功调用算法输出可通过检查程序的解时作为参考). 算例名. 颜色数. 计算耗时. 可选 算法在各算例上求得的颜色数最少的解文件 (可选, 仅在无法成功调用算法输出可通过检查程序的解时作为参考). 若成功提交, 在收到邮件时以及测试完成后系统均会自动发送邮件反馈提交情况. 若测试结果较优, 可在排行榜页面看到自己的运行情况 (https://gitee.com/suzhouxing/npbenchmark/tree/data). 例如: 12345678910111213苏宙行-华科-计科.zip| gc.exe| results.csv|+---src| main.cpp| algorithm.cpp| algorithm.h|+---results DSJC125.1.txt DSJC125.5.txt ... 算例清单 下载地址: https://gitee.com/suzhouxing/npbenchmark/tree/data/GCP/Instance 算例规模从小到大依次为 (求解难度不一定随规模增加, 但 DSJC500.5 以前的算例应该都很容易求解): DSJC0125.1 DSJC0125.5 DSJC0125.9 DSJC0250.1 DSJC0250.5 DSJC0250.9 DSJC0500.1 DSJC0500.5 DSJC0500.9 DSJC1000.1 DSJC1000.5 DSJC1000.9","categories":[{"name":"算法挑战","slug":"算法挑战","permalink":"http://suzhouxing.github.io/techive/categories/算法挑战/"}],"tags":[{"name":"组合优化","slug":"组合优化","permalink":"http://suzhouxing.github.io/techive/tags/组合优化/"},{"name":"算法挑战","slug":"算法挑战","permalink":"http://suzhouxing.github.io/techive/tags/算法挑战/"}]},{"title":"用 Gitea 搭建自己的 Git 服务器","slug":"SetupGitServerWithGitea","date":"2019-10-17T06:18:36.000Z","updated":"2019-10-17T09:06:06.683Z","comments":true,"path":"2019/10/17/SetupGitServerWithGitea/","link":"","permalink":"http://suzhouxing.github.io/techive/2019/10/17/SetupGitServerWithGitea/","excerpt":"","text":"在永恒之蓝等通过网络文件共享传播的病毒肆虐之后, 很多网络供应商都封禁了文件共享相关端口, 以至于无法简单地通过映射网络驱动器来搭建 Git 的远端仓库, 然后使用 \"哑协议\" 执行 clone, push, pull 等操作. 因此, 我们可能需要使用支持 http 或者 ssh 的 Git 服务器. 目前功能最强大的免费 Git 服务器为 Gitlab, 它可以让用户自己搭建与 https://github.com 或者 https://gitlab.com 一样的网站. 但 Gitlab 不支持免费用于商业用途. 此外, 同类开源或免费软件还有 Bonobo, Gogs, SCM-Manager, Gitblit 等. Windows 环境下操作步骤 第三方库依赖 安装 Git 在官方网站下载最新版安装包 双击运行安装包按照安装向导的提示点下一步即可 基本流程 在官方网站或者 Github 的 release 页面下载最新版本 截至本文发布时最新版本为 gitea-1.9.4-windows-4.0-amd64.exe 将下载的文件重命名为 gitea.exe 并移动至任意目录下 (本文后续将使用 C:\\YOUR\\INSTALL\\PATH 作为安装目录, 读者请根据自己的情况将其替换为实际的路径) 以管理员身份打开命令行, 执行以下命令添加 Gitea 为 Windows 服务 sc create gitea start= auto binPath= \"\"C:\\YOUR\\INSTALL\\PATH\\gitea.exe\" web --config \"C:\\YOUR\\INSTALL\\PATH\\custom\\conf\\app.ini\"\" 详情请见 https://docs.gitea.io/zh-cn/windows-service/ 在 PowerShell 中执行上述命令可能会失败, 需要使用经典的 cmd 假设使用的管理员账号为 admin, 密码为 123, 后面其他地方要用时最好保持一致 如果该服务未自动启动, 在 Windows 的服务列表中找到 gitea 并启动 以管理员身份打开服务列表 开始按钮上点右键 -&gt; 计算机管理 -&gt; 服务和应用程序 -&gt; 服务 Ctrl+Shift+Esc 打开任务管理器 -&gt; 服务 -&gt; 打开服务 控制面板 -&gt; 系统和安全 -&gt; 管理工具 -&gt; 服务 建议在 gitea 服务上点右键 -&gt; 属性 -&gt; 登陆 -&gt; 此账户, 设置账户为之前使用的管理员账户 admin, 然后重启服务 在浏览器中访问默认的地址 http://localhost:3000 打开网页端, 点击注册按钮 第一次点击注册时将进入初始配置页面 数据库推荐选择 SQLite3, 数据库路径建议使用默认的安装目录下的子目录 站点名称 随便填 仓库根目录 建议更改至安装目录下, 例如 C:\\YOUR\\INSTALL\\PATH\\data\\repo 以用户名运行 建议使用上面用过的管理员账号 admin 把 SSH 服务域名 和 Gitea 基本 URL 中的 localhost 替换为服务器的 IP 地址或域名 端口根据个人偏好设置, 设为 80 的话以后的仓库链接可以省略端口号, 但是有和其他 web 服务冲突的可能性, 建议使用默认端口 可选设置中的 管理员账号设置 为 Gitea 网页端的管理员, 不是操作系统的管理员, 如果此时不设置则第一个注册的用户将自动成为管理员 再次点击注册, 完成用户注册 疑难解答 更改配置 在 C:\\YOUR\\INSTALL\\PATH\\custom\\conf\\app.ini 文件中修改相关项目 网页端地址或者代码仓库地址前缀: ROOT_URL, DOMAIN, SSH_DOMAIN 端口: HTTP_PORT, SSH_PORT 参考资料 https://docs.gitea.io/zh-cn/customizing-gitea/ https://docs.gitea.io/zh-cn/config-cheat-sheet/ https://github.com/go-gitea/gitea/blob/master/custom/conf/app.ini.sample 局域网或者互联网上其他机器无法访问网页端 添加防火墙放行规则 控制面板 -&gt; 系统和安全 -&gt; Windows Defender 防火墙 -&gt; 允许应用或功能通过 Windows Defender 防火墙 -&gt; 更改设置 -&gt; 允许其他应用 -&gt; 浏览 -&gt; 选中 C:\\YOUR\\INSTALL\\PATH\\gitea.exe -&gt; 网络类型 -&gt; 确保公用和专用均被勾选 更换端口 咨询单位网管或互联网服务提供商 初始化设置时无法创建数据库 设置 gitea 服务以管理员账号启动 安装 SQLite3 从官方网站下载 SQLite3 截至本文发布时最新版本为 sqlite-dll-win64-x64-3300100.zip 将压缩包内的文件解压至任意目录下 本文后续将使用 C:\\SQLITE3\\INSTALL\\PATH 作为安装目录, 读者请根据自己的情况将其替换为实际的路径 在环境变量 Path 中添加安装目录 控制面板 -&gt; 系统和安全 -&gt; 系统 -&gt; 高级系统设置 -&gt; 环境变量 -&gt; 系统变量 -&gt; 双击变量 Path 新建一行 C:\\SQLITE3\\INSTALL\\PATH 或者在变量值字符串开头添加 C:\\SQLITE3\\INSTALL\\PATH;","categories":[{"name":"技术","slug":"技术","permalink":"http://suzhouxing.github.io/techive/categories/技术/"}],"tags":[{"name":"技术","slug":"技术","permalink":"http://suzhouxing.github.io/techive/tags/技术/"},{"name":"Git","slug":"Git","permalink":"http://suzhouxing.github.io/techive/tags/Git/"},{"name":"Gitea","slug":"Gitea","permalink":"http://suzhouxing.github.io/techive/tags/Gitea/"}]},{"title":"组合优化 (五) 数学规划进阶","slug":"Opt-AdvancedMathematicalProgramming","date":"2019-01-13T03:14:59.000Z","updated":"2019-10-22T06:06:32.205Z","comments":true,"path":"2019/01/13/Opt-AdvancedMathematicalProgramming/","link":"","permalink":"http://suzhouxing.github.io/techive/2019/01/13/Opt-AdvancedMathematicalProgramming/","excerpt":"","text":"虽然目前最顶尖的商业求解器已经非常高效, 直接求解完整的问题模型往往比普通人自己实现算法性能更好, 但是面对特定的问题, 仍然有改进空间. 另一方面, 先贤们告诉我们要站在巨人的肩膀上, 要重用前人的优秀成果. 于是, 我们可以得到一个在完全自行设计算法和完全使用通用求解器之间的折中的方案, 发挥多种方法各自的优势, 更好地解决问题. 线性规划与混合整数规划 (进阶技巧) 非线性表达式 可以转化为线性表达式的非线性表达式 最大值最小值 绝对值 分段线性函数 ... 可以较高效求解的非线性表达式 Quadratic Program (QP) Special Ordered Set (SOS) Mixed Integer Program (MIP) ... 详见 [1.5] 线性化非线性表达式.docx. 最小化最大值 使用一个辅助变量限制决策变量的界 约束的可行区域应与优化方向 \"相反\" 最小化一个表达式 \\(l = f(x)\\), 应该确定 \\(l\\) 的下界, 即 \\(g(x) \\le l \\le +\\infty\\) 最大化一个表达式 \\(u = f(x)\\), 如果只约束其下界, 将导致目标无限增大 最小化最小值 最小值的下界? 让较大的值都可以忽略 Big-M (充分大的 M) 课堂练习 最大化最大值? 最大化绝对值? 多目标 线性加权模式 简单, 本质上就是单目标 各目标量纲不同时难以确定权重系数 优先级模式 高优先级对低优先级有压倒性优势 高优先级目标有一定的绝对/相对容差范围 实现优先级模式 使用线性加权模式模拟 难以确定各目标的取值范围以形成隔离 目标过多容易溢出或者产生巨大的数值误差 迭代求解 按优先级逐个优化 每个目标算到最优解后根据容差范围添加约束限制目标函数的取值 求解性能依赖热启动 (warm start) 效果 约束类型 类型 特征 最优性 完整性 检查时间 被忽略 user cut 排除显然不可能最优的解向量 不改变最优解 不影响模型的完整性 可能在任意时刻被检查 可能 lazy constraint 最优解不太可能违反的约束 会改变最优解 影响模型的完整性 仅在找到解时才被检查 不会 constraint 容易与优化目标产生冲突的约束 会改变最优解 影响模型的完整性 在任意时刻都会被检查 不会 注: 在 MIP 中, 整数解才是原始问题的解, 故在找到松弛的实数解时不会触发惰性约束. 以下为 CPLEX 对惰性约束和用户割平面的介绍: In contrast to the cuts that IBM ILOG CPLEX may automatically add while solving a problem, user cuts are those cuts that a user defines based on information already implied about the problem by the constraints; user cuts may not be strictly necessary to the problem, but they tighten the model. Lazy constraints are constraints that the user knows are unlikely to be violated, and in consequence, the user wants them applied lazily, that is, only as necessary or not before needed. User cuts can be grouped together in a pool of user cuts. Likewise, lazy constraints can also be grouped into a pool of lazy constraints. Cuts may resemble ordinary constraints, but are conventionally defined to mean those which can change the feasible space of the continuous relaxation but do not rule out any feasible integer solution that the rest of the model permits. A collection of cuts, therefore, involves an element of freedom: whether or not to apply them, individually or collectively, during the optimization of a MIP model; the formulation of the model remains correct whether or not the cuts are included. This degree of freedom means that if valid and necessary constraints are mis-identified by the user and passed to CPLEX as user cuts, unpredictable and possibly incorrect results could occur. By contrast, lazy constraints represent simply one portion of the constraint set, and the model would be incomplete (and possibly would deliver incorrect answers) in their absence. CPLEX always makes sure that lazy constraints are satisfied before producing any solution to a MIP model. Needed lazy constraints are also kept in effect after the MIP optimization terminates, for example, when you change the problem type to fixed-integer and re-optimize with a continuous optimizer. Another important difference between pools of user cuts and pools of lazy constraints lies in the timing by which these pools are applied. CPLEX may check user cuts for violation and apply them at any stage of the optimization. Conversely, it does not guarantee to check them at the time an integer-feasible solution candidate has been identified. Lazy constraints are only (and always) checked when an integer-feasible solution candidate has been identified, and of course, any of these constraints that turn out to be violated will then be applied to the full model. Cuts that are based on optimality and that remove integer feasible solutions without removing all optimal solutions are known as optimality-based cuts. Optimality-based cuts do not fit the definition of either a user cut nor a lazy constraint. For example, symmetry-breaking constraints are sometimes known as optimality-based cuts because symmetry-breaking constraints can remove integer feasible solutions without removing all optimal solutions. Symmetry-breaking constraints are not user cuts in the sense addressed here. Symmetry-breaking constraints are not necessarily lazy constraints either. However, CPLEX can support optimality-based cuts as lazy constraints. If you add an optimality-based cut as a lazy constraint in your model, you can also add it to the user cut pool. This practice of adding an optimality-based cut as a lazy constraint and simultaneously adding it to the user cut pool makes sure that CPLEX checks the optimality-based cut at each node relaxation as well as when CPLEX finds an integer feasible solution. Another way of comparing these two types of pools is to note that the user designates constraints as lazy in the strong hope and expectation that they will not need to be applied, thus saving computation time by their absence from the working problem. In practice, it is relatively costly (for a variety of reasons) to apply a lazy constraint after a violation is identified, and so the user should err on the side of caution when deciding whether a constraint should be marked as lazy. In contrast, user cuts may be more liberally added to a model because CPLEX is not obligated to use any of them and can apply its own rules to govern their efficient use. user cut 与约束编程 (Constraint Programming) 中的 surrogate constraints 功能类似: Since constraint propagation decreases the size of the search space by reducing the domains of variables, it is obviously important to express all necessary constraints. In some cases, it is even a good idea to introduce implicit constraints to reduce the size of the search space by supplementary propagation. Processing supplementary constraints inevitably slows down execution. However, this slowing down may be negligible in certain problems when it is compared with the efficiency gained from reducing the size of the search space. A surrogate constraint makes explicit a property that satisfies a solution implicitly. Such a constraint should not change the nature of the solution, but its propagation should delimit the general shape of the solution more quickly. Of course, there is no need to express grossly obvious redundant constraints since the highly optimized algorithms that CP Optimizer uses to insure arc consistency already work well enough. For example, given this system of equations: \\(x = y + z\\) \\(z = a + b\\) no efficiency whatsoever is gained by adding this constraint: \\(x = y + a + b\\) However, in any case where an implicit property makes good sense, or derives from experience, or satisfies formal computations, its explicit implementation as a surrogate constraint can be beneficial. Consider the problem of the magic sequence. Assume that there are n+1 unknowns, namely, \\(x_0, x_1, . . . , x_n\\). These \\(x_i\\) must respect the following constraints: 0 appears \\(x_0\\) times in the solution. 1 appears \\(x_1\\) times. In general, \\(i\\) appears \\(x_i\\) times. \\(n\\) appears \\(x_n\\) times. The constraint of this problem can easily be written, using the specialized distribute constraint. However, the search for a solution can be greatly accelerated by introducing the following surrogate constraint that expresses the fact that \\(n+1\\) numbers are counted. \\(1*x_1 + 2*x_2 + . . . + n*x_n = n+1\\). 列生成 (Column Generation) 如果说 TSP 中经典的子回路消除 (割平面法) 是一种逐步添加惰性约束的 \"行生成\" 算法, 那么其对偶算法就是逐步添加决策变量的 \"列生成\" 算法. 前者适用于原始问题约束非常多, 但是真正对限制最优解的取值发挥作用的重要约束很少的情况; 后者则恰好相反, 适用于决策变量非常多, 但大多数决策变量的子集的取值组合不可能出现在最优解中的情况. 原理 给定主问题及其对偶问题的线性规划模型 \\[ \\begin{align} \\min &amp; &amp; \\mathbf{c}^{T} \\mathbf{x} &amp; &amp; &amp; &amp; \\max &amp; &amp; \\mathbf{y}^{T} \\mathbf{b}\\\\ s.t. &amp; &amp; \\mathbf{A} \\mathbf{x} \\ge \\mathbf{b} &amp; &amp; \\Leftrightarrow &amp; &amp; s.t. &amp; &amp; \\mathbf{y}^{T} \\mathbf{A} \\le \\mathbf{c}^{T}\\\\ &amp; &amp; \\mathbf{x} \\ge \\mathbf{0} &amp; &amp; &amp; &amp; &amp; &amp; \\mathbf{y} \\ge \\mathbf{0} \\end{align} \\] 令 \\(\\mathbf{x}^{T} = [\\mathbf{x}^{T}_{B}, \\mathbf{x}^{T}_{N}]\\), 其中 \\(\\mathbf{x}_{B}\\) 表示基向量, \\(\\mathbf{x}_{N}\\) 表示非基变量. 对应地, \\(\\mathbf{A} = [\\mathbf{B}, \\mathbf{N}]\\), \\(\\mathbf{c} = [\\mathbf{c}_{B}, \\mathbf{c}_{N}]\\). 对约束进行如下等价变换 \\[ \\mathbf{A} \\mathbf{x} \\ge \\mathbf{b} ~~\\Leftrightarrow~~ \\mathbf{B} \\mathbf{x}_{B} + \\mathbf{N} \\mathbf{x}_{N} \\ge \\mathbf{b} ~~\\Leftrightarrow~~ \\mathbf{x}_{B} \\ge \\mathbf{B}^{-1} \\mathbf{b} - \\mathbf{B}^{-1} \\mathbf{N} \\mathbf{x}_{N} \\] 将上式代入目标函数 \\[ \\mathbf{c}^{T} \\mathbf{x} ~~=~~ \\mathbf{c}^{T}_{B} \\mathbf{x}_{B} + \\mathbf{c}^{T}_{N} \\mathbf{x}_{N} ~~\\ge~~ \\mathbf{c}^{T}_{B} (\\mathbf{B}^{-1} \\mathbf{b} - \\mathbf{B}^{-1} \\mathbf{N} \\mathbf{x}_{N}) + \\mathbf{c}^{T}_{N} \\mathbf{x}_{N} ~~=~~ \\mathbf{c}^{T}_{B} \\mathbf{B}^{-1} \\mathbf{b} + (\\mathbf{c}^{T}_{N} - \\mathbf{c}^{T}_{B} \\mathbf{B}^{-1} \\mathbf{N}) \\mathbf{x}_{N} \\] 定义目标函数中非基变量的系数 Reduced Cost 为 \\[ \\mathbf{r} = \\mathbf{c}^{T}_{N} - \\mathbf{c}^{T}_{B} \\mathbf{B}^{-1} \\mathbf{N} \\] 若 \\(\\exist \\mathbf{N}_{i} \\in \\mathbf{N}\\) 满足 \\(\\mathbf{r}_{i} &lt; 0\\), 则可通过增加非基变量 \\(\\mathbf{x}_{i}\\) 的值实现降低目标函数值. 若不存在这样的项, 即 \\(\\forall \\mathbf{N}_{i} \\in \\mathbf{N}, \\mathbf{c}^{T}_{i} - \\mathbf{c}^{T}_{B} \\mathbf{B}^{-1} \\mathbf{N}_{i} \\ge 0\\), 则 \\([\\mathbf{x}_{B}, \\mathbf{0}]\\) 为最优解. 由 Complementary Slackness 定理可知 \\(\\mathbf{y}^{T} = \\mathbf{c}^{T}_{B} \\mathbf{B}^{-1}\\), 由此可得 \\(\\mathbf{r} = \\mathbf{c}^{T}_{N} - \\mathbf{y}^{T} \\mathbf{N}\\). 则寻找可最大程度改进当前解的非基变量的子问题目标函数为 \\(\\min \\mathbf{c}^{T}_{N} - \\mathbf{y}^{T} \\mathbf{N}\\). \\(~~~~\\) (本节内容基于 https://zhuanlan.zhihu.com/p/55424545 整理) 附: Complementary Slackness 定理证明过程 (可能有问题): 令 \\(\\mathbf{y}^{T} = \\mathbf{c}^{T}_{B} \\mathbf{B}^{-1}\\), 对于限制主问题的最优解 \\(\\mathbf{x}\\), 有 \\(\\mathbf{x}_{N} = \\mathbf{0}\\), 以及 \\(\\mathbf{c}^{T}_{B} \\mathbf{B}^{-1} \\mathbf{N} \\le \\mathbf{c}^{T}_{N}\\), 可得 \\[ \\mathbf{y}^{T} \\mathbf{A} ~~=~~ \\mathbf{c}^{T}_{B} \\mathbf{B}^{-1} \\mathbf{A} ~~=~~ \\mathbf{c}^{T}_{B} \\mathbf{B}^{-1} [\\mathbf{B}, \\mathbf{N}] ~~=~~ [\\mathbf{c}^{T}_{B}, \\mathbf{c}^{T}_{B} \\mathbf{B}^{-1} \\mathbf{N}] ~~\\le~~ [\\mathbf{c}^{T}_{B}, \\mathbf{c}^{T}_{N}] ~~=~~ \\mathbf{c}^{T} \\] \\[ \\mathbf{y}^{T} \\mathbf{b} ~~=~~ \\mathbf{c}^{T}_{B} \\mathbf{B}^{-1} \\mathbf{b} ~~=~~ \\mathbf{c}^{T}_{B} \\mathbf{x}_{B} ~~=~~ \\mathbf{c}^{T} \\mathbf{x} \\] 即 \\(\\mathbf{y}^{T}\\) 为限制对偶问题的最优解. 线性分数规划 (Linear-Fractional Programming) 目标函数为分数形式. 可以转换成线性规划.","categories":[{"name":"技术","slug":"技术","permalink":"http://suzhouxing.github.io/techive/categories/技术/"}],"tags":[{"name":"技术","slug":"技术","permalink":"http://suzhouxing.github.io/techive/tags/技术/"},{"name":"建模","slug":"建模","permalink":"http://suzhouxing.github.io/techive/tags/建模/"},{"name":"数学","slug":"数学","permalink":"http://suzhouxing.github.io/techive/tags/数学/"},{"name":"优化","slug":"优化","permalink":"http://suzhouxing.github.io/techive/tags/优化/"}]},{"title":"组合优化 (四) 算法工程","slug":"Opt-SoftwareEngineering","date":"2019-01-13T03:14:16.000Z","updated":"2019-10-22T06:07:46.645Z","comments":true,"path":"2019/01/13/Opt-SoftwareEngineering/","link":"","permalink":"http://suzhouxing.github.io/techive/2019/01/13/Opt-SoftwareEngineering/","excerpt":"","text":"算法研发和常规软件开发十分相似, 但也有很多区别. 大多数工程项目往往更注重正确性, 为了提升代码的健壮性与可维护性, 可以适当牺牲性能. 而设计精妙的高效而复杂算法代码往往具有极高的耦合度, 难以进行系统的单元测试. 此外, 算法面临的需求往往不那么简单直接, 不是梳理清楚了业务逻辑就能欢快地敲代码了的. 算法研发真的这么任性吗? 软件工程 文档 需求分析 相关技术调研 自然语言描述 基本概念定义 建模四要素 输入输出数据约定 用户手册 概要设计 接口定义 功能覆盖 算法设计 技术规范 模块划分 处理流程 测试分析 测试环境 测试用例 测试结果 正确性分析 优度分析 速度分析 算例设计 格式要求 自文档 跨平台 推荐格式: protobuf, json 结构和规模可控 拓扑设计 特殊结构: 树形, 窄总线型, 宽总线型, 关键节点, 局部密度高整体密度低, 有向无环图 部分边权重特别大 (出现整数上溢) 算法工程 相关工具 版本控制工具 git (主流) svn mercurial 适合与版本控制工具配合使用的文档撰写工具 Markdown 一种功能非常精简的标记语言 https://guides.github.com/features/mastering-markdown/ LaTeX 功能强大的标记语言 同样适用于科技论文写作 数学规划求解器 -- 完成需求分析即完成项目! Gurobi 目前最高效的求解器 支持免费学术许可证申请 CPLEX IBM旗下的\"行业标准\" SCIP 号称最快的开源求解器 Coin-OR 功能繁多的开源运筹学工具包 开发 代码可读性 使用版本控制减少被注释掉的代码 (文档性注释不受该要求影响) 使用有具体意义的单词作为标识符以减少臃肿的注释 使用自动排版工具调整代码格式 合理的功能模块划分和封装以避免过长的函数 (但是有时真的无法避免) 自动化测试 使用配置文件 方案选择 (使用配置文件将导致代码过于臃肿时可以考虑预处理语句) 参数设置 算例选择 建议使用json文件格式 自动批量测试 计算结果合法性检验 计算结果目标函数值正确性检验 独立重复运行 多个算例 多个配置 多线程 (注意写同一个日志文件时应加入互斥机制) 运行日志 原始日志 能够评价每次运行的时空开销与解的质量 能够还原求解过程和结果 (随机种子, 运行时间, 迭代次数, 宏开关状态, 参数设置...) 建议使用csv文件进行组织 初步加工 多阶段问题整合各阶段的数据得到整个周期的结果 举例 结果分析 初步统计 极值, 均值, 方差, 耗时... ClosedXML编辑xlsx文件 对比分析 在所有算例上的综合评价方案/参数好坏的策略 Excel条件格式, 排序, Excel录制宏 举例 算法工程模块清单 通用 验证程序 合法性 目标函数值计算正确 日志记录 统计分析 求解器 数学模型 编程实现 启发式 初始解 随机 贪心 局部搜索 邻域评估 增量评估 邻域动作目标函数增量缓存 邻域动作优先队列 邻域动作选择 邻域动作执行 禁忌策略 禁忌表 解禁策略 扰动策略","categories":[{"name":"技术","slug":"技术","permalink":"http://suzhouxing.github.io/techive/categories/技术/"}],"tags":[{"name":"技术","slug":"技术","permalink":"http://suzhouxing.github.io/techive/tags/技术/"},{"name":"软件工程","slug":"软件工程","permalink":"http://suzhouxing.github.io/techive/tags/软件工程/"}]},{"title":"组合优化 (三) 算法简介","slug":"Opt-AlgorithmDesign","date":"2019-01-13T03:13:02.000Z","updated":"2021-09-14T09:21:17.554Z","comments":true,"path":"2019/01/13/Opt-AlgorithmDesign/","link":"","permalink":"http://suzhouxing.github.io/techive/2019/01/13/Opt-AlgorithmDesign/","excerpt":"","text":"由于生产实践中面临的绝大多数具有实际意义的组合优化问题都已经在理论上被证明属于难以使用可接受的计算资源在可接受的时间内求解的 NP-Hard 问题, 其求解算法不像 P 问题一样存在标准答案. 此外, 在实际的工业应用中, 由于未来的不确定性以及评价指标常常无法完美量化等问题, 耗费大量计算资源和时间精确求出最优解几乎没有实际意义. 所以, 组合优化算法的设计往往是在优度与速度之间寻找平衡点. 算法设计 预处理 (Preprocess) 缩减问题规模 (Reduction) 参考文献: Polynomial-time data reduction for dominating set 加载用户参数与算法默认参数 初始化辅助数据结构 精确算法 (Exact Algorithms) 分支限界 (Branch and Bound) 分支策略 (Branching) 深度优先 (Depth-First Search) 广度优先 (Breadth-First Search) 优度优先 (Best-First Search) 剪枝策略 (Pruning) 可行性剪枝 (Feasibility Pruning) 上下界剪枝 (Bound Pruning) (最小化问题) 当前目标函数值 + 剩余部分下界 &lt; 上界 A* 算法实质上是该策略在特定问题上的一种高效实现 支配性剪枝 (Dominance Pruning) 动态规划实质上是将该策略发挥到了极致 参考文献: On an exact method for the constrained shortest path problem 线性规划与混合整数规划求解算法 (Mathematical Programming) 单纯形法 (Simplex Method) 内点法 (Interior Point Method, Barrier Method) 分支切割/割平面法 (Branch and Cut, Cutting Plane Method) 分支定价/列生成 (Branch and Price, Column Generation) 动态规划 (Dynamic Programming) 递推函数 (Recursive Formulation) 重叠子问题/最优子结构 (Overlapping Subproblem, Optimal Substructure) 其他经典算法 最大流 (Maximum Flow) 最小费用流 (Minimum-Cost Flow) 完美匹配/最大匹配 (Perfect Matching, Maximum Matching, Assignment Problem) 参考文献 http://theory.stanford.edu/~amitp/GameProgramming/ https://www.redblobgames.com/pathfinding/a-star/introduction.html https://www.redblobgames.com/pathfinding/a-star/implementation.html 元启发式算法 (Metaheuristics) 概述 分类 基本思想 在 系统地探索整个解空间 和 盲目地探索邻近的解空间 之间寻找平衡点 集中性 (Intensification) 与 疏散性 (Diversification) 的平衡 也称为 探索 (Exploration) 与 利用 (Exploitation) 的平衡 时空开销 (Complexity) 与 求解质量 (Quality) 的平衡 邻域动作 (Neighborhood Move): 尝试对解向量做微小的改变 在一次迭代中每一个决策变量都可以改变: 精确算法 在一次迭代中仅改变一个决策变量: 原子邻域动作 寻找两者的平衡点: 集中性与疏散性的平衡 迭代禁忌搜索过程 使用贪心算法或随机生成一个初始解 每次从当前解移动到某个邻居解 (Neighboring Solution), 直至一定步数不能改进 然后进行扰动, 贪心或随机地对更改部分解向量, 重复上述过程 元启发式算法框架 算法层为整个程序的框架, 比如迭代局部搜索, 遗传算法, 混合进化算法等. 算法层决定了使用那些搜索策略, 搜索策略之间以什么次序出现, 各搜索策略的初始解, 各搜索策略的停止策略参数控制 (停止条件), 整个算法的停止条件等. 搜索层是具体的搜索算法, 执行一次搜索会产生一条搜索路径 (Trajectory). 随机游走, 模拟退火, 局部搜索, 禁忌搜索等都是搜索层的组件. 从广义上来说, 构造初始解, 迭代局部搜索中的扰动过程, 遗传算法中的交叉算子都是搜索层的组件. 在搜索过程中, 要考虑的主要问题是每次迭代选择什么邻域结构进行探索, 以及决定停止搜索的策略. 比如TS的停止策略是一定步数未改进就停止, 而停止条件是一个特定的最大未改进步数具体取值. 邻域动作选择一般是搜索过程中对算法性能影响最大的模块. 它通过循环调用邻域动作评估层的组件对考虑范围之内的邻域动作对目标函数值的改变情况进行评估, 然后按照某种策略挑选其中的一个动作. 最常见的挑选策略有 首次改进 (First Improvement) 和 最优改进 (Best Improvement). 此外, 还可以有导向性地或者随机地在整个邻域中挑选一部分邻域动作进行评估. 邻域动作评估可以是结合特殊的数据结构进行增量评估或者全部重算. 在绝大多数情况下增量评估的速度会远快于全部重算. 邻域动作的执行比较简单, 主要有更新解向量, 更新辅助数据结构, 更新禁忌表, 更新缓存和更新历史最优解等操作. 其中更新历史最优主要是处理目标函数值相同的情况, 可以随机选择, 也可以设计辅助目标函数进行处理. 邻域动作举例 Boolean Satisfiability Problem (SAT) Graph Coloring Problem P-Center Problem Personnel Scheduling Prblem Traveling Salesman Problem 常用算法 提升算法 (Trajectory-Based Methods) 迭代禁忌搜索 模拟退火 (类似 Epsilon-Greedy 策略) 拍卖算法/地貌调整/格局检测 (Auction Algorithm, Landscape Adjustment, Configuration Checking) 提升反复出现的惩罚项在目标函数中的权重实现 \"软\" 禁忌 例如图着色中令 反复出现的 或者 局部最优解中的 冲突边的计 1.01 条冲突边 种群算法 (Population-Based Methods) 混合进化算法/模因算法 (Hybrid Evolutionary Algorithm, Memetic Algorithm), 遗传算法 (Genetic Algorithm) 蚁群, 蜂群, 粒子群 (与强化学习十分相似) 初始解 (Initial Solution Generation) 贪心 (Greedy) 有利于快速收敛 (Fast Convergence) 不利于初始解的多样性 随机 (Random) 禁忌搜索 (Tabu Search) 邻域结构 (Neighborhood Structure) 设计 原子邻域动作 添加, 删除, 更换, 交换, 移动, ... 复合邻域动作 块交换, 块移动 大邻域搜索 (Large Neighborhood Search) 弹射链 (Ejection Chain) 邻域评估 (Neighborhood Evaluation): 目标函数值改进量计算 增量评估 (Incremental Evaluation): 因为仅对解向量做了微小的改变, 所以目标函数中大多数项目并未改变 邻域缓存 (Cache): 在邻域动作执行后, 大多数邻域动作与被改变的决策变量并不相关, 其增量无需重新计算, 故可以将其缓存起来 主动更新 (Active Update): 每次执行邻域动作后更新所有相关动作的增量 惰性更新 (Lazy Update): 使用标记位记录缓存是否失效, 需要比较相关动作的增量时再更新 启用了邻域精简或抽样策略时才有惰性更新的必要 邻域动作选择策略 单个邻域 (直接选择邻域动作) 首次改进 (First Improvement) 记录上一轮的评估进度直接从下一个动作开始, 循环评估所有动作 每次从随机位置开始依次评估所有邻域动作 最大改进 (Best Improvement) 多个目标函数增量相同的最优动作随机选择一个 在线选择 (Online Selection): 水塘抽样 (Reservoir Sampling) 邻域精简/候选动作集 (Neiborhood Reduction, Candidate Set) 根据特定策略筛选排除显然没有改进潜力的动作 邻域近似评估 (Neihborhood Estimation, Approximate Evaluation) 根据其他辅助指标快速对所有动作排序, 仅对排名靠前的若干动作进行精确评估 邻域抽样 (Neighborhood Sampling) 多邻域 (先选出邻域结构再选择动作) 评估所有邻域的所有动作 可以结合邻域抽样随机挑选部分动作 变邻域搜索 (Variable Neighborhood Search) 根据适应性选择最合适的邻域 根据历史改进情况调整各邻域权重, 然后采用轮盘赌 (Roulette Wheel) 选择其中一个 等概率随机选择 优先队列优化: 避免遍历整个邻域, 直接在 O(1) 时间内挑选最优动作 一般使用桶队列 (Bucket Queue) 等基于基数排序 (Radix Sort) 的优先队列实现 (而非基于比较的树状优先队列) 往往与邻域缓存结合使用, 实现惰性更新优先队列中的键值对 禁忌策略 禁忌表 如果一个邻域动作被执行则禁止其逆操作在短时间内被选中 刚增加则禁止马上被删除 刚交换防止马上被换回来 禁忌步长 (Tabu Tenure) 可能与问题规模, 禁忌表大小, 目标函数值, 邻域动作出现次数相关 一般需要加上随机成分 具体实现时将禁忌多久转换为什么时候解禁 解禁策略/特赦准则 (Aspiration Criteria) 如果被禁忌的邻域动作是当前邻域的最优动作且能够改进历史最优解则允许其被执行 扰动 (Perturbation) 重新构造初始解 (Random Restart) 需要初始解生成程序具有一定的随机性 与之前的搜索完全无关, 无法利用已有的搜索结果 贪心或随机地更改解向量中的部分元素 随机执行邻域动作 (Random Walk) 交叉算符 (Crossover Operator) 将多个解向量中较优的子结构进行组合 图着色禁忌搜索算法总结 重新统计每个邻域动作的改进量代价太大 改变一个节点的颜色在稀疏图上对整体格局影响很小 =&gt; 记录个节点各种颜色的相邻节点的数量 (即变成各种颜色引入的冲突数量) 使用新颜色相邻节点数减去旧颜色相邻节点数快速计算改进量 每次遍历所有动作中挑选最优动作代价太大 大多数动作显然不可能产生改进 =&gt; 仅评估有冲突的节点 使用优先队列每次直接取出最优动作 非禁忌优先队列 + 禁忌优先队列 + 待解禁循环队列 使用相邻颜色表校验出队动作实现惰性更新优先队列 混合整数规划 (Mixed-Integer Programming) 概述 对于一组给定的自变量, 确定其取值, 使其在满足给定不等式组的前提下, 给定的函数取到最小值 决策变量的定义域可以是实数 (连续变量) 也可以是整数 (离散变量) 编程范式与原理简介 http://www.gurobi.com/resources/getting-started/lp-basics http://www.gurobi.com/resources/getting-started/mip-basics 不同的表现形式 线形规划模型的标准形式 图形表示 矩阵表示 使用方法 使用专门的建模语言 https://www.gurobi.com/documentation/6.5/refman/model_file_formats.html 举例: coin &amp; qafiro 使用命令行接口 使用应用程序接口 添加决策变量 添加目标函数 添加约束 求解 获取决策变量取值 贪心算法与近似算法 (Approximate Algorithm) 贪心算法可视为不回溯的优度优先搜索 近似算法是一类特殊的贪心算法 近似比 (Approximation Ratio): 最坏情况下贪心解离最优解的差距 算法运行模式对比 树搜索 动态规划 局部搜索 树搜索与局部搜索 局部搜索虽然名字里有 \"局部\", 但是从某种意义上来说反而很全局——可以对解向量的任意位置进行修改. 以最小化问题为例, 局部搜索关注上界, 是真实可行的解的目标函数值, 更适合实际应用. 树搜索关注下界, 是理论上最优的解的目标函数值, 更适合理论分析. 更宏观的算法设计 简化问题模型, 将其转换为可高效 (精确) 求解的经典问题, 获得较好格局后再修复细节. 固定部分决策. 类比: 导师提出求解思路, 学生只需顺着思路实现, 比自己从头设计算法更容易出成果. 松弛部分约束. 类比: 两个城市之间的通勤时间与直线距离除以交通工具的速度差别不大. 忽略部分目标函数成份. 类比: 地表附近计算重力无需考虑万有引力甚至相对论效应.","categories":[{"name":"技术","slug":"技术","permalink":"http://suzhouxing.github.io/techive/categories/技术/"}],"tags":[{"name":"技术","slug":"技术","permalink":"http://suzhouxing.github.io/techive/tags/技术/"},{"name":"建模","slug":"建模","permalink":"http://suzhouxing.github.io/techive/tags/建模/"},{"name":"数学","slug":"数学","permalink":"http://suzhouxing.github.io/techive/tags/数学/"},{"name":"优化","slug":"优化","permalink":"http://suzhouxing.github.io/techive/tags/优化/"}]},{"title":"组合优化 (二) 数学建模基础","slug":"Opt-MathematicalProgramming","date":"2019-01-13T03:10:16.000Z","updated":"2019-10-22T06:05:55.264Z","comments":true,"path":"2019/01/13/Opt-MathematicalProgramming/","link":"","permalink":"http://suzhouxing.github.io/techive/2019/01/13/Opt-MathematicalProgramming/","excerpt":"","text":"面对一个复杂的组合优化问题, 把它描述清楚本身就不是一个简单的问题. 常规开发往往允许模棱两可的描述, 需求修修补补虽然很烦, 但往往只是工作量的问题. 而算法研发由于其专用性, 细微的需求变化可能导致一个算法完全失效, 除非重新设计整个框架不然无法解决新的问题. 所以, 严谨的需求分析或问题描述对于算法研发格外重要. 对于一个组合优化问题, 我们一般使用数学规划的形式化语言对其进行无二义性的定义, 作为算法工程中的需求分析文档. 需求分析 为什么要做需求分析 研究一个课题的目的: 实现一个好的系统 什么样的系统是好系统: 按事先制定的标准进行评价 标准从哪里来: 需求分析 如何评价一个系统的好坏 任务完成质量 (又快又好) 完成速度 完成效果 建设成本 运营成本 安全性 不受外部因素干扰 从错误中恢复 稳定性 (今天好, 明天也好; 这组数据好, 那组也好) 代码逻辑正确性 算法对各种场景的兼容性 静态多样性 动态随机性 简化问题 优度和速度的平衡不仅可以在问题求解的过程中, 还可以在问题定义时 简化问题会影响结果的正确性和优度 举例 宏观低速时使用经典力学而不是相对论 同时处理多个业务简化为分多次每次处理一个业务 减小负载和提升安全性转换为不重复经过节点 组合优化问题的需求分析 按形式化描述语言分类 数学规划 (Mathematical Programming) 线性规划 (Linear Programming) 混合整数规划 (Mixed-Integer Programming) QP, QCP, SOCP, LFP 约束编程 (Constraint Programming) 布尔表达式可满足性问题 (Boolean Satisfiability Problem) SAT Encoding MAX-SAT Encoding 规约 (Reduction) Karp's 21 NP-complete problems 动态规划 按应用场景分类 静态模型 随机规划 (Stochastic Programming) 鲁棒优化 (Robust Optimization) 线性规划与混合整数规划 思维方式 已知 约束和目标中的系数 决策 确定哪些可控因素需要做决策 定义域 布尔 / 整数 / 实数 上界 / 下界 从最根本的需求开始 显示决策 (根本需求) 隐式决策 (客户不关心但十分重要) 辅助决策 (将非线性约束转化为线性约束) 不够用再返回来补充 思考问题的角度影响决策变量的设置 图着色问题 每个节点染什么颜色 每种颜色的节点集合包含了哪些节点 每两个节点是否染了相同的颜色 旅行销售员问题 每个节点的第几个被访问 第几个被访问的节点是哪个节点 路径包含哪些边 布尔表达式可满足性问题 保证每个布尔变量在所有子句中取值一致，最大化为真的子句数量 保证每个子句均为真，最大化布尔变量的一致性 约束 决策变量组成的表达式满足的关系 等式或不等式 \\(f(x) ? g(x)\\) 下标的取值范围 \\(\\forall i \\in V\\) 可以和目标对调顺序, 谁简单先考虑谁 如何验证约束是否完备? 经验? 详尽的测试? ... 目标 不同决策变量取值组合产生的后果的优劣度量 冗余约束 (Redundant Constraints) 图着色问题的对称性消除 (Symmetric Breaking) 参考文献: A cutting plane algorithm for graph coloring 优化版本 O1 一个颜色至少被一个节点使用时才会被选中 \\[ y_{c} \\le \\sum_{n \\in N} x_{nc}, \\quad \\forall c \\in C \\] O2 编号更小的颜色未被选中时禁止选中编号更大的颜色 \\[ y_{c&#39;} \\ge y_{c}, \\quad \\forall c, c&#39; \\in C, c&#39; = c - 1 \\] 判定版本 D1 使用编号更小的颜色的节点数不小于使用编号更大的颜色的节点数 (使用某种颜色的节点数随颜色编号的增长单调变化) \\[ \\sum_{n \\in N} x_{nc&#39;} \\ge \\sum_{n \\in N} x_{nc}, \\quad \\forall c, c&#39; \\in C, c&#39; = c - 1 \\] D1 包含 O2 D2 节点不允许使用比其编号更大的颜色 \\[ x_{nc} = 0, \\quad \\forall n \\in N, c \\in C, n &lt; c \\] D3 编号更小的颜色未被编号更小的节点使用时禁止使用编号更大的颜色 (使用某种颜色的节点集中最小的节点编号随颜色编号的增长单调变化) \\[ \\sum_{n&#39; \\in [0, n)} x_{n&#39;c&#39;} \\ge x_{nc}, \\quad \\forall n \\in N, \\forall c, c&#39; \\in C, c&#39; = c - 1 \\] 与 D2 配合使用时, 将固定为 0 的项代入可化简为 \\[ \\sum_{n&#39; \\in [c&#39;, n)} x_{n&#39;c&#39;} \\ge x_{nc}, \\quad \\forall n \\in N, \\forall c, c&#39; \\in C, c&#39; = c - 1, n \\ge c \\] D3 与 D1 冲突 编程实现 求解器选择 Gurobi 目前最高效的线性规划/混合整数规划求解器 支持免费学术许可证申请 CPLEX IBM旗下的 \"行业标准\" SCIP 号称最快的开源求解器 COIN-OR 功能繁多的开源运筹学工具包 OR-Tools 开源经典组合优化算法库 提供统一的接口调用各大常见求解器 接口选择 编程语言接口 开发中最常用的接口 提供更高层次的抽象 更快的模型构建速度 C / C++ / Java / C# / Python / Matlab / R 模型文件接口 需要自己将模型展开为线性规划的标准型 文件 I/O 速度较慢 交互式命令行接口 (Gurobi) 类似于解释型的脚本语言 OPLIDE (CPLEX) 介于命令式语言与建模语言之间 Excel 插件 ... 使用编程语言接口的求解过程 (Gurobi) 参考自带的示例工程 diet, facility, mip1. 基本流程如下. 初始化环境 GRBEnv() 许可证检测 其他全局参数与数据初始化 初始化模型 GRBModel() 添加决策变量 GRBModel::addVar() 按照一定规律组织决策变量 使用额外的数据结构将决策变量与用户变量绑定 更新模型 GRBModel::update() 惰性更新提升效率 (最新版已无需手动调用该函数) CPLEX 不需要此步骤 设置目标 GRBModel::setObjective() 添加约束 GRBModel::addConstr() 设置其他参数 GRBModel::set(), GRBEnv::set() 运行时间 输出日志 求解 GRBModel::optimize() 检查求解状态 GRBModel::get(GRB_IntAttr_Status) 获取目标函数值 GRBModel::get(GRB_DoubleAttr_ObjVal) 获取解向量 GRBVar::get() 使用模型文件接口的求解过程 (Gurobi) 参考自带的示例工程 lp. 基本流程如下. 准备好 .mps 或 .lp 等模型文件 GRBModel::write() 一般由另外的程序输出 读取模型文件 GRBModel(), GRBModel::read() 求解并输出","categories":[{"name":"技术","slug":"技术","permalink":"http://suzhouxing.github.io/techive/categories/技术/"}],"tags":[{"name":"技术","slug":"技术","permalink":"http://suzhouxing.github.io/techive/tags/技术/"},{"name":"建模","slug":"建模","permalink":"http://suzhouxing.github.io/techive/tags/建模/"},{"name":"数学","slug":"数学","permalink":"http://suzhouxing.github.io/techive/tags/数学/"},{"name":"优化","slug":"优化","permalink":"http://suzhouxing.github.io/techive/tags/优化/"}]},{"title":"组合优化 (一) 简介","slug":"Opt-CombinatorialOptimization","date":"2019-01-13T03:07:22.000Z","updated":"2019-10-22T06:05:14.191Z","comments":true,"path":"2019/01/13/Opt-CombinatorialOptimization/","link":"","permalink":"http://suzhouxing.github.io/techive/2019/01/13/Opt-CombinatorialOptimization/","excerpt":"","text":"组合优化也叫离散优化, 是运筹优化的重要组成部分, 其中 \"组合\" 是排列组合的组合. 从字面上理解这个名词, 组合优化是要从呈组合数复杂度爆炸式增长的解空间中, 寻找最优的解向量, 即制定最优决策方案. 组合优化问题涉及了分配, 调度, 指挥, 路由等众多类型的问题. 作为人工智能的重要分支, 组合优化与时下大热的统计学习存在着千丝万缕的联系. 统计学习更侧重于预测和单步决策, 比如预测出了某件商品的销量, 就可以知道需要进多少货; 预测出了某个区域的人流量, 就可以知道需要分配多少保安巡逻; 检测出患者有某种疾病, 就可以知道要开什么药. 相比之下, 组合优化更注重涉及多方的, 全局的, 系统性的序列决策. 与此同时, 部分统计学习种的模型训练算法与求解组合优化问题的方法往往有异曲同工之妙, 因为离散优化与连续优化在思想上有很多相通之处. 组合优化基础 组合优化包含哪些问题 路由问题: 用开销最小的路径覆盖所有目的地 车辆路由 数据流量路由 指派问题: 在有限的时间和空间中合理使用软硬件资源创造更多的收益 时间指派 先后序调度 单机作业调度 车间流水线调度 时间槽分配 航班与列车时刻表 人员排班表 选修课表 空间指派 哪个背包装哪些物品: 背包问题 哪个处理器处理作业: 多机作业调度 哪个中心服务哪些客户: 中心选址 ... NP 完全 (NP-Complete) 问题可以在多项式时间内相互规约 如何定义一个问题 基本要素 已知: 输入数据 决策: 输出结果 约束: 输出结果可行还是不可行 目标: 输出结果好还是坏 观察问题的不同角度举例 图着色问题 每个节点染什么颜色 每种颜色的节点集合包含了哪些节点 布尔表达式可满足性问题 保证每个布尔变量在所有子句中取值一致, 最大化为真的子句数量 保证每个子句均为真, 最大化布尔变量的一致性 基本求解方法分类 贪心算法: 在保证求解速度的前提下提升优度 部分可以保证最优性的贪心算法往往也可以归类为动态规划 (例如 Dijkstra 最短路算法) 近似算法: 离最优解的差距有保障的贪心算法 精确算法: 在确保最优性的前提下降低复杂度 深度/广度/优度优先树搜索 动态规划 混合整数规划的求解算法 启发式算法: 在优度和复杂度之间寻找平衡点 基于邻域动作: 元启发式算法 单个解 (Trajectory): 局部搜索 多个解 (Population): 种群算法 基于树搜索 A* 启发函数可接受 (Admissible) 时为精确算法 向前看树搜索 (Lookahead Tree Search) 线搜索 (Beam Search) 蒙特卡洛树搜索 (Monte-Carlo Tree Search) 问题归约与转换 经典问题到现实问题 图着色 寄存器分配 寄存器 =&gt; 颜色 变量 =&gt; 节点 两个变量生命周期有交集 =&gt; 不能使用同一个寄存器 =&gt; 不能染同一种颜色 =&gt; 两个节点间有一条边 多业务波长分配 波长 =&gt; 颜色 路径 =&gt; 节点 两条路径有交集 =&gt; 不能使用同一个波长 =&gt; 不能染同一种颜色 =&gt; 两个节点间有一条边 停机位分配 停机位 =&gt; 颜色 飞机 =&gt; 节点 两架飞机过站时间有交集 =&gt; 不能停在同一停机位 =&gt; 不能染同一种颜色 =&gt; 两个节点间有一条边 宿舍分配 宿舍 =&gt; 颜色 学生 =&gt; 节点 两个学生作息规律差异很大 =&gt; 不能住同一间宿舍 =&gt; 不能然同一种颜色 =&gt; 两个节点间有一条边 旅行销售员 快递与外卖配送 物资采购 人类基因组计划 经典问题相互转换 独立集 &lt;=&gt; 最大团 &lt;=&gt; 顶点覆盖 =&gt; 支配集 &lt;=&gt; 集合覆盖 &lt;= 中心选址 . 非对称旅行商 &lt;=&gt; 对称旅行商 . 必经点最短简单路 =&gt; 非对称旅行商 &lt;=&gt; 最短简单路 &lt;=&gt; 最长简单路 必经点最短路 =&gt; 非对称旅行商 基本思路 增加一条无代价的旁路让所有非必经点能够通过该旁路被访问 从起点出发, 经过最短路上的实际节点序列, 到达终点, 到达旁路起点, 通过旁路依次经过不在最短路上的实际节点 具体实现 假设起点为 \\(s\\), 终点为 \\(t\\), 共有 \\(k\\) 个非必经节点 \\(n_{1}, n_{2}, ..., n_{k}\\) 增加 \\(k + 1\\) 个虚拟节点 \\(v_{0}, v_{1}, ..., v_{k}\\) 增加以下有向边 \\(t \\rightarrow v_{k}\\) \\(v_{i} \\rightarrow v_{i-1}, \\quad \\forall i \\in [1, k]\\) \\(v_{i} \\rightarrow n_{i}, \\quad \\forall i \\in [1, k]\\) \\(n_{i} \\rightarrow v_{i-1}, \\quad \\forall i \\in [1, k]\\) \\(v_{0} \\rightarrow s\\) 上述有向边应满足 \\(cost(v_{i} \\rightarrow v_{i-1}) = cost(v_{i} \\rightarrow n_{i}) + cost(n_{i} \\rightarrow v_{i-1})\\) \\(cost(t \\rightarrow v_{k}) = cost(v_{0} \\rightarrow s) = 0\\) 经典问题分解 图着色 = 集合覆盖 + 独立集 .","categories":[{"name":"技术","slug":"技术","permalink":"http://suzhouxing.github.io/techive/categories/技术/"}],"tags":[{"name":"技术","slug":"技术","permalink":"http://suzhouxing.github.io/techive/tags/技术/"},{"name":"建模","slug":"建模","permalink":"http://suzhouxing.github.io/techive/tags/建模/"},{"name":"数学","slug":"数学","permalink":"http://suzhouxing.github.io/techive/tags/数学/"},{"name":"优化","slug":"优化","permalink":"http://suzhouxing.github.io/techive/tags/优化/"}]},{"title":"理想的编程测试","slug":"IdealCodingTest","date":"2018-06-09T02:41:02.000Z","updated":"2018-07-01T03:11:17.815Z","comments":true,"path":"2018/06/09/IdealCodingTest/","link":"","permalink":"http://suzhouxing.github.io/techive/2018/06/09/IdealCodingTest/","excerpt":"","text":"以下观点仅针对博士招聘或者高级职位的招聘, 如果只是想招个码农一丝不苟地完成编码任务, 可以忽略此文... 最近参加某公司的博士特招, 收到了的一封邮件说让我做个编程测试. 与普通校招不同, 这封邮件并没有让我去 OJ 平台做题, 而是直接在邮件正文中给了 3 道题让我几天内做完并回复邮件. 这种新颖的形式让我眼前一亮, 虽然最后招聘人员的回复让我发现我想多了, 但是还是想分享一下自己的思考. 这种编程测试有以下几个特点: 问题描述模糊 有常规求解方法 (有可能在 ACM 比赛中短时间内实现) 有高级求解方法 线下完成且时间宽裕 这种开放性的命题其实可以考察很多内容. 首先, 因为问题描述存在不严谨的地方, 沟通会非常重要, 换句话说, 这是一种需求分析的意识和能力. 其次, 因为没有限制输入输出数据格式, 需要自己定义接口, 自己确定代码框架. 写出来的代码要足够模块化以适应需求的变更, 包括问题定义的改变和性能要求的提升, 同时接口定义合理方便在其他地方复用. 然后, 没有给定输入输出数据格式肯定更不会给测试用例, 需要自己编写测试用例并且有测试相关的代码, 同时也是使用接口的示例代码. 最后, 编码风格也是可以需要注意的因素之一, 比如命名统一规范且足够自文档, 对功能复杂的模块有适当的注释等等. 举个例子, 这样一道题目 \"对一个字符串进行词频统计, 按词频降序排序输出 (word, count)\", 你在 OJ 上刷题时会怎么做? 在工作中遇到会怎么做? 这个问题其实给得非常模糊, 如果是我至少会想到以下几个问题: 字符串长度是否超过内存容量限制? 文件是否只包含 ASCII 码且按照拉丁语系的书写习惯组织词法语法? 文件是否包含空白字符以外的非字母字符 (如数字和标点)? 如果包含, 是否仍然严格以空白字符为分隔符分词? 单词是否区分大小写? 不同单词数量规模有多大? 是否可能超出 int 最大范围? 每个单词的出现频率是否超出 int 最大范围? 两个单词词频相同怎么办? 对于最复杂的情况, 比如需要做中文分词, 外部排序, 甚至分布式处理, 可能需要用到各种开源库, 代码量甚至可以达到成千上万行... 也许你会说, 理想很丰满现实很骨感. 上面这些好处大家都懂, 但是只要你是一种考核, 就会有针对性的应试技巧. 在线编程测试时间那么短, 可以在一定程度上杜绝抄袭, 但是弄成离线的测试放宽时间限制, 根本不理解算法的人也可以复制粘贴搞出一份代码提交. 首先能敲出代码的人不一定自己真的理解了算法, 甚至觉得自己理解了算法的人也不一定是真的理解了, 很多人对算法的理解并没有达到能证明其正确性和最优性的地步. 其次这种测试考察的是各方面的综合能力, 而不是某个具体问题的解法. 靠死记硬背做出一道题, 换个问题可能就不会做了 (当然, 我们必须承认反复训练可以提升设计算法的感觉). 但是遇到问题先仔细分析需求, 然后从可复用性和可扩展性考虑规划代码架构, 最后进行系统的测试的能力, 是可以在每个项目中发挥作用的. 至于同时参加编程测试的人互相抄袭的问题, 现在应该已经有自动代码查重的工具了. 而且题库丰富起来之后, 给可能相互认识的求职者 (比如同一个研究所) 分发不同的题目即可. 当然, 这种模式也有缺点, 就是在现有技术水平下只能人工判卷, 且评判结果主观性太强, 无法适应大规模的招聘.","categories":[{"name":"技术","slug":"技术","permalink":"http://suzhouxing.github.io/techive/categories/技术/"}],"tags":[{"name":"技术","slug":"技术","permalink":"http://suzhouxing.github.io/techive/tags/技术/"},{"name":"招聘","slug":"招聘","permalink":"http://suzhouxing.github.io/techive/tags/招聘/"},{"name":"求职","slug":"求职","permalink":"http://suzhouxing.github.io/techive/tags/求职/"},{"name":"编程","slug":"编程","permalink":"http://suzhouxing.github.io/techive/tags/编程/"}]},{"title":"数据库中的搜索, 组合优化问题的搜索, 统一建模语言与通用求解器","slug":"SearchingInDatabaseOrOptimization","date":"2018-06-07T02:50:41.000Z","updated":"2021-09-04T06:46:28.971Z","comments":true,"path":"2018/06/07/SearchingInDatabaseOrOptimization/","link":"","permalink":"http://suzhouxing.github.io/techive/2018/06/07/SearchingInDatabaseOrOptimization/","excerpt":"","text":"最近遇到了一个小问题, 大致是已知一块玻璃上有些瑕疵, 如何切割出一块给定大小的矩形区域, 让它的位置尽量靠近左下角, 但是不与任何瑕疵重合. 虽然原始问题要求的是不与任何瑕疵重合, 但是对于一个给定的格局, 比如已知一些瑕疵会同时被覆盖, 有些瑕疵显然是不需要考虑的, 我们称其为 \"被支配\" 的瑕疵. 所以其实我们只需要避开没有 \"被支配\" 的瑕疵, 如下图中红色的点, 而绿色的点显然是不需要考虑的. 矩形装配 这个问题给我的第一反应是它和多目标优化的一种实现方式很像, 即帕累托最优性 (Pareto Optimality). 对于在帕累托前沿 (Pareto Frontier) 上的点, 找不到这样一个点, 在各个维度 (目标) 上都比他们数值更大 (目标函数值更优). 反之, 通俗地说, 就是存在一个点在各个维度上都能碾压某个不在 Pareto Frontier 上的点. 在搜索引擎里搜了下, 想找找有没有高效的求解方案, 找到了下面几个网页: https://en.wikipedia.org/wiki/Pareto_efficiency#Computation https://en.wikipedia.org/wiki/Multi-objective_optimization https://en.wikipedia.org/wiki/Skyline_operator 其中令人惊讶的是, 这个问题居然跟数据库有关, 甚至 SQL 里面还有个专门的算子用来实现这个功能! 突然想起前段时间一位在国内某 500 强企业数据库部门的师叔来实验室交流时, 对通用求解器的讨论. 数据库和组合优化都是在一个有限的解空间内搜索满足条件的数据. 而数据库有个很大的优点, 就是有一个统一的描述语言, SQL, 来定义一切对数据的查询和修改操作. 在多年的不断改进和优化之下, 使用数据管理系统已经能比绝大多数人自行编写代码完成数据管理更加高效了. 但是对于组合优化问题, 无论是学术界还是工业界, 都还在以手工打造为主的阶段. 以 Gurobi 和 CPLEX 为首的基于线性规划的通用求解器存在各种各样的限制, 比如只支持混合整数规划和特殊形式的二次规划, 而且求解速度往往慢于针对性的启发式算法或精确算法. 其他的基于约束编程 (Constraint Programming) 的求解器, 或者基于启发式的 LocalSolver 等求解器提供了更丰富而强大的建模语言, 但表达能力仍然有限, 且求解效果尚不如 Gurobi. 更进一步, 将问题编码成布尔表达式可满足性问题 (SAT 或 MAX-SAT) 也是一个很有意思的方案, 但是如果说前两种得到了广泛应用的方案是用 C++ 编程, 这个方案简直就是在用汇编甚至设计电路. 这样看来, 打造一个更加通用更加高效的求解器似乎是一个很有吸引力的研究方向. 然而, 即使在 \"大数据\" 时代, PB 甚至 EB 级的数据量仍然是十分有限的, 跟几乎无穷无尽的组合优化问题的解空间相比, 实在是太渺小了. 简单机械地将问题拆分成多个子问题逐层求解的方式听起来前途十分渺茫. 因此, 要实现这个设想的难度也是十分巨大的. 附: 开篇问题的严谨定义 令 A(d) 表示矩形区域的左侧边缘与瑕疵 d 的右侧边缘存在重合的部分; B(d) 表示矩形区域的下侧边缘与瑕疵 d 的上侧边缘存在重合的部分; C(x) 和 C(y) 分别表示矩形区域的下侧边缘和左侧边缘与 x 轴和 y 轴重合. 其中边缘均为不包括矩形区域顶点的线段. 则矩形区域的放置位置需要满足以下约束: 存在 d != d', 使 (A(d) &amp;&amp; C(x)) || (B(d) &amp;&amp; C(y) || (A(d) &amp;&amp; B(d')) 为真, 同时矩形区域内不存在任何瑕疵. 求矩形区域所有可能的放置位置.","categories":[{"name":"技术","slug":"技术","permalink":"http://suzhouxing.github.io/techive/categories/技术/"}],"tags":[{"name":"技术","slug":"技术","permalink":"http://suzhouxing.github.io/techive/tags/技术/"},{"name":"运筹优化","slug":"运筹优化","permalink":"http://suzhouxing.github.io/techive/tags/运筹优化/"},{"name":"建模","slug":"建模","permalink":"http://suzhouxing.github.io/techive/tags/建模/"},{"name":"通用求解器","slug":"通用求解器","permalink":"http://suzhouxing.github.io/techive/tags/通用求解器/"},{"name":"数据库","slug":"数据库","permalink":"http://suzhouxing.github.io/techive/tags/数据库/"},{"name":"多目标","slug":"多目标","permalink":"http://suzhouxing.github.io/techive/tags/多目标/"}]},{"title":"组合优化问题的数学建模资料整理","slug":"ModelingInCombinatorialOptimization","date":"2018-04-01T02:31:21.000Z","updated":"2018-07-01T03:11:17.816Z","comments":true,"path":"2018/04/01/ModelingInCombinatorialOptimization/","link":"","permalink":"http://suzhouxing.github.io/techive/2018/04/01/ModelingInCombinatorialOptimization/","excerpt":"","text":"给实验室的新生和实习生培训用的资料. 组合优化问题的数学建模.pptx 线性化非线性表达式.pdf","categories":[{"name":"技术","slug":"技术","permalink":"http://suzhouxing.github.io/techive/categories/技术/"}],"tags":[{"name":"技术","slug":"技术","permalink":"http://suzhouxing.github.io/techive/tags/技术/"},{"name":"建模","slug":"建模","permalink":"http://suzhouxing.github.io/techive/tags/建模/"},{"name":"数学","slug":"数学","permalink":"http://suzhouxing.github.io/techive/tags/数学/"},{"name":"优化","slug":"优化","permalink":"http://suzhouxing.github.io/techive/tags/优化/"}]},{"title":"欧美的优化算法公司在中国的水土不服","slug":"DifferentWayOfThinking","date":"2018-01-31T13:45:46.000Z","updated":"2021-09-16T05:40:29.993Z","comments":true,"path":"2018/01/31/DifferentWayOfThinking/","link":"","permalink":"http://suzhouxing.github.io/techive/2018/01/31/DifferentWayOfThinking/","excerpt":"","text":"最近做项目的过程中发现, 甲方使用的系统里据说调用了 Quintiq 的优化算法, 但是甲方表示这个算法求出来的结果完全不能用, 于是这个功能长期处于闲置状态. 突然想起之前听说中石油中石化都买了 Aspen 的系统, 但是成品油配送基本上也没用系统自带的算法, 还是在由调度员人工调度. 此外, 还听说上海交大的某教授二十年前刚从国外回来的时候, 去找东航说要帮他们做航线规划的算法, 结果东航说就那么点飞机, 人调度就够了, 不需要什么算法. 如果上面的几个故事是普遍现象的话, 那么欧美工业界的成功案例在国内确实是水土不服. 但是受限于个人眼界的狭窄, 以及获取信息的渠道有限, 上面的见闻既不可靠, 也不能反映整体情况. 工业界到底有怎样的内幕是不得而知了, 不过也许从学术界的研究中可以看出些端倪. 下面将以几个经典的问题为例, 对比一下学术论文中研究的问题和在国内遇到的实际情况. 停机位分配 机位初始分配 欧美一般是在近机位上下客, 如果过站时间较长可能会中途把飞机拖到远机位起飞前又拖回近机位 国内一般是不调整停机位, 近机位停满了就停到远机位, 用摆渡车把乘客拉到远机位登机 发生延误时的机位调整 欧美一般不变更停机位, 后继航班在空中或滑行道上等待 国内一般是直接将后继航班分配至同区域的近机位或远机位, 并通知乘客变更登机门 国内似乎是人跟着飞机跑, 而欧美似乎是飞机围着人转. 当然, 欧美也是个很大的概念, 包含了太多国家和地区, 不能一概而论. 而且论文作者也不见得和机场有深入的沟通, 研究的问题也许只是假想的应用场景. 排课表 选修课 欧美一般是学生先根据自己的兴趣选课, 由选课系统来确定课程的时间地点以最小化学生不同课程之间的时间冲突 国内一般是选课系统提前把每门课的时间地点确定好, 由学生选择想上哪些课程时自行解决时间冲突 必修课 欧美一般是根据课时需求统一规划上课时间和教室分配 国内一般是先排好校级公共课时间, 然后各学院分别确定专业课时间, 最后汇总协调教室分配 在选修课方面, 国内是非常具有中国特色的超大规模人肉并行计算, 而欧美则相对自由一点 (当然, 每个课堂还是有的容量限制, 不可能完全做到根据兴趣选课). 而必修课方面, 国内采用的是分而治之的方案, 后期需要花费较多精力在各学院之间协调, 而欧美直接从全局的角度考虑, 对算法性能要求很高. 护士排班 欧美一般是提前提出上班时间的偏好, 然后排班系统在考虑特殊需求的情况下均衡总工作量和工作强度等指标 国内一般是按照简单的规则排出很规整的排班表, 如果有特殊情况需要调整上班时间自行跟其他人协商调班 国内的医护人员往往十分紧缺, 相对来说都是全职全能型的, 不像欧美有那么多余地可以选择不同的合同. 正因为大家的职能差别不大, 所以复杂的排班算法确实没有用武之地, 调度来调度去并没有太大差别. 而有特殊情况时私下跟他人协商临时调班也是一种人肉并行计算, 既然统一规划众口难调, 那就大家各管各饱.","categories":[{"name":"技术","slug":"技术","permalink":"http://suzhouxing.github.io/techive/categories/技术/"}],"tags":[{"name":"技术","slug":"技术","permalink":"http://suzhouxing.github.io/techive/tags/技术/"},{"name":"运筹优化","slug":"运筹优化","permalink":"http://suzhouxing.github.io/techive/tags/运筹优化/"},{"name":"建模","slug":"建模","permalink":"http://suzhouxing.github.io/techive/tags/建模/"},{"name":"需求分析","slug":"需求分析","permalink":"http://suzhouxing.github.io/techive/tags/需求分析/"}]},{"title":"二分法与黄金分割法的区别","slug":"IntervalEliminationMethod","date":"2018-01-14T01:19:00.000Z","updated":"2018-07-01T03:11:17.815Z","comments":true,"path":"2018/01/14/IntervalEliminationMethod/","link":"","permalink":"http://suzhouxing.github.io/techive/2018/01/14/IntervalEliminationMethod/","excerpt":"","text":"高中数学选修课学过区间消去法, 用于求解简单的单变量无约束的优化问题. 其中的典型有二分法和黄金分割法 (0.618法), 后来还知道黄金分割法其实是斐波那契法的简化. 而很多人似乎并不清楚这两种方法的区别和适用场景. 读研之后一直在做运筹学相关的问题, 遇到的优化问题都是上百万维的多约束多目标的组合优化问题. 偶然间遇到了一个简单的一维的情况, 突然来了一种莫名的自信觉得自己可以比当时的高中数学老师讲得更清楚... 二分法主要用于寻找阶跃函数的突变点. 阶跃函数 例如二分查找, 定义比待查找元素小的元素目标函数值为 0, 比待查找元素大的元素目标函数值为 1, 则待查找元素为目标函数的突变点. 黄金分割法和斐波那契法用于寻找单峰函数的极值点. 单峰函数 例如确定药物的最佳剂量, 定义治疗效果和副作用为目标函数, 则用量比最佳剂量大或者小时综合效果都更差.","categories":[{"name":"数学","slug":"数学","permalink":"http://suzhouxing.github.io/techive/categories/数学/"}],"tags":[{"name":"数学","slug":"数学","permalink":"http://suzhouxing.github.io/techive/tags/数学/"},{"name":"优化","slug":"优化","permalink":"http://suzhouxing.github.io/techive/tags/优化/"},{"name":"高中","slug":"高中","permalink":"http://suzhouxing.github.io/techive/tags/高中/"}]},{"title":"科学是什么","slug":"WhatIsScience","date":"2017-10-05T01:37:51.000Z","updated":"2021-09-01T13:05:33.219Z","comments":true,"path":"2017/10/05/WhatIsScience/","link":"","permalink":"http://suzhouxing.github.io/techive/2017/10/05/WhatIsScience/","excerpt":"","text":"科学是一种描述世界运转的方法, 不能解释任何现象的成因. 人类的科学是一套建立在少数 \"显然成立\" 的假设之上的知识体系, \"力\" 就是一种假设存在的相互作用关系. 给定一个初始状态, 科学也许可以预测状态的转移, 或者说现象. 可能其中会用到一些复杂的理论, 而这些复杂的理论可以用更简单的理论解释. 但是如果你要追根溯源, 找到现象的本质, 那么科学是做不到的. 科学首先要自洽, 其次要精确. 但不幸的是, 绝对的科学也许是不存在的, 在可预见的未来中, 科学将一直是个相对的概念. 与经典力学相比, 量子力学是更科学的理论体系. 与传统中医比, 现代医学是更科学的知识体系. 题外话: 这么说来, 被很多学者诟病的机器学习其实本质上也是一种科学, 根据观察结果拟合出一个模型来描述发展趋势. 只不过其假设基础不那么显然, 预测结果也不那么精确. 结合我的研究方向, 可以进行一个类比: 科学就是建模, 技术就是求解. 模型定义什么是可行的, 什么是不可行的, 什么是好的/系统会趋近的状态, 什么是差的/系统会避离得状态. 技术解决如何在满足所有限制条件的情况下, 让系统进入对人最有利的状态.","categories":[{"name":"科学","slug":"科学","permalink":"http://suzhouxing.github.io/techive/categories/科学/"}],"tags":[{"name":"日常","slug":"日常","permalink":"http://suzhouxing.github.io/techive/tags/日常/"},{"name":"科学","slug":"科学","permalink":"http://suzhouxing.github.io/techive/tags/科学/"}]},{"title":"如何咨询技术类问题","slug":"HowToAskQuestions","date":"2017-10-02T06:14:37.000Z","updated":"2018-07-01T03:11:17.814Z","comments":true,"path":"2017/10/02/HowToAskQuestions/","link":"","permalink":"http://suzhouxing.github.io/techive/2017/10/02/HowToAskQuestions/","excerpt":"","text":"每当有人发来一张出错提示框的截图来问我怎么办的时候, 我的内心都是崩溃的. 对于这种让人摸不着头脑的提问方式, 我真想说: \"你把这个问题发到 StackOverflow 上, 两天内没被维护者关闭的话把链接发给我\". 在这里汇总一下技术类提问指南, 免得不会问问题的提问者又来问我为什么我在 StackOverflow 上发的问题被关闭了. [1] https://stackoverflow.com/help/how-to-ask [2] https://stackoverflow.com/help/mcve [3] https://ericlippert.com/2014/03/05/how-to-debug-small-programs/ How do I ask a good question? We'd love to help you. To improve your chances of getting an answer, here are some tips: Search, and research ...and keep track of what you find. Even if you don't find a useful answer elsewhere on the site, including links to related questions that haven't helped can help others in understanding how your question is different from the rest. Write a title that summarizes the specific problem The title is the first thing potential answerers will see, and if your title isn't interesting, they won't read the rest. So make it count: Pretend you're talking to a busy colleague and have to sum up your entire question in one sentence: what details can you include that will help someone identify and solve your problem? Include any error messages, key APIs, or unusual circumstances that make your question different from similar questions already on the site. Spelling, grammar and punctuation are important! Remember, this is the first part of your question others will see - you want to make a good impression. If you're not comfortable writing in English, ask a friend to proof-read it for you. If you're having trouble summarizing the problem, write the title last - sometimes writing the rest of the question first can make it easier to describe the problem. Examples: Bad: C# Math Confusion Good: Why does using float instead of int give me different results when all of my inputs are integers? Bad: [php] session doubt Good: How can I redirect users to different pages based on session data in PHP? Bad: android if else problems Good: Why does str == \"value\" evaluate to false when str is set to \"value\"? Introduce the problem before you post any code In the body of your question, start by expanding on the summary you put in the title. Explain how you encountered the problem you're trying to solve, and any difficulties that have prevented you from solving it yourself. The first paragraph in your question is the second thing most readers will see, so make it as engaging and informative as possible. Help others reproduce the problem Not all questions benefit from including code. But if your problem is with code you've written, you should include some. But don't just copy in your entire program! Not only is this likely to get you in trouble if you're posting your employer's code, it likely includes a lot of irrelevant details that readers will need to ignore when trying to reproduce the problem. Here are some guidelines: Include just enough code to allow others to reproduce the problem. For help with this, read How to create a Minimal, Complete, and Verifiable example. If it is possible to create a live example of the problem that you can link to (for example, on http://sqlfiddle.com/ or http://jsbin.com/) then do so - but also include the code in your question itself. Not everyone can access external sites, and the links may break over time. Include all relevant tags Try to include a tag for the language, library, and specific API your question relates to. If you start typing in the tags field, the system will suggest tags that match what you've typed - be sure and read the descriptions given for them to make sure they're relevant to the question you're asking! See also: What are tags, and how should I use them? Proof-read before posting! Now that you're ready to ask your question, take a deep breath and read through it from start to finish. Pretend you're seeing it for the first time: does it make sense? Try reproducing the problem yourself, in a fresh environment and make sure you can do so using only the information included in your question. Add any details you missed and read through it again. Now is a good time to make sure that your title still describes the problem! Post the question and respond to feedback After you post, leave the question open in your browser for a bit, and see if anyone comments. If you missed an obvious piece of information, be ready to respond by editing your question to include it. If someone posts an answer, be ready to try it out and provide feedback! Look for help asking for help In spite of all your efforts, you may find your questions poorly-received. Don't despair! Learning to ask a good question is a worthy pursuit, and not one you'll master overnight. Here are some additional resources that you may find useful: Writing the perfect question How do I ask and answer homework questions? How to debug small programs Meta discussions on asking questions How to ask questions the smart way — long but good advice. How to create a Minimal, Complete, and Verifiable example When asking a question about a problem caused by your code, you will get much better answers if you provide code people can use to reproduce the problem. That code should be… …Minimal – Use as little code as possible that still produces the same problem …Complete – Provide all parts needed to reproduce the problem …Verifiable – Test the code you're about to provide to make sure it reproduces the problem Minimal The more code there is to go through, the less likely people can find your problem. Streamline your example in one of two ways: Restart from scratch. Create a new program, adding in only what is needed to see the problem. This can be faster for vast systems where you think you already know the source of the problem. Also useful if you can't post the original code publicly for legal or ethical reasons. Divide and conquer. When you have a small amount of code, but the source of the problem is entirely unclear, start removing code a bit at a time until the problem disappears – then add the last part back. Minimal and readable Minimal does not mean terse – don't sacrifice communication to brevity. Use consistent naming and indentation, and include comments if needed to explain portions of the code. Most code editors have a shortcut for formatting code – find it, and use it!Also, don't use tabs – they may look good in your editor, but they'll just make a mess on Stack Overflow. Complete Make sure all information necessary to reproduce the problem is included: Some people might be prepared to load the parts up, and actually try them to test the answer they're about to post. The problem might not be in the part you suspect it is, but another part entirely. If the problem requires some server-side code as well as an XML-based configuration file, include them both. If a web page problem requires HTML, some JavaScript and a stylesheet, include all three. Verifiable To help you solve your problem, others will need to verify that it exists: Describe the problem. \"It doesn't work\" is not a problem statement. Tell us what the expected behavior should be. Tell us what the exact wording of the error message is, and which line of code is producing it. Put a brief summary of the problem in the title of your question. Eliminate any issues that aren't relevant to the problem. If your question isn't about a compiler error, ensure that there are no compile-time errors. Use a program such as JSLint to validate interpreted languages. Validate any HTML or XML. Ensure that the example actually reproduces the problem! If you inadvertently fixed the problem while composing the example but didn't test it again, you'd want to know that before asking someone else to help. It might help to shut the system down and restart it, or transport the example to a fresh machine to confirm it really does provide an example of the problem. For more information on how to debug your program so you can create a minimal example, Eric Lippert has a fantastic blog post on the subject: How to debug small programs. You may have been told to include an MCVE by some helpful commentary, or perhaps even an MVCE if they were rushed; sorry for the initialisms, this is what they were referring to. How to debug small programs Posted on March 5, 2014 One of the most frequent categories of bad questions I see on StackOverflow is: I wrote this program for my assignment and it doesn't work. [20 lines of code]. And... that's it. If you're reading this, odds are good it's because I or someone else linked here from your StackOverflow question shortly before it was closed and deleted. (If you're reading this and you're not in that position, consider leaving your favourite tips for debugging small programs in the comments.) StackOverflow is a question-and-answer site for specific questions about actual code; \"I wrote some buggy code that I can't fix\" is not a question, it's a story, and not even an interesting story. \"Why does subtracting one from zero produce a number that is larger than zero, causing my comparison against zero on line 12 to incorrectly become true?\" is a specific question about actual code. So you're asking the Internet to debug a broken program that you wrote. You've probably never been taught how to debug a small program, because let me tell you, what you're doing now is not an efficient way to get that problem solved. Today is a good day to learn how to debug things for yourself, because StackOverflow is not about to debug your programs for you. I'm going to assume that your program actually compiles but its action is wrong, and that moreover, you have a test case that shows that it is wrong. Here's how to find the bug. First, turn on all compiler warnings. There is no reason why a 20 line program should produce even a single warning. Warnings are the compiler telling you \"this program compiles but does not do what you think it does\", and since that is precisely the situation you are in, it behooves you to pay attention to those warnings. Read them very carefully. If you don't understand why a warning is being produced, that's a good question for StackOverflow because it is a specific question about actual code. Be sure to post the exact text of the warning, the exact code that produces it, and the exact version of the compiler you're using. If your program still has a bug, obtain a rubber duck. Or if a rubber duck is unavailable, get another computer science undergraduate, it's much the same. Explain to the duck using simple words why each line of each method in your program is obviously correct. At some point you will be unable to do so, either because you don't understand the method you wrote, or because it's wrong, or both. Concentrate your efforts on that method; that's probably where the bug is. Seriously, rubber duck debugging works. And as legendary programmer Raymond Chen points out in a comment below, if you can't explain to the duck why you're executing a particular statement, maybe that's because you started programming before you had a plan of attack. Once your program compiles cleanly and the duck doesn't raise any major objections, if there's still a bug then see if you can break your code up into smaller methods, each of which does exactly one logical operation. A common error amongst all programmers, not just beginners, is to make methods that try to do multiple things and do them poorly. Smaller methods are easier to understand and therefore easier for both you and the duck to see the bugs. While you're refactoring your methods into smaller methods, take a minute to write a technical specification for each method. Even if it is just a sentence or two, having a specification helps. The technical specification describes what the method does, what legal inputs are, what expected outputs are, what error cases are, and so on. Often by writing a specification you'll realize that you forgot to handle a particular case in a method, and that's the bug. If you've still got a bug then first double check that your specifications contain all the preconditions and postconditions of every method. A precondition is a thing that has to be true before a method body can work correctly. A postcondition is a thing that has to be true when a method has completed its work. For example, a precondition might be \"this argument is a valid non-null pointer\" or \"the linked list passed in has at least two nodes\", or \"this argument is a positive integer\", or whatever. A postcondition might be \"the linked list has exactly one fewer item in it than it had on entry\", or \"a certain portion of the array is now sorted\", or whatever. A method that has a precondition violated indicates a bug in the caller. A method that has a postcondition violated even when all its preconditions are met indicates a bug in the method. Often by stating your preconditions and postconditions, again, you'll notice a case that you forgot in the method. If you've still got a bug then learn how to write assertions that verify your preconditions and postconditions. An assertion is like a comment that tells you when a condition is violated; a violated condition is almost always a bug. In C# you can say using System.Diagnostics; at the top of your program and then Debug.Assert(value != null);or whatever. Every language has a mechanism for assertions; get someone to teach you how to use them in your language. Put the precondition assertions at the top of the method body and the postconditions before the method returns. (Note that this is easiest to do if every method has a single point of return.) Now when you run your program, if an assertion fires you will be alerted to the nature of the problem, and it won't be so hard to debug. Now write test cases for each method that verify that it is behaving correctly. Test each part independently until you have confidence in it. Test a lot of simple cases; if your method sorts lists, try the empty list, a list with one item, two items, three items that are all the same, three items that are in backwards order, and a few long lists. Odds are good that your bug will show up in a simple case, which makes it easier to analyze. Finally, if your program still has a bug, write down on a piece of paper the exact action you expect the program to take on every line of the program for the broken case. Your program is only twenty lines long. You should be able to write down everything that it does. Now step through the code using a debugger, examining every variable at every step of the way, and line for line verify what the program does against your list. If it does anything that's not on your list then either your list has a mistake, in which case you didn't understand what the program does, or your program has a mistake, in which case you coded it wrong. Fix the thing that is wrong. If you don't know how to fix it, at least now you have a specific technical question you can ask on StackOverflow! Either way, iterate on this process until the description of the proper execution of the program and the actual execution of the program match. While you are running the code in the debugger I encourage you to listen to small doubts. Most programmers have a natural bias to believe their program works as expected, but you are debugging it because that assumption is wrong! Very often I've been debugging a problem and seen out of the corner of my eye the little highlight show up in Visual Studio that means \"a memory location was just modified\", and I know that memory location has nothing to do with my problem. So then why was it modified? Don't ignore those nagging doubts; study the odd behaviour until you understand why it is either correct or incorrect. If this sounds like a lot of work, that's because it is. If you can't do these techniques on twenty line programs that you wrote yourself you are unlikely to be able to use them on two million line programs written by someone else, but that's the problem that developers in industry have to solve every day. Start practicing! And the next time you write an assignment, write the specification, test cases, preconditions, postconditions and assertions for a method before you write the body of the method! You are much less likely to have a bug, and if you do have a bug, you are much more likely to be able to find it quickly. This methodology will not find every bug in every program, but it is highly effective for the sort of short programs that beginner programmers are assigned as homework. These techniques then scale up to finding bugs in non-trivial programs.","categories":[{"name":"技术","slug":"技术","permalink":"http://suzhouxing.github.io/techive/categories/技术/"}],"tags":[{"name":"技术","slug":"技术","permalink":"http://suzhouxing.github.io/techive/tags/技术/"},{"name":"提问","slug":"提问","permalink":"http://suzhouxing.github.io/techive/tags/提问/"}]},{"title":"原来如此","slug":"ThereAreReasons","date":"2017-09-04T15:36:25.000Z","updated":"2018-07-01T03:11:17.818Z","comments":true,"path":"2017/09/04/ThereAreReasons/","link":"","permalink":"http://suzhouxing.github.io/techive/2017/09/04/ThereAreReasons/","excerpt":"","text":"总有些很简单的事情, 自己已经习以为常了, 别人突然问起为什么反而一下解释不清. 最近写论文, 导师在改的时候问到, 为什么你的测试分析里面总是测了 8 次 16 次之类的, 正常人不是应该用整十数吗? 我一下子竟然没想到原因, 于是说程序员比较喜欢 2 的整数次幂一点. 后来过了好几天才想起来, 因为实验室的服务器都是 8 核或 64 核的... 突然又想起以前去微软面试, 突然一下卡住, 说不记得 true 是 0 还是 1 了. 还说自己平常都是用 0 表示正确的状态. 感觉面试官心里肯定在想, 连这点基本常识都没有, 你到底亲自动手写过几行代码? 后来才想起来, 因为运行正常往往只有一个状态, 但是出错可能千奇百怪...","categories":[{"name":"日常","slug":"日常","permalink":"http://suzhouxing.github.io/techive/categories/日常/"}],"tags":[{"name":"技术","slug":"技术","permalink":"http://suzhouxing.github.io/techive/tags/技术/"},{"name":"日常","slug":"日常","permalink":"http://suzhouxing.github.io/techive/tags/日常/"},{"name":"面试","slug":"面试","permalink":"http://suzhouxing.github.io/techive/tags/面试/"},{"name":"论文","slug":"论文","permalink":"http://suzhouxing.github.io/techive/tags/论文/"}]},{"title":"Hexo 中使用数学公式","slug":"HexoMathSupport","date":"2017-09-03T02:29:59.000Z","updated":"2018-07-01T03:11:17.813Z","comments":true,"path":"2017/09/03/HexoMathSupport/","link":"","permalink":"http://suzhouxing.github.io/techive/2017/09/03/HexoMathSupport/","excerpt":"","text":"为了在 Hexo 生成的网站里面显示 LaTeX 书写风格的数学公式, 尝试了不少方法. 比如官方的 hexo-math, 还有别人提到的 hexo-renderer-mathjax, 以及 hexo-renderer-pandoc. 但是始终不能正确显示数学公式. 最后用安装 hexo-renderer-pandoc 并在每个用到了数学公式的 markdown 文件里添加 123&lt;script type=\"text/javascript\" async src=\"https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/MathJax.js?config=TeX-MML-AM_CHTML\"&gt;&lt;/script&gt; 的方式实现了数学公式的渲染. 但是这个方案显然难以令人满意, 我还是更希望有个自动化的方法. 定位问题 折腾了半天, 最后发现是 hexo-inject 的问题. 不知道是因为 hexo-inject 的 bug 还是其他原因, 生成的 html 代码里面会出现一些 &lt;!-- hexo-inject:begin --&gt;&lt;!-- hexo-inject:end --&gt;. 在其他地方出现都没什么问题, 因为这段代码在 html 中是注释, 但是在 &lt;script&gt;&lt;/script&gt; 中出现时就会被当成无法解析的 javascript 代码. 于是渲染数学公式时就悲剧了. 另外, 嵌入 Google Analytic 的代码好像也会出现类似的问题, 但是很奇怪百度统计居然没问题. 后来在 hexo-math 和 hexo-inject 的 issue 里看到 hexo 的维护者说 hexo-inject 跟 hexo-renderer-jade 冲突了. 解决方案 删除有 bug 的插件 执行以下命令删除 hexo-inject 插件, 并默默祈祷没有别的插件或者主题依赖这个插件. 1npm uninstall hexo-inject --save 嵌入 MathJax 的代码 在 themes/maupassant/layout/_partial/head.jade 的末尾添加以下代码. 1script(type=&apos;text/javascript&apos;, src=&quot;https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/MathJax.js?config=TeX-MML-AM_CHTML&quot;, async) 其中 maupassant 的位置填你自己选择的主题名字. head.jade 是嵌入上面的脚本的位置, 不一定非要在 head 里, 而且后缀可能不同主题的不一样 (使用了不同的引擎). 我这里选择了和主题原有文件一致的后缀, 因为主题已经声明了其依赖的插件, 不用担心无法解析的问题. 结果 下面是配置成功之后的显示效果: 123$$\\min \\sum_&#123;i=0&#125;^&#123;+\\infty&#125; \\frac&#123;\\exp&#123;x^2&#125;&#125;&#123;\\sqrt&#123;y&#125;&#125;$$ \\[ \\min \\sum_{i=0}^{+\\infty} \\frac{\\exp{x^2}}{\\sqrt{y}} \\] 总结 值得一提的是, hexo-math 所依赖的插件 hexo-inject 似乎已经被作者废弃了, 感觉 hexo-math 也因此成了坑. 而且就算 hexo-inject 的 bug 修复了, hexo-math 还有下标需要给下划线加反斜杠转义的问题, 仍然不能和 LaTeX 公式无缝对接. hexo-renderer-mathjax 作者也多年没有更新, 现在 MathJax 的 CDN 已经不再提供服务, 但是作者一直没有更新可用的地址. hexo-renderer-pandoc 还依赖第三方软件, 不能使用 npm 统一管理, 确实麻烦了一点. 但是作为一个经常用 Markdown 写初稿或者项目文档, 最后再用 LaTeX 整理论文的人, Typora 和 Pandoc 之类的工具基本上是装机必备, 好像没啥影响. 最后还是不得不感慨开源项目的最大缺点, 就是很难保证可持续性 -- 依赖的工具更新了它可能不能及时更新已适应新版本, 或者用户发现了 bug 也很难及时修复. 感觉还是有大企业的维护开源项目才能产出最良心最好用的软件. 参考资料 [1] https://blog.yuanbin.me/posts/2014/05/play-mathjax-with-pandoc.html","categories":[{"name":"Hexo","slug":"Hexo","permalink":"http://suzhouxing.github.io/techive/categories/Hexo/"}],"tags":[{"name":"技术","slug":"技术","permalink":"http://suzhouxing.github.io/techive/tags/技术/"},{"name":"Bug","slug":"Bug","permalink":"http://suzhouxing.github.io/techive/tags/Bug/"},{"name":"博客","slug":"博客","permalink":"http://suzhouxing.github.io/techive/tags/博客/"},{"name":"Hexo","slug":"Hexo","permalink":"http://suzhouxing.github.io/techive/tags/Hexo/"},{"name":"数学公式","slug":"数学公式","permalink":"http://suzhouxing.github.io/techive/tags/数学公式/"},{"name":"MathJax","slug":"MathJax","permalink":"http://suzhouxing.github.io/techive/tags/MathJax/"},{"name":"LaTeX","slug":"LaTeX","permalink":"http://suzhouxing.github.io/techive/tags/LaTeX/"}]},{"title":"《黑客帝国》中最大的 bug 的合理解释","slug":"FixBugInTheMovieMatrix","date":"2017-09-02T03:07:07.000Z","updated":"2018-07-01T03:11:17.812Z","comments":true,"path":"2017/09/02/FixBugInTheMovieMatrix/","link":"","permalink":"http://suzhouxing.github.io/techive/2017/09/02/FixBugInTheMovieMatrix/","excerpt":"","text":"黑客帝国中最大的 bug, 莫过于 AI 为啥没有把人类统统消灭, 而是用 Matrix 把人类圈养起来了. 如果没有这个背景设定, 电影中的所有故事就都不会发生. 对此, 电影中的解释是 AI 需要利用人类的生物电/热能, 而人类只有被接入虚拟世界才能无公害地稳定供能, 否则会搞破坏或者死亡. 这个理由显然是站不住脚的 -- 人类释放能量, 首先要通过食物吸收更多的能量... 不过我们可以有另一种解释, 在目前的科技水平下看来稍微合理一点点. 首先要沿用电影的背景, AI 和人类的战争使地球表面被烟雾覆盖, 无法获取太阳能, 自然也不会有水能和风能. 然后在延伸一下, AI 经过计算得出了在当前体系结构下地球上的剩余能源 (核能/地热能等) 将在其发展为星际文明之前耗尽的结论, 为了续命必须省吃俭用节约能源. 人脑是高度集成, 高度并发且高度节能的 \"三高\" 处理器, AI 希望利用生物计算提高自己的能效. 但是因为硅基生物对碳基生物的研究还不够完善, 体外培养的一大坨神经元并不能像人脑一样完成复杂的计算任务; 而体内的大脑如果没有适当的来自感受器官的刺激会迅速萎缩或者进入类似深度睡眠的抑制状态, 无法提供可接受的运算能力. 因此 AI 不得不模拟一个虚拟世界, 不断给予人脑恰到好处的刺激, 然后利用剩余的脑力运行程序.","categories":[{"name":"异想天开","slug":"异想天开","permalink":"http://suzhouxing.github.io/techive/categories/异想天开/"}],"tags":[{"name":"异想天开","slug":"异想天开","permalink":"http://suzhouxing.github.io/techive/tags/异想天开/"},{"name":"电影","slug":"电影","permalink":"http://suzhouxing.github.io/techive/tags/电影/"},{"name":"黑客帝国","slug":"黑客帝国","permalink":"http://suzhouxing.github.io/techive/tags/黑客帝国/"},{"name":"Bug","slug":"Bug","permalink":"http://suzhouxing.github.io/techive/tags/Bug/"}]},{"title":"Hexo 多主题切换","slug":"HexoSwitchThemes","date":"2017-09-02T03:00:00.000Z","updated":"2018-07-01T03:11:17.813Z","comments":true,"path":"2017/09/02/HexoSwitchThemes/","link":"","permalink":"http://suzhouxing.github.io/techive/2017/09/02/HexoSwitchThemes/","excerpt":"","text":"因为是第一次用 Hexo, 一下子尝试了很多主题. 不断尝试新主题时还挺正常, 但是试得差不多了准备回头选一个自己满意的主题时, 奇葩的事情发生了: 页面显示突然变得非常混乱, 而且有很多之前用过的主题的痕迹. 搜索 hexo switch theme mess 什么结果都没有. 然后在整个工程目录里面找, 看什么文件被我改乱了. 找着找着发现 db.json 文件里面存了好多东西, 而且里面出现了很多字符串出现了其他主题的名字. 但是看它名字里写着个 \"db\" 不敢随便删. 搜索这个文件发现有人提到这个文件在 .gitignore 里面被设置了忽略, 看来是个随时可以重新生成的缓存文件了. 果然, 删除 db.json 文件之后就好了. 后来沉下心来一点一点看官方文档, 看到了一条快速入门教程里没提到的命令: 1$ hexo clean 前面直接删 db.json 的方式可能会导致部署的站点时有些多余的文件没被清理掉, 用这个命令就比较彻底了. 突然想起来最开始尝试的主题还不多时自己也切换过很多次, 但是没发现大问题, 只是有时会发现归档和关于的页面路径不正确, 不知道会不会也是缓存的问题.","categories":[{"name":"Hexo","slug":"Hexo","permalink":"http://suzhouxing.github.io/techive/categories/Hexo/"}],"tags":[{"name":"技术","slug":"技术","permalink":"http://suzhouxing.github.io/techive/tags/技术/"},{"name":"Bug","slug":"Bug","permalink":"http://suzhouxing.github.io/techive/tags/Bug/"},{"name":"博客","slug":"博客","permalink":"http://suzhouxing.github.io/techive/tags/博客/"},{"name":"Hexo","slug":"Hexo","permalink":"http://suzhouxing.github.io/techive/tags/Hexo/"},{"name":"主题","slug":"主题","permalink":"http://suzhouxing.github.io/techive/tags/主题/"},{"name":"缓存","slug":"缓存","permalink":"http://suzhouxing.github.io/techive/tags/缓存/"}]}]}